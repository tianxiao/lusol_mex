<!DOCTYPE html
	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
<title>Implementation of file lusol.f</title>
<link rev="made" href="mailto:nwh" />
<base href="." target="source" />
<link rel="stylesheet" type="text/css" href="ftagshtml.css" />
<script type="text/javascript">//<![CDATA[
// Javascript functions for lusol.f.
function LienDynamique(document2){
   top.index.location=document2 ;
}
function JavaDynamique(document2){
   top.source.location=document2 ;
}

//]]></script>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
</head>
<body link="BLUE" alink="GREEN" vlink="#9910DD" bgcolor="WHITE" text="BLACK">

<A NAME=R_lusol_f></A><H1 align=center><a target="java" href="lusol_f_LF.html" onclick="LienDynamique('lusol_f_i.html#R_lusol_f')">lusol.f</a></H1>
<H2 align=center><H3 align=center>Last modified 10/11/2010@12h13m19s.</H3></H2>
<CENTER>
<table border="2" cellpadding="7" bgcolor="#AAFFC0" width="100%">
<TR>
<th align="right"><a onmouseover="window.status='Files Index: lusol.f.'; return true" target="source" href="fileindex_c.html#R_lusol_f">Files</a></th>
<th align="right"><a onmouseover="window.status='Routine Index.'; return true" target="source" href="routineindex_c.html#R_lusol_f">Routines</a></th>
<th align="right"><a onmouseover="window.status='Functions Index.'; return true" target="source" href="functionindex_c.html#R_lusol_f">Functions</a></th>
<th align="right"><a target="source" href="externalindex_c.html">Externals</a></th>
<th align="right"><a onmouseover="window.status='Search Index.'; return true" target="source" href="javanavig_c.html">JavaForm</a></th>
</TR>
</table>
</CENTER>
<a onmouseover="window.status='Source file lusol.f'; return true" target="source" href="../lusol.f">View source file</a>
<img width="100%" src="color.gif" />
<PRE>

<COMMENT><HR></HR>

     File lusol1.f

     lu1fac   lu1fad   lu1gau   lu1mar   lu1mRP   lu1mCP   lu1mSP
     lu1pen   lu1mxc   lu1mxr   lu1or1   lu1or2   lu1or3   lu1or4
     lu1pq1   lu1pq2   lu1pq3   lu1rec   lu1slk
     lu1ful   lu1DPP   lu1DCP

 26 Apr 2002: TCP implemented using heap data structure.
 01 May 2002: lu1DCP implemented.
 07 May 2002: lu1mxc must put 0.0 at top of empty columns.
 09 May 2002: lu1mCP implements Markowitz with cols searched
              in heap order.
              Often faster (searching 20 or 40 cols) but more dense.
 11 Jun 2002: TRP implemented.
              lu1mRP implements Markowitz with Threshold Rook Pivoting.
              lu1mxc maintains max col elements.  (Previously lu1max.)
              lu1mxr maintains max row elements.
 12 Jun 2002: lu1mCP seems too slow on big problems (e.g. memplus).
              Disabled it for the moment.  (Use lu1mar + TCP.)
 14 Dec 2002: TSP implemented.
              lu1mSP implements Markowitz with
              Threshold Symmetric Pivoting.
 07 Mar 2003: character*1, character*2 changed to f90 form.
              Comments changed from * in column to ! in column 1.
              Comments kept within column 72 to avoid compiler warning.
 19 Dec 2004: Hdelete(...) has new input argument Hlenin.
 21 Dec 2004: Print Ltol and Lmax with e10.2 instead of e10.1.
 26 Mar 2006: lu1fad: Ignore nsing from lu1ful.
              lu1DPP: nsing redefined (but not used by lu1fad).
              lu1DCP: nsing redefined (but not used by lu1fad).
<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1fac><A Name='R_lu1fac'><a target="index" href="lusol_f_i.html#R_lu1fac">lu1fac</a></A><ARGLIST>( m    , n    , nelem, lena , luparm, parmlu,
     &                   a    , indc , indr , ip   , iq    ,
     &                   lenc , lenr , locc , locr ,
     &                   iploc, iqloc, ipinv, iqinv, w     , inform )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE><DIV ALIGN=right><INFO>lusol.f-&gt;41</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena)   , w(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m)   , iq(n),</VARIABLE>
     &                   lenc(n)   , lenr(m)   ,
     &                   iploc(n)  , iqloc(m)  , ipinv(m), iqinv(n)
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n)   , locr(m)</VARIABLE>
<COMMENT><HR></HR>
     lu1fac computes a factorization A = L*U, where A is a sparse
     matrix with m rows and n columns, P*L*P' is lower triangular
     and P*U*Q is upper triangular for certain permutations P, Q
     (which are returned in the arrays ip, iq).
     Stability is ensured by limiting the size of the elements of L.

     The nonzeros of A are input via the parallel arrays a, indc, indr,
     which should contain nelem entries of the form    aij,    i,    j
     in any order.  There should be no duplicate pairs         i,    j.

<HR></HR>
     *        Beware !!!   The row indices i must be in indc,         *
     *              and the column indices j must be in indr.         *
     *              (Not the other way round!)                        *
<HR></HR>

     It does not matter if some of the entries in a(*) are zero.
     Entries satisfying  abs( a(i) ) .le. parmlu(3)  are ignored.
     Other parameters in luparm and parmlu are described below.

     The matrix A may be singular.  On exit, nsing = luparm(11) gives
     the number of apparent singularities.  This is the number of
     "small" diagonals of the permuted factor U, as judged by
     the input tolerances Utol1 = parmlu(4) and  Utol2 = parmlu(5).
     The diagonal element diagj associated with column j of A is
     "small" if
                 abs( diagj ) .le. Utol1
     or
                 abs( diagj ) .le. Utol2 * max( uj ),

     where max( uj ) is the maximum element in the j-th column of U.
     The position of such elements is returned in w(*).  In general,
     w(j) = + max( uj ),  but if column j is a singularity,
     w(j) = - max( uj ).  Thus, w(j) .le. 0 if column j appears to be
     dependent on the other columns of A.

     NOTE: lu1fac (like certain other sparse LU packages) does not
     treat dense columns efficiently.  This means it will be slow
     on "arrow matrices" of the form
                  A = (x       a)
                      (  x     b)
                      (    x   c)
                      (      x d)
                      (x x x x e)
     if the numerical values in the dense column allow it to be
     chosen LATE in the pivot order.

     With TPP (Threshold Partial Pivoting), the dense column is
     likely to be chosen late.

     With TCP (Threshold Complete Pivoting), if any of a,b,c,d
     is significantly larger than other elements of A, it will
     be chosen as the first pivot and the dense column will be
     eliminated, giving reasonably sparse factors.
     However, if element e is so big that TCP chooses it, the factors
     will become dense.  (It's hard to win on these examples!)
<HR></HR>


     Notes on the array names
<HR></HR>

     During the LU factorization, the sparsity pattern of the matrix
     being factored is stored twice: in a column list and a row list.

     The column list is ( a, indc, locc, lenc )
     where
           a(*)    holds the nonzeros,
           indc(*) holds the indices for the column list,
           locc(j) points to the start of column j in a(*) and indc(*),
           lenc(j) is the number of nonzeros in column j.

     The row list is    (    indr, locr, lenr )
     where
           indr(*) holds the indices for the row list,
           locr(i) points to the start of row i in indr(*),
           lenr(i) is the number of nonzeros in row i.


     At all stages of the LU factorization, ip contains a complete
     row permutation.  At the start of stage k,  ip(1), ..., ip(k-1)
     are the first k-1 rows of the final row permutation P.
     The remaining rows are stored in an ordered list
                          ( ip, iploc, ipinv )
     where
           iploc(nz) points to the start in ip(*) of the set of rows
                     that currently contain nz nonzeros,
           ipinv(i)  points to the position of row i in ip(*).

     For example,
           iploc(1) = k   (and this is where rows of length 1 begin),
           iploc(2) = k+p  if there are p rows of length 1
                          (and this is where rows of length 2 begin).

     Similarly for iq, iqloc, iqinv.
<HR></HR>


     00 Jun 1983  Original version.
     00 Jul 1987  nrank  saved in luparm(16).
     12 Apr 1989  ipinv, iqinv added as workspace.
     26 Apr 1989  maxtie replaced by maxcol in Markowitz search.
     16 Mar 1992  jumin  saved in luparm(19).
     10 Jun 1992  lu1fad has to move empty rows and cols to the bottom
                  (via lu1pq3) before doing the dense LU.
     12 Jun 1992  Deleted dense LU (lu1ful, lu1vlu).
     25 Oct 1993  keepLU implemented.
     07 Feb 1994  Added new dense LU (lu1ful, lu1den).
     21 Dec 1994  Bugs fixed in lu1fad (nrank) and lu1ful (ipvt).
     08 Aug 1995  Use ip instead of w as parameter to lu1or3 (for F90).
     13 Sep 2000  TPP and TCP options implemented.
     17 Oct 2000  Fixed troubles due to A = empty matrix (Todd Munson).
     01 Dec 2000  Save Lmax, Umax, etc. after both lu1fad and lu6chk.
                  lu1fad sets them when keepLU = false.
                  lu6chk sets them otherwise, and includes items
                  from the dense LU.
     11 Mar 2001  lu6chk now looks at diag(U) when keepLU = false.
     26 Apr 2002  New TCP implementation using heap routines to
                  store largest element in each column.
                  New workspace arrays Ha, Hj, Hk required.
                  For compatibility, borrow space from a, indc, indr
                  rather than adding new input parameters.
     01 May 2002  lu1den changed to lu1DPP (dense partial  pivoting).
                  lu1DCP implemented       (dense complete pivoting).
                  Both TPP and TCP now switch to dense mode and end.

     Systems Optimization Laboratory, Stanford University.
<HR></HR>


  INPUT PARAMETERS

  m      (not altered) is the number of rows in A.
  n      (not altered) is the number of columns in A.
  nelem  (not altered) is the number of matrix entries given in
         the arrays a, indc, indr.
  lena   (not altered) is the dimension of  a, indc, indr.
         This should be significantly larger than nelem.
         Typically one should have
            lena &gt; max( 2*nelem, 10*m, 10*n, 10000 )
         but some applications may need more.
         On machines with virtual memory it is safe to have
         lena "far bigger than necessary", since not all of the
         arrays will be used.
  a      (overwritten) contains entries   Aij  in   a(1:nelem).
  indc   (overwritten) contains the indices i in indc(1:nelem).
  indr   (overwritten) contains the indices j in indr(1:nelem).

  luparm input parameters:                                Typical value

  luparm( 1) = nout     File number for printed messages.         6

  luparm( 2) = lprint   Print level.                              0
                   &lt;  0 suppresses output.
                   =  0 gives error messages.
                  &gt;= 10 gives statistics about the LU factors.
                  &gt;= 50 gives debug output from lu1fac
                        (the pivot row and column and the
                        no. of rows and columns involved at
                        each elimination step).

  luparm( 3) = maxcol   lu1fac: maximum number of columns         5
                        searched allowed in a Markowitz-type
                        search for the next pivot element.
                        For some of the factorization, the
                        number of rows searched is
                        maxrow = maxcol - 1.

  luparm( 6) = 0    =&gt;  TPP: Threshold Partial   Pivoting.        0
             = 1    =&gt;  TRP: Threshold Rook      Pivoting.
             = 2    =&gt;  TCP: Threshold Complete  Pivoting.
             = 3    =&gt;  TSP: Threshold Symmetric Pivoting.
             = 4    =&gt;  TDP: Threshold Diagonal  Pivoting.
                             (TDP not yet implemented).
                        TRP and TCP are more expensive than TPP but
                        more stable and better at revealing rank.
                        Take care with setting parmlu(1), especially
                        with TCP.
                        NOTE: TSP and TDP are for symmetric matrices
                        that are either definite or quasi-definite.
                        TSP is effectively TRP for symmetric matrices.
                        TDP is effectively TCP for symmetric matrices.

  luparm( 8) = keepLU   lu1fac: keepLU = 1 means the numerical    1
                        factors will be computed if possible.
                        keepLU = 0 means L and U will be discarded
                        but other information such as the row and
                        column permutations will be returned.
                        The latter option requires less storage.

  parmlu input parameters:                                Typical value

  parmlu( 1) = Ltol1    Max Lij allowed during Factor.
                                                  TPP     10.0 or 100.0
                                                  TRP      4.0 or  10.0
                                                  TCP      5.0 or  10.0
                                                  TSP      4.0 or  10.0
                        With TRP and TCP (Rook and Complete Pivoting),
                        values less than 25.0 may be expensive
                        on badly scaled data.  However,
                        values less than 10.0 may be needed
                        to obtain a reliable rank-revealing
                        factorization.
  parmlu( 2) = Ltol2    Max Lij allowed during Updates.            10.0
                        during updates.
  parmlu( 3) = small    Absolute tolerance for       eps**0.8 = 3.0d-13
                        treating reals as zero.
  parmlu( 4) = Utol1    Absolute tol for flagging    eps**0.67= 3.7d-11
                        small diagonals of U.
  parmlu( 5) = Utol2    Relative tol for flagging    eps**0.67= 3.7d-11
                        small diagonals of U.
                        (eps = machine precision)
  parmlu( 6) = Uspace   Factor limiting waste space in  U.      3.0
                        In lu1fac, the row or column lists
                        are compressed if their length
                        exceeds Uspace times the length of
                        either file after the last compression.
  parmlu( 7) = dens1    The density at which the Markowitz      0.3
                        pivot strategy should search maxcol
                        columns and no rows.
                        (Use 0.3 unless you are experimenting
                        with the pivot strategy.)
  parmlu( 8) = dens2    the density at which the Markowitz      0.5
                        strategy should search only 1 column,
                        or (if storage is available)
                        the density at which all remaining
                        rows and columns will be processed
                        by a dense LU code.
                        For example, if dens2 = 0.1 and lena is
                        large enough, a dense LU will be used
                        once more than 10 per cent of the
                        remaining matrix is nonzero.


  OUTPUT PARAMETERS

  a, indc, indr     contain the nonzero entries in the LU factors of A.
         If keepLU = 1, they are in a form suitable for use
         by other parts of the LUSOL package, such as lu6sol.
         U is stored by rows at the start of a, indr.
         L is stored by cols at the end   of a, indc.
         If keepLU = 0, only the diagonals of U are stored, at the
         end of a.
  ip, iq    are the row and column permutations defining the
         pivot order.  For example, row ip(1) and column iq(1)
         defines the first diagonal of U.
  lenc(1:numl0) contains the number of entries in nontrivial
         columns of L (in pivot order).
  lenr(1:m) contains the number of entries in each row of U
         (in original order).
  locc(1:n) = 0 (ready for the LU update routines).
  locr(1:m) points to the beginning of the rows of U in a, indr.
  iploc, iqloc, ipinv, iqinv  are undefined.
  w      indicates singularity as described above.
  inform = 0 if the LU factors were obtained successfully.
         = 1 if U appears to be singular, as judged by lu6chk.
         = 3 if some index pair indc(l), indr(l) lies outside
             the matrix dimensions 1:m , 1:n.
         = 4 if some index pair indc(l), indr(l) duplicates
             another such pair.
         = 7 if the arrays a, indc, indr were not large enough.
             Their length "lena" should be increase to at least
             the value "minlen" given in luparm(13).
         = 8 if there was some other fatal error.  (Shouldn't happen!)
         = 9 if no diagonal pivot could be found with TSP or TDP.
             The matrix must not be sufficiently definite
             or quasi-definite.

  luparm output parameters:

  luparm(10) = inform   Return code from last call to any LU routine.
  luparm(11) = nsing    No. of singularities marked in the
                        output array w(*).
  luparm(12) = jsing    Column index of last singularity.
  luparm(13) = minlen   Minimum recommended value for  lena.
  luparm(14) = maxlen   ?
  luparm(15) = nupdat   No. of updates performed by the lu8 routines.
  luparm(16) = nrank    No. of nonempty rows of U.
  luparm(17) = ndens1   No. of columns remaining when the density of
                        the matrix being factorized reached dens1.
  luparm(18) = ndens2   No. of columns remaining when the density of
                        the matrix being factorized reached dens2.
  luparm(19) = jumin    The column index associated with DUmin.
  luparm(20) = numL0    No. of columns in initial  L.
  luparm(21) = lenL0    Size of initial  L  (no. of nonzeros).
  luparm(22) = lenU0    Size of initial  U.
  luparm(23) = lenL     Size of current  L.
  luparm(24) = lenU     Size of current  U.
  luparm(25) = lrow     Length of row file.
  luparm(26) = ncp      No. of compressions of LU data structures.
  luparm(27) = mersum   lu1fac: sum of Markowitz merit counts.
  luparm(28) = nUtri    lu1fac: triangular rows in U.
  luparm(29) = nLtri    lu1fac: triangular rows in L.
  luparm(30) =



  parmlu output parameters:

  parmlu(10) = Amax     Maximum element in  A.
  parmlu(11) = Lmax     Maximum multiplier in current  L.
  parmlu(12) = Umax     Maximum element in current  U.
  parmlu(13) = DUmax    Maximum diagonal in  U.
  parmlu(14) = DUmin    Minimum diagonal in  U.
  parmlu(15) = Akmax    Maximum element generated at any stage
                        during TCP factorization.
  parmlu(16) = growth   TPP: Umax/Amax    TRP, TCP, TSP: Akmax/Amax
  parmlu(17) =
  parmlu(18) =
  parmlu(19) =
  parmlu(20) = resid    lu6sol: residual after solve with U or U'.
<HR></HR>
  parmlu(30) =
<HR></HR>
</COMMENT>
      <DECLARE>character</DECLARE> <VARIABLE>mnkey*1, kPiv(0:3)*2</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>lPiv</VARIABLE>
      <DECLARE>logical</DECLARE> <VARIABLE>keepLU, TCP, TPP, TRP, TSP</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;366</INFO></DIV>
      <DECLARE>double precision</DECLARE> <VARIABLE>Lmax, Ltol</VARIABLE>

      <DECLARE>double precision</DECLARE> <VARIABLE>zero         ,  one</VARIABLE>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0,  one = 1.0d+0 )

<COMMENT>     Grab relevant input parameters.
</COMMENT>
      nelem0 = nelem
      nout   = luparm(1)
      lprint = luparm(2)<DIV ALIGN=right><INFO>lusol.f-&gt;376</INFO></DIV>
      lPiv   = luparm(6)
      keepLU = luparm(8) .ne. 0

      Ltol   = parmlu(1)    <COMMENT> Limit on size of Lij</COMMENT>
      small  = parmlu(3)    <COMMENT> Drop tolerance
</COMMENT>
      TPP    = lPiv .eq. 0  <COMMENT> Threshold Partial   Pivoting (normal).</COMMENT>
      TRP    = lPiv .eq. 1  <COMMENT> Threshold Rook      Pivoting</COMMENT>
      TCP    = lPiv .eq. 2  <COMMENT> Threshold Complete  Pivoting.</COMMENT>
      TSP    = lPiv .eq. 3  <COMMENT> Threshold Symmetric Pivoting.</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;386</INFO></DIV>
      kPiv(0)= 'PP'
      kPiv(1)= 'RP'
      kPiv(2)= 'CP'
      kPiv(3)= 'SP'

<COMMENT>     Initialize output parameters.
</COMMENT>
      inform = 0
      minlen = nelem + 2*(m + n)
      numl0  = 0<DIV ALIGN=right><INFO>lusol.f-&gt;396</INFO></DIV>
      lenL   = 0
      lenU   = 0
      lrow   = 0
      mersum = 0
      nUtri  = m
      nLtri  = 0
      ndens1 = 0
      ndens2 = 0
      nrank  = 0
      nsing  = 0<DIV ALIGN=right><INFO>lusol.f-&gt;406</INFO></DIV>
      jsing  = 0
      jumin  = 0

      Amax   = zero
      Lmax   = zero
      Umax   = zero
      DUmax  = zero
      DUmin  = zero
      Akmax  = zero

      <TEST>if</TEST> (m .gt. n) then<DIV ALIGN=right><INFO>lusol.f-&gt;417</INFO></DIV>
         mnkey  = '&gt;'
      else if (m .eq. n) then
         mnkey  = '='
      else
         mnkey  = '&lt;'
      end if

<COMMENT>     Float version of dimensions.
</COMMENT>
      dm     = m<DIV ALIGN=right><INFO>lusol.f-&gt;427</INFO></DIV>
      dn     = n
      delem  = nelem

<COMMENT>     Initialize workspace parameters.
</COMMENT>
      luparm(26) = 0             <COMMENT> ncp</COMMENT>
      <TEST>if</TEST> (lena .lt. minlen) go to 970

<COMMENT><HR></HR>
     Organize the  aij's  in  a, indc, indr.
     lu1or1  deletes small entries, tests for illegal  i,j's,
             and counts the nonzeros in each row and column.
     lu1or2  reorders the elements of  A  by columns.
     lu1or3  uses the column list to test for duplicate entries
             (same indices  i,j).
     lu1or4  constructs a row list from the column list.
<HR></HR></COMMENT>
      call <!new fthcall lu1or1><A Name='C_444'><a href="lusol_f_c.html#R_lu1or1">lu1or1</a></A><BRANCHEMENT>( m   , n    , nelem, lena , small,
     &             a   , indc , indr , lenc , lenr,
     &             Amax, numnz, lerr , inform )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;447</INFO></DIV>

      <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 10) then
         densty = 100.0d+0 * delem / (dm * dn)
         write(nout, 1000) m, mnkey, n, nelem, Amax, densty
      end if
      <TEST>if</TEST> (inform .ne. 0) go to 930

      nelem  = numnz

      call <!new fthcall lu1or2><A Name='C_456'><a href="lusol_f_c.html#R_lu1or2">lu1or2</a></A><BRANCHEMENT>( n, nelem, lena, a, indc, indr, lenc, locc )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;457</INFO></DIV>
      call <!new fthcall lu1or3><A Name='C_457'><a href="lusol_f_c.html#R_lu1or3">lu1or3</a></A><BRANCHEMENT>( m, n, lena, indc, lenc, locc, ip,
     &             lerr, inform )</BRANCHEMENT>

      <TEST>if</TEST> (inform .ne. 0) go to 940

      call <!new fthcall lu1or4><A Name='C_462'><a href="lusol_f_c.html#R_lu1or4">lu1or4</a></A><BRANCHEMENT>( m, n, nelem, lena,
     &             indc, indr, lenc, lenr, locc, locr )</BRANCHEMENT>

<COMMENT><HR></HR>
     Set up lists of rows and columns with equal numbers of nonzeros,
     using  indc(*)  as workspace.
<HR></HR></COMMENT>
      call <!new fthcall lu1pq1><A Name='C_469'><a href="lusol_f_c.html#R_lu1pq1">lu1pq1</a></A><BRANCHEMENT>( m, n, lenr, ip, iploc, ipinv, indc(nelem + 1) )</BRANCHEMENT>
      call <!new fthcall lu1pq1><A Name='C_470'><a href="lusol_f_c.html#R_lu1pq1">lu1pq1</a></A><BRANCHEMENT>( n, m, lenc, iq, iqloc, iqinv, indc(nelem + 1) )</BRANCHEMENT>

<COMMENT><HR></HR>
     For TCP, allocate Ha, Hj, Hk at the end of a, indc, indr.
     Then compute the factorization  A = L*U.
<HR></HR></COMMENT>
      <TEST>if</TEST> (TPP .or. TSP) then<DIV ALIGN=right><INFO>lusol.f-&gt;477</INFO></DIV>
         lenH   = 1
         lena2  = lena
         locH   = lena
         lmaxr  = 1
      else if (TRP) then
         lenH   = 1             <COMMENT> Dummy</COMMENT>
         lena2  = lena  - m     <COMMENT> Reduced length of      a</COMMENT>
         locH   = lena          <COMMENT> Dummy</COMMENT>
         lmaxr  = lena2 + 1     <COMMENT> Start of Amaxr      in a</COMMENT>
      else if (TCP) then<DIV ALIGN=right><INFO>lusol.f-&gt;487</INFO></DIV>
         lenH   = n             <COMMENT> Length of heap</COMMENT>
         lena2  = lena  - lenH  <COMMENT> Reduced length of      a, indc, indr</COMMENT>
         locH   = lena2 + 1     <COMMENT> Start of Ha, Hj, Hk in a, indc, indr</COMMENT>
         lmaxr  = 1             <COMMENT> Dummy</COMMENT>
      end if

      call <!new fthcall lu1fad><A Name='C_493'><a href="lusol_f_c.html#R_lu1fad">lu1fad</a></A><BRANCHEMENT>( m     , n     , nelem , lena2 , luparm, parmlu,
     &             a     , indc  , indr  , ip    , iq    ,
     &             lenc  , lenr  , locc  , locr  ,
     &             iploc , iqloc , ipinv , iqinv , w     ,
     &             lenH  ,a(locH), indc(locH), indr(locH), a(lmaxr),
     &             inform, lenL  , lenU  , minlen, mersum,
     &             nUtri , nLtri , ndens1, ndens2, nrank ,
     &             Lmax  , Umax  , DUmax , DUmin , Akmax )</BRANCHEMENT>

      luparm(16) = nrank
      luparm(23) = lenL
      <TEST>if</TEST> (inform .eq. 7) go to 970
      <TEST>if</TEST> (inform .eq. 9) go to 985
      <TEST>if</TEST> (inform .gt. 0) go to 980<DIV ALIGN=right><INFO>lusol.f-&gt;507</INFO></DIV>

      <TEST>if</TEST> ( keepLU ) then
<COMMENT><HR></HR>
        The LU factors are at the top of  a, indc, indr,
        with the columns of  L  and the rows of  U  in the order

        ( free )   ... ( u3 ) ( l3 ) ( u2 ) ( l2 ) ( u1 ) ( l1 ).

        Starting with ( l1 ) and ( u1 ), move the rows of  U  to the
        left and the columns of  L  to the right, giving

        ( u1 ) ( u2 ) ( u3 ) ...   ( free )   ... ( l3 ) ( l2 ) ( l1 ).

        Also, set  numl0 = the number of nonempty columns of L.
<HR></HR></COMMENT>
         lu     = 0
         ll     = lena  + 1
         lm     = lena2 + 1
         ltopl  = ll - lenL - lenU
         lrow   = lenU<DIV ALIGN=right><INFO>lusol.f-&gt;527</INFO></DIV>

         <LOOP><A Name=C_528>do</A></LOOP> k = 1, nrank
            i       =   ip(k)
            lenUk   = - lenr(i)
            lenr(i) =   lenUk
            j       =   iq(k)
            lenLk   = - lenc(j) - 1
            <TEST>if</TEST> (lenLk .gt. 0) then
                numl0        = numl0 + 1
                iqloc(numl0) = lenLk<DIV ALIGN=right><INFO>lusol.f-&gt;537</INFO></DIV>
            end if

            <TEST>if</TEST> (lu + lenUk .lt. ltopl) then
<COMMENT><HR></HR>
              There is room to move ( uk ).  Just right-shift ( lk ).
<HR></HR></COMMENT>
               <LOOP><A Name=C_543>do</A></LOOP> idummy = 1, lenLk
                  ll       = ll - 1
                  lm       = lm - 1
                  a(ll)    = a(lm)<DIV ALIGN=right><INFO>lusol.f-&gt;547</INFO></DIV>
                  indc(ll) = indc(lm)
                  indr(ll) = indr(lm)
               <A Href=#C_543>end do</A>
            else
<COMMENT><HR></HR>
              There is no room for ( uk ) yet.  We have to
              right-shift the whole of the remaining LU file.
              Note that ( lk ) ends up in the correct place.
<HR></HR></COMMENT>
               llsave = ll - lenLk<DIV ALIGN=right><INFO>lusol.f-&gt;557</INFO></DIV>
               nmove  = lm - ltopl

               <LOOP><A Name=C_559>do</A></LOOP> idummy = 1, nmove
                  ll       = ll - 1
                  lm       = lm - 1
                  a(ll)    = a(lm)
                  indc(ll) = indc(lm)
                  indr(ll) = indr(lm)
               <A Href=#C_559>end do</A>

               ltopl  = ll<DIV ALIGN=right><INFO>lusol.f-&gt;568</INFO></DIV>
               ll     = llsave
               lm     = ll
            end if

<COMMENT><HR></HR>
           Left-shift ( uk ).
<HR></HR></COMMENT>
            locr(i) = lu + 1
            l2      = lm - 1
            lm      = lm - lenUk<DIV ALIGN=right><INFO>lusol.f-&gt;578</INFO></DIV>

            <LOOP><A Name=C_579>do</A></LOOP> l = lm, l2
               lu       = lu + 1
               a(lu)    = a(l)
               indr(lu) = indr(l)
            <A Href=#C_579>end do</A>
         <A Href=#C_528>end do</A>

<COMMENT><HR></HR>
        Save the lengths of the nonempty columns of  L,
        and initialize  locc(j)  for the LU update routines.
<HR></HR></COMMENT>
         <LOOP><A Name=C_590>do</A></LOOP> k = 1, numl0
            lenc(k) = iqloc(k)
         <A Href=#C_590>end do</A>

         <LOOP><A Name=C_594>do</A></LOOP> j = 1, n
            locc(j) = 0
         <A Href=#C_594>end do</A>

<COMMENT><HR></HR>
        Test for singularity.
        lu6chk  sets  nsing, jsing, jumin, Lmax, Umax, DUmax, DUmin
        (including entries from the dense LU).
        inform = 1  if there are singularities (nsing gt 0).
<HR></HR></COMMENT>
         call <!new fthcall lu6chk><A Name='C_604'><a href="lusol_f_c.html#R_lu6chk">lu6chk</a></A><BRANCHEMENT>( 1, m, n, w, lena, luparm, parmlu,
     &                a, indc, indr, ip, iq,
     &                lenc, lenr, locc, locr, inform )</BRANCHEMENT>
         nsing  = luparm(11)
         jsing  = luparm(12)<DIV ALIGN=right><INFO>lusol.f-&gt;609</INFO></DIV>
         jumin  = luparm(19)
         Lmax   = parmlu(11)
         Umax   = parmlu(12)
         DUmax  = parmlu(13)
         DUmin  = parmlu(14)

      else
<COMMENT><HR></HR>
        keepLU = 0.  L and U were not kept, just the diagonals of U.
        lu1fac will probably be called again soon with keepLU = .true.
        11 Mar 2001: lu6chk revised.  We can call it with keepLU = 0,
                     but we want to keep Lmax, Umax from lu1fad.
        05 May 2002: Allow for TCP with new lu1DCP.  Diag(U) starts
                     below lena2, not lena.  Need lena2 in next line.
<HR></HR></COMMENT>
         call <!new fthcall lu6chk><A Name='C_624'><a href="lusol_f_c.html#R_lu6chk">lu6chk</a></A><BRANCHEMENT>( 1, m, n, w, lena2, luparm, parmlu,
     &                a, indc, indr, ip, iq,
     &                lenc, lenr, locc, locr, inform )</BRANCHEMENT>
         nsing  = luparm(11)
         jsing  = luparm(12)<DIV ALIGN=right><INFO>lusol.f-&gt;629</INFO></DIV>
         jumin  = luparm(19)
         DUmax  = parmlu(13)
         DUmin  = parmlu(14)
      end if

      go to <A Href=#lu1fac_L_990>990</A>

<COMMENT><HR></HR>
     Error exits.
<HR></HR></COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;639</INFO></DIV>
  <A Name=lu1fac_L_930>930</A> inform = 3
      <TEST>if</TEST> (lprint .ge. 0) write(nout, 1300) lerr, indc(lerr), indr(lerr)
      go to <A Href=#lu1fac_L_990>990</A>

  <A Name=lu1fac_L_940>940</A> inform = 4
      <TEST>if</TEST> (lprint .ge. 0) write(nout, 1400) lerr, indc(lerr), indr(lerr)
      go to <A Href=#lu1fac_L_990>990</A>

  <A Name=lu1fac_L_970>970</A> inform = 7
      <TEST>if</TEST> (lprint .ge. 0) write(nout, 1700) lena, minlen<DIV ALIGN=right><INFO>lusol.f-&gt;649</INFO></DIV>
      go to <A Href=#lu1fac_L_990>990</A>

  <A Name=lu1fac_L_980>980</A> inform = 8
      <TEST>if</TEST> (lprint .ge. 0) write(nout, 1800)
      go to <A Href=#lu1fac_L_990>990</A>

  <A Name=lu1fac_L_985>985</A> inform = 9
      <TEST>if</TEST> (lprint .ge. 0) write(nout, 1900)

<COMMENT>     Store output parameters.
</COMMENT>
  <A Name=lu1fac_L_990>990</A> nelem      = nelem0
      luparm(10) = inform
      luparm(11) = nsing
      luparm(12) = jsing
      luparm(13) = minlen
      luparm(15) = 0
      luparm(16) = nrank
      luparm(17) = ndens1
      luparm(18) = ndens2<DIV ALIGN=right><INFO>lusol.f-&gt;669</INFO></DIV>
      luparm(19) = jumin
      luparm(20) = numl0
      luparm(21) = lenL
      luparm(22) = lenU
      luparm(23) = lenL
      luparm(24) = lenU
      luparm(25) = lrow
      luparm(27) = mersum
      luparm(28) = nUtri
      luparm(29) = nLtri<DIV ALIGN=right><INFO>lusol.f-&gt;679</INFO></DIV>

      parmlu(10) = Amax
      parmlu(11) = Lmax
      parmlu(12) = Umax
      parmlu(13) = DUmax
      parmlu(14) = DUmin
      parmlu(15) = Akmax

      Agrwth = Akmax  / (Amax + 1.0d-20)
      Ugrwth = Umax   / (Amax + 1.0d-20)<DIV ALIGN=right><INFO>lusol.f-&gt;689</INFO></DIV>
      <TEST>if</TEST> ( TPP ) then
         growth = Ugrwth
      else <COMMENT> TRP or TCP or TSP</COMMENT>
         growth = Agrwth
      end if
      parmlu(16) = growth

<COMMENT><HR></HR>
     Print statistics for the LU factors.
<HR></HR></COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;699</INFO></DIV>
      ncp    = luparm(26)
      condU  = DUmax / max( DUmin, 1.0d-20 )
      dincr  = lenL + lenU - nelem
      dincr  = dincr * 100.0d+0 / max( delem, one )
      avgmer = mersum
      avgmer = avgmer / dm
      nbump  = m - nUtri - nLtri

      <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 10) then
         <TEST>if</TEST> ( TPP ) then<DIV ALIGN=right><INFO>lusol.f-&gt;709</INFO></DIV>
            write(nout, 1100) avgmer, lenL, lenL+lenU, ncp, dincr,
     &                        nUtri, lenU, Ltol, Umax, Ugrwth,
     &                        nLtri, ndens1, Lmax

         else
            write(nout, 1120) kPiv(lPiv), avgmer,
     &                        lenL, lenL+lenU, ncp, dincr,
     &                        nUtri, lenU, Ltol, Umax, Ugrwth,
     &                        nLtri, ndens1, Lmax, Akmax, Agrwth
         end if<DIV ALIGN=right><INFO>lusol.f-&gt;719</INFO></DIV>

         write(nout, 1200) nbump, ndens2, DUmax, DUmin, condU
      end if

      return

 <A Name=lu1fac_L_1000>1000</A> format(' m', i12, ' ', a, 'n', i12, '  Elems', i9,
     &       '  Amax', 1p, e10.1, '  Density', 0p, f7.2)
 <A Name=lu1fac_L_1100>1100</A> format(' Merit', 0p, f8.1, '  lenL', i9, '  L+U', i11,
     &       '  Cmpressns', i5, '  Incres', 0p, f8.2<DIV ALIGN=right><INFO>lusol.f-&gt;729</INFO></DIV>
     & /     ' Utri', i9, '  lenU', i9, '  Ltol', 1p, e10.2,
     &       '  Umax', e10.1, '  Ugrwth', e8.1
     & /     ' Ltri', i9, '  dense1', i7, '  Lmax', e10.2)
 <A Name=lu1fac_L_1120>1120</A> format(' Mer', a2, 0p, f8.1, '  lenL', i9, '  L+U', i11,
     &       '  Cmpressns', i5, '  Incres', 0p, f8.2
     & /     ' Utri', i9, '  lenU', i9, '  Ltol', 1p, e10.2,
     &       '  Umax', e10.1, '  Ugrwth', e8.1
     & /     ' Ltri', i9, '  dense1', i7, '  Lmax', e10.2,
     &       '  Akmax', e9.1, '  Agrwth', e8.1)
 <A Name=lu1fac_L_1200>1200</A> format(' bump', i9, '  dense2', i7, '  DUmax', 1p, e9.1,<DIV ALIGN=right><INFO>lusol.f-&gt;739</INFO></DIV>
     &       '  DUmin', e9.1, '  condU', e9.1)
 <A Name=lu1fac_L_1300>1300</A> format(/ ' lu1fac  error...  entry  a(', i8, ')  has an illegal',
     &         ' row or column index'
     &       //' indc, indr =', 2i8)
 <A Name=lu1fac_L_1400>1400</A> format(/ ' lu1fac  error...  entry  a(', i8, ')  has the same',
     &         ' indices as an earlier entry'
     &       //' indc, indr =', 2i8)
 <A Name=lu1fac_L_1700>1700</A> format(/ ' lu1fac  error...  insufficient storage'
     &       //' Increase  lena  from', i10, '  to at least', i10)
 <A Name=lu1fac_L_1800>1800</A> format(/ ' lu1fac  error...  fatal bug',<DIV ALIGN=right><INFO>lusol.f-&gt;749</INFO></DIV>
     &         '   (sorry --- this should never happen)')
 <A Name=lu1fac_L_1900>1900</A> format(/ ' lu1fac  error...  TSP used but',
     &         ' diagonal pivot could not be found')

      end subroutine <a href="lusol_f_c.html#R_lu1fac">lu1fac</a> <COMMENT> subroutine lu1fac

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1fad><A Name='R_lu1fad'><a target="index" href="lusol_f_i.html#R_lu1fad">lu1fad</a></A><ARGLIST>( m     , n     , nelem , lena  , luparm, parmlu,
     &                   a     , indc  , indr  , ip    , iq    ,
     &                   lenc  , lenr  , locc  , locr  ,
     &                   iploc , iqloc , ipinv , iqinv , w     ,
     &                   lenH  , Ha    , Hj    , Hk    , Amaxr ,
     &                   inform, lenL  , lenU  , minlen, mersum,
     &                   nUtri , nLtri , ndens1, ndens2, nrank ,
     &                   Lmax  , Umax  , DUmax , DUmin , Akmax )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena), Amaxr(m), w(n)</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;769</INFO></DIV>
      <DECLARE>double precision</DECLARE> <VARIABLE>Ha(lenH)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>lenc(n)   , lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n)   , locr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>iploc(n)  , iqloc(m), ipinv(m), iqinv(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>Hj(lenH)  , Hk(lenH)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>Lmax</VARIABLE>

<COMMENT><HR></HR>
     lu1fad  is a driver for the numerical phase of lu1fac.
     At each stage it computes a column of  L  and a row of  U,
     using a Markowitz criterion to select the pivot element,
     subject to a stability criterion that bounds the elements of  L.

     00 Jan 1986  Version documented in LUSOL paper:
                  Gill, Murray, Saunders and Wright (1987),
                  Maintaining LU factors of a general sparse matrix,
                  Linear algebra and its applications 88/89, 239-270.

     02 Feb 1989  Following Suhl and Aittoniemi (1987), the largest
                  element in each column is now kept at the start of
                  the column, i.e. in position locc(j) of a and indc.
                  This should speed up the Markowitz searches.
                  To save time on highly triangular matrices, we wait
                  until there are no further columns of length 1
                  before setting and maintaining that property.

     12 Apr 1989  ipinv and iqinv added (inverses of ip and iq)
                  to save searching ip and iq for rows and columns
                  altered in each elimination step.  (Used in lu1pq2)

     19 Apr 1989  Code segmented to reduce its size.
                  lu1gau does most of the Gaussian elimination work.
                  lu1mar does just the Markowitz search.
                  lu1mxc moves biggest elements to top of columns.
                  lu1pen deals with pending fill-in in the row list.
                  lu1pq2 updates the row and column permutations.

     26 Apr 1989  maxtie replaced by maxcol, maxrow in the Markowitz
                  search.  maxcol, maxrow change as density increases.

     25 Oct 1993  keepLU implemented.

     07 Feb 1994  Exit main loop early to finish off with a dense LU.
                  densLU tells lu1fad whether to do it.
     21 Dec 1994  Bug fixed.  nrank was wrong after the call to lu1ful.
     12 Nov 1999  A parallel version of dcopy gave trouble in lu1ful
                  during left-shift of dense matrix D within a(*).
                  Fixed this unexpected problem here in lu1fad
                  by making sure the first and second D don't overlap.

     13 Sep 2000  TCP (Threshold Complete Pivoting) implemented.
                  lu2max added
                  (finds aijmax from biggest elems in each col).
                  Utri, Ltri and Spars1 phases apply.
                  No switch to Dense CP yet.  (Only TPP switches.)
     14 Sep 2000  imax needed to remember row containing aijmax.
     22 Sep 2000  For simplicity, lu1mxc always fixes
                  all modified cols.
                  (TPP spars2 used to fix just the first maxcol cols.)
     08 Nov 2000: Speed up search for aijmax.
                  Don't need to search all columns if the elimination
                  didn't alter the col containing the current aijmax.
     21 Nov 2000: lu1slk implemented for Utri phase with TCP
                  to guard against deceptive triangular matrices.
                  (Utri used to have aijtol &gt;= 0.9999 to include
                  slacks, but this allows other 1s to be accepted.)
                  Utri now accepts slacks, but applies normal aijtol
                  test to other pivots.
     28 Nov 2000: TCP with empty cols must call lu1mxc and lu2max
                  with ( lq1, n, ... ), not just ( 1, n, ... ).
     23 Mar 2001: lu1fad bug with TCP.
                  A col of length 1 might not be accepted as a pivot.
                  Later it appears in a pivot row and temporarily
                  has length 0 (when pivot row is removed
                  but before the column is filled in).  If it is the
                  last column in storage, the preceding col also thinks
                  it is "last".  Trouble arises when the preceding col
                  needs fill-in -- it overlaps the real "last" column.
                  (Very rarely, same trouble might have happened if
                  the drop tolerance caused columns to have length 0.)

                  Introduced ilast to record the last row in row file,
                             jlast to record the last col in col file.
                  lu1rec returns ilast = indr(lrow + 1)
                              or jlast = indc(lcol + 1).
                  (Should be an output parameter, but didn't want to
                  alter lu1rec's parameter list.)
                  lu1rec also treats empty rows or cols safely.
                  (Doesn't eliminate them!)

     26 Apr 2002: Heap routines added for TCP.
                  lu2max no longer needed.
                  imax, jmax used only for printing.
     01 May 2002: lu1DCP implemented (dense complete pivoting).
                  Both TPP and TCP now switch to dense LU
                  when density exceeds dens2.
     06 May 2002: In dense mode, store diag(U) in natural order.
     09 May 2002: lu1mCP implemented (Markowitz TCP via heap).
     11 Jun 2002: lu1mRP implemented (Markowitz TRP).
     28 Jun 2002: Fixed call to lu1mxr.
     14 Dec 2002: lu1mSP implemented (Markowitz TSP).
     15 Dec 2002: Both TPP and TSP can grab cols of length 1
                  during Utri.
     19 Dec 2004: Hdelete(...) has new input argument Hlenin.
     26 Mar 2006: lu1fad returns nrank  = min( mrank, nrank )
                  and ignores nsing from lu1ful
     26 Mar 2006: Allow for empty columns before calling Hbuild.

     Systems Optimization Laboratory, Stanford University.
<HR></HR>
</COMMENT>
      <DECLARE>logical</DECLARE> <VARIABLE>Utri, Ltri, spars1, spars2, dense</VARIABLE>
      <DECLARE>logical</DECLARE> <VARIABLE>densLU, keepLU</VARIABLE>
      <DECLARE>logical</DECLARE> <VARIABLE>TCP, TPP, TRP, TSP</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>Lij, Ltol, small</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>Hlen, Hlenin, hops, h, lPiv</VARIABLE>

      <DECLARE>double precision</DECLARE> <VARIABLE>zero,           one</VARIABLE>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0,  one  = 1.0d+0 )<DIV ALIGN=right><INFO>lusol.f-&gt;889</INFO></DIV>

<COMMENT><HR></HR>
     Local variables
<HR></HR>

     lcol   is the length of the column file.  It points to the last
            nonzero in the column list.
     lrow   is the analogous quantity for the row file.
     lfile  is the file length (lcol or lrow) after the most recent
            compression of the column list or row list.
     nrowd  and  ncold  are the number of rows and columns in the
            matrix defined by the pivot column and row.  They are the
            dimensions of the submatrix D being altered at this stage.
     melim  and  nelim  are the number of rows and columns in the
            same matrix D, excluding the pivot column and row.
     mleft  and  nleft  are the number of rows and columns
            still left to be factored.
     nzchng is the increase in nonzeros in the matrix that remains
            to be factored after the current elimination
            (usually negative).
     nzleft is the number of nonzeros still left to be factored.
     nspare is the space we leave at the end of the last row or
            column whenever a row or column is being moved to the end
            of its file.  nspare = 1 or 2 might help reduce the
            number of file compressions when storage is tight.

     The row and column ordering permutes A into the form

<HR></HR>
                         \                     |
                          \         U1         |
                           \                   |
<HR></HR>
                            |\
                            | \
                            |  \
            P A Q   =       |   \
                            |    \
                            |     --------------
                            |     |            |
                            |     |            |
                            | L1  |     A2     |
                            |     |            |
                            |     |            |
<HR></HR>

     where the block A2 is factored as  A2 = L2 U2.
     The phases of the factorization are as follows.

     Utri   is true when U1 is being determined.
            Any column of length 1 is accepted immediately (if TPP).

     Ltri   is true when L1 is being determined.
            lu1mar exits as soon as an acceptable pivot is found
            in a row of length 1.

     spars1 is true while the density of the (modified) A2 is less
            than the parameter dens1 = parmlu(7) = 0.3 say.
            lu1mar searches maxcol columns and maxrow rows,
            where  maxcol = luparm(3),  maxrow = maxcol - 1.
            lu1mxc is used to keep the biggest element at the top
            of all remaining columns.

     spars2 is true while the density of the modified A2 is less
            than the parameter dens2 = parmlu(8) = 0.6 say.
            lu1mar searches maxcol columns and no rows.
            lu1mxc could fix up only the first maxcol cols (with TPP).
            22 Sep 2000:  For simplicity, lu1mxc fixes all
                          modified cols.

     dense  is true once the density of A2 reaches dens2.
            lu1mar searches only 1 column (the shortest).
            lu1mxc could fix up only the first column (with TPP).
            22 Sep 2000:  For simplicity, lu1mxc fixes all
                          modified cols.

<HR></HR>
     To eliminate timings, comment out all lines containing "time".
<HR></HR>

     integer            eltime, mktime

     call timer ( 'start ', 3 )
     ntime  = (n / 4.0)

</COMMENT>
      nout   = luparm(1)
      lprint = luparm(2)
      maxcol = luparm(3)
      lPiv   = luparm(6)
      keepLU = luparm(8) .ne. 0<DIV ALIGN=right><INFO>lusol.f-&gt;980</INFO></DIV>

      TPP    = lPiv .eq. 0  <COMMENT> Threshold Partial   Pivoting (normal).</COMMENT>
      TRP    = lPiv .eq. 1  <COMMENT> Threshold Rook      Pivoting</COMMENT>
      TCP    = lPiv .eq. 2  <COMMENT> Threshold Complete  Pivoting.</COMMENT>
      TSP    = lPiv .eq. 3  <COMMENT> Threshold Symmetric Pivoting.
</COMMENT>
      densLU = .false.
      maxrow = maxcol - 1
      ilast  = m                 <COMMENT> Assume row m is last in the row file.</COMMENT>
      jlast  = n                 <COMMENT> Assume col n is last in the col file.</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;990</INFO></DIV>
      lfile  = nelem
      lrow   = nelem
      lcol   = nelem
      minmn  = min( m, n )
      maxmn  = max( m, n )
      nzleft = nelem
      nspare = 1

      <TEST>if</TEST> ( keepLU ) then
         lu1    = lena   + 1<DIV ALIGN=right><INFO>lusol.f-&gt;1000</INFO></DIV>
      else
<COMMENT>        Store only the diagonals of U in the top of memory.</COMMENT>
         ldiagU = lena   - n
         lu1    = ldiagU + 1
      end if

      Ltol   = parmlu(1)
      small  = parmlu(3)
      uspace = parmlu(6)
      dens1  = parmlu(7)<DIV ALIGN=right><INFO>lusol.f-&gt;1010</INFO></DIV>
      dens2  = parmlu(8)
      Utri   = .true.
      Ltri   = .false.
      spars1 = .false.
      spars2 = .false.
      dense  = .false.

<COMMENT>     Check parameters.
</COMMENT>
      Ltol   = max( Ltol, 1.0001d+0 )<DIV ALIGN=right><INFO>lusol.f-&gt;1020</INFO></DIV>
      dens1  = min( dens1, dens2 )

<COMMENT>     Initialize output parameters.
     lenL, lenU, minlen, mersum, nUtri, nLtri, ndens1, ndens2, nrank
     are already initialized by lu1fac.
</COMMENT>
      Lmax   = zero
      Umax   = zero
      DUmax  = zero
      DUmin  = 1.0d+20<DIV ALIGN=right><INFO>lusol.f-&gt;1030</INFO></DIV>
      <TEST>if</TEST> (nelem .eq. 0) Dumin = zero
      Akmax  = zero
      hops   = 0

<COMMENT> More initialization.
</COMMENT>
      <TEST>if</TEST> (TPP .or. TSP) then <COMMENT> Don't worry yet about lu1mxc.</COMMENT>
         aijmax = zero
         aijtol = zero
         Hlen   = 1<DIV ALIGN=right><INFO>lusol.f-&gt;1040</INFO></DIV>

      else <COMMENT> TRP or TCP
 Move biggest element to top of each column.
 Set w(*) to mark slack columns (unit vectors).
</COMMENT>
         call <!new fthcall lu1mxc><A Name='C_1045'><a href="lusol_f_c.html#R_lu1mxc">lu1mxc</a></A><BRANCHEMENT>( 1, n, iq, a, indc, lenc, locc )</BRANCHEMENT>
         call <!new fthcall lu1slk><A Name='C_1046'><a href="lusol_f_c.html#R_lu1slk">lu1slk</a></A><BRANCHEMENT>( m, n, lena, iq, iqloc, a, locc, w )</BRANCHEMENT>
      end if

      <TEST>if</TEST> (TRP) then<DIV ALIGN=right><INFO>lusol.f-&gt;1050</INFO></DIV>
<COMMENT> Find biggest element in each row.
</COMMENT>
         call <!new fthcall lu1mxr><A Name='C_1052'><a href="lusol_f_c.html#R_lu1mxr">lu1mxr</a></A><BRANCHEMENT>( 1, m, ip, Amaxr,
     &                a, indc, lenc, locc, indr, lenr, locr )</BRANCHEMENT>
      end if

      <TEST>if</TEST> (TCP) then
<COMMENT> Set Ha(1:Hlen) = biggest element in each column,
     Hj(1:Hlen) = corresponding column indices.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;1060</INFO></DIV>
         Hlen  = 0
         <LOOP><A Name=C_1061>do</A></LOOP> kk = 1, n
            Hlen     = Hlen + 1
            j        = iq(kk)
            <TEST>if</TEST> (lenc(j) .gt. 0) then
               lc    = locc(j)
               amax  = abs( a(lc) )
            else
               amax  = zero
            end if<DIV ALIGN=right><INFO>lusol.f-&gt;1070</INFO></DIV>
            Ha(Hlen) = amax
            Hj(Hlen) = j
            Hk(j)    = Hlen
         <A Href=#C_1061>end do</A>

<COMMENT> Build the heap, creating new Ha, Hj and setting Hk(1:Hlen).
</COMMENT>
         call <!new fthcall Hbuild><A Name='C_1077'><a href="lusol_f_c.html#R_Hbuild">Hbuild</a></A><BRANCHEMENT>( Ha, Hj, Hk, Hlen, Hlen, hops )</BRANCHEMENT>
      end if

<COMMENT><HR></HR>
     Start of main loop.
<HR></HR></COMMENT>
      mleft  = m + 1
      nleft  = n + 1

      <LOOP><A Name=C_1086>do</A></LOOP> <A Href=#lu1fad_L_800>800</A> nrowu = 1, minmn

<COMMENT>        mktime = (nrowu / ntime) + 4
        eltime = (nrowu / ntime) + 9</COMMENT>
         mleft  = mleft - 1<DIV ALIGN=right><INFO>lusol.f-&gt;1091</INFO></DIV>
         nleft  = nleft - 1

<COMMENT>        Bail out if there are no nonzero rows left.
</COMMENT>
         <TEST>if</TEST> (iploc(1) .gt. m) go to 900

<COMMENT> For TCP, the largest Aij is at the top of the heap.
</COMMENT>
         <TEST>if</TEST> ( TCP ) then
            aijmax = Ha(1)      <COMMENT> Marvelously easy !</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;1101</INFO></DIV>
            Akmax  = max( Akmax, aijmax )
            aijtol = aijmax / Ltol
         end if

<COMMENT><HR></HR>
        Find a suitable pivot element.
<HR></HR>
</COMMENT>
         <TEST>if</TEST> ( Utri ) then
<COMMENT><HR></HR>
           So far all columns have had length 1.
           We are still looking for the (backward) triangular part of A
           that forms the first rows and columns of U.
<HR></HR>
</COMMENT>
            lq1    = iqloc(1)
            lq2    = n
            <TEST>if</TEST> (m   .gt.   1) lq2 = iqloc(2) - 1

            <TEST>if</TEST> (lq1 .le. lq2) then  <COMMENT> There are more cols of length 1.</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;1121</INFO></DIV>
               <TEST>if</TEST> (TPP .or. TSP) then
                  jbest  = iq(lq1)  <COMMENT> Grab the first one.
</COMMENT>
               else <COMMENT> TRP or TCP    ! Scan all columns of length 1.</COMMENT>
                  jbest  = 0

                  <LOOP><A Name=C_1127>do</A></LOOP> lq = lq1, lq2
                     j      = iq(lq)
                     <TEST>if</TEST> (w(j) .gt. zero) then <COMMENT> Accept a slack</COMMENT>
                        jbest  = j<DIV ALIGN=right><INFO>lusol.f-&gt;1131</INFO></DIV>
                        go to <A Href=#lu1fad_L_250>250</A>
                     end if

                     lc     = locc(j)
                     amax   = abs( a(lc) )
                     <TEST>if</TEST> (TRP) then
                        i      = indc(lc)
                        aijtol = Amaxr(i) / Ltol
                     end if

                     <TEST>if</TEST> (amax .ge. aijtol) then<DIV ALIGN=right><INFO>lusol.f-&gt;1142</INFO></DIV>
                        jbest  = j
                        go to <A Href=#lu1fad_L_250>250</A>
                     end if
                  <A Href=#C_1127>end do</A>
               end if

  <A Name=lu1fad_L_250>250</A>          <TEST>if</TEST> (jbest .gt. 0) then
                  lc     = locc(jbest)
                  ibest  = indc(lc)
                  mbest  = 0<DIV ALIGN=right><INFO>lusol.f-&gt;1152</INFO></DIV>
                  go to <A Href=#lu1fad_L_300>300</A>
               end if
            end if

<COMMENT>           This is the end of the U triangle.
           We will not return to this part of the code.
           TPP and TSP call lu1mxc for the first time
           (to move biggest element to top of each column).
</COMMENT>
            <TEST>if</TEST> (lprint .ge. 50) then<DIV ALIGN=right><INFO>lusol.f-&gt;1162</INFO></DIV>
               write(nout, 1100) 'Utri ended.  spars1 = true'
            end if
            Utri   = .false.
            Ltri   = .true.
            spars1 = .true.
            nUtri  =  nrowu - 1
            <TEST>if</TEST> (TPP .or. TSP) then
               call <!new fthcall lu1mxc><A Name='C_1169'><a href="lusol_f_c.html#R_lu1mxc">lu1mxc</a></A><BRANCHEMENT>( lq1, n, iq, a, indc, lenc, locc )</BRANCHEMENT>
            end if
         end if<DIV ALIGN=right><INFO>lusol.f-&gt;1172</INFO></DIV>

         <TEST>if</TEST> ( spars1 ) then
<COMMENT><HR></HR>
           Perform a Markowitz search.
           Search cols of length 1, then rows of length 1,
           then   cols of length 2, then rows of length 2, etc.
<HR></HR>
           call timer ( 'start ', mktime )

 if (TPP) then ! 12 Jun 2002: Next line disables lu1mCP below</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;1182</INFO></DIV>
            <TEST>if</TEST> (TPP .or. TCP) then
               call <!new fthcall lu1mar><A Name='C_1183'><a href="lusol_f_c.html#R_lu1mar">lu1mar</a></A><BRANCHEMENT>( m    , n     , lena  , maxmn,
     &                      TCP  , aijtol, Ltol  , maxcol, maxrow,
     &                      ibest, jbest , mbest ,
     &                      a    , indc  , indr  , ip   , iq,
     &                      lenc , lenr  , locc  , locr ,
     &                      iploc, iqloc )</BRANCHEMENT>

            else if (TRP) then
               call <!new fthcall lu1mRP><A Name='C_1191'><a href="lusol_f_c.html#R_lu1mRP">lu1mRP</a></A><BRANCHEMENT>( m    , n     , lena  , maxmn,
     &                      Ltol , maxcol, maxrow,
     &                      ibest, jbest , mbest ,
     &                      a    , indc  , indr  , ip   , iq,
     &                      lenc , lenr  , locc  , locr ,
     &                      iploc, iqloc , Amaxr )</BRANCHEMENT>

<COMMENT>           else if (TCP) then ! Disabled by test above
              call lu1mCP( m    , n     , lena  , aijtol,
    &              ibest, jbest , mbest ,
    &              a    , indc  , indr  ,
    &              lenc , lenr  , locc  ,
    &              Hlen , Ha    , Hj    )
</COMMENT>
            else if (TSP) then
               call <!new fthcall lu1mSP><A Name='C_1206'><a href="lusol_f_c.html#R_lu1mSP">lu1mSP</a></A><BRANCHEMENT>( m    , n     , lena  , maxmn,
     &                      Ltol , maxcol,
     &                      ibest, jbest , mbest ,
     &                      a    , indc  , iq    , locc , iqloc )</BRANCHEMENT>
               <TEST>if</TEST> (ibest .eq. 0) go to 990
            end if<DIV ALIGN=right><INFO>lusol.f-&gt;1212</INFO></DIV>

<COMMENT>           call timer ( 'finish', mktime )
</COMMENT>
            <TEST>if</TEST> ( Ltri ) then

<COMMENT>              So far all rows have had length 1.
              We are still looking for the (forward) triangle of A
              that forms the first rows and columns of L.
</COMMENT>
               <TEST>if</TEST> (mbest .gt. 0) then<DIV ALIGN=right><INFO>lusol.f-&gt;1222</INFO></DIV>
                   Ltri   = .false.
                   nLtri  =  nrowu - 1 - nUtri
                   <TEST>if</TEST> (lprint .ge. 50) then
                      write(nout, 1100) 'Ltri ended.'
                   end if
               end if

            else

<COMMENT>              See if what's left is as dense as dens1.
</COMMENT>
               <TEST>if</TEST> (nzleft  .ge.  (dens1 * mleft) * nleft) then
                   spars1 = .false.
                   spars2 = .true.
                   ndens1 =  nleft
                   maxrow =  0
                   <TEST>if</TEST> (lprint .ge. 50) then
                      write(nout, 1100) 'spars1 ended.  spars2 = true'
                   end if
               end if<DIV ALIGN=right><INFO>lusol.f-&gt;1242</INFO></DIV>
            end if

         else if ( spars2 .or. dense ) then
<COMMENT><HR></HR>
           Perform a restricted Markowitz search,
           looking at only the first maxcol columns.  (maxrow = 0.)
<HR></HR>
           call timer ( 'start ', mktime )

 if (TPP) then ! 12 Jun 2002: Next line disables lu1mCP below</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;1252</INFO></DIV>
            <TEST>if</TEST> (TPP .or. TCP) then
               call <!new fthcall lu1mar><A Name='C_1253'><a href="lusol_f_c.html#R_lu1mar">lu1mar</a></A><BRANCHEMENT>( m    , n     , lena  , maxmn,
     &              TCP  , aijtol, Ltol  , maxcol, maxrow,
     &              ibest, jbest , mbest ,
     &              a    , indc  , indr  , ip   , iq,
     &              lenc , lenr  , locc  , locr ,
     &              iploc, iqloc )</BRANCHEMENT>

            else if (TRP) then
               call <!new fthcall lu1mRP><A Name='C_1261'><a href="lusol_f_c.html#R_lu1mRP">lu1mRP</a></A><BRANCHEMENT>( m    , n     , lena  , maxmn,
     &              Ltol , maxcol, maxrow,
     &              ibest, jbest , mbest ,
     &              a    , indc  , indr  , ip   , iq,
     &              lenc , lenr  , locc  , locr ,
     &              iploc, iqloc , Amaxr )</BRANCHEMENT>

<COMMENT>           else if (TCP) then ! Disabled by test above
              call lu1mCP( m    , n     , lena  , aijtol,
    &              ibest, jbest , mbest ,
    &              a    , indc  , indr  ,
    &              lenc , lenr  , locc  ,
    &              Hlen , Ha    , Hj    )
</COMMENT>
            else if (TSP) then
               call <!new fthcall lu1mSP><A Name='C_1276'><a href="lusol_f_c.html#R_lu1mSP">lu1mSP</a></A><BRANCHEMENT>( m    , n     , lena  , maxmn,
     &                      Ltol , maxcol,
     &                      ibest, jbest , mbest ,
     &                      a    , indc  , iq    , locc , iqloc )</BRANCHEMENT>
               <TEST>if</TEST> (ibest .eq. 0) go to 985
            end if<DIV ALIGN=right><INFO>lusol.f-&gt;1282</INFO></DIV>

<COMMENT>           call timer ( 'finish', mktime )

           See if what's left is as dense as dens2.
</COMMENT>
            <TEST>if</TEST> ( spars2 ) then
               <TEST>if</TEST> (nzleft  .ge.  (dens2 * mleft) * nleft) then
                   spars2 = .false.
                   dense  = .true.
                   ndens2 =  nleft<DIV ALIGN=right><INFO>lusol.f-&gt;1292</INFO></DIV>
                   maxcol =  1
                   <TEST>if</TEST> (lprint .ge. 50) then
                      write(nout, 1100) 'spars2 ended.  dense = true'
                   end if
               end if
            end if
         end if

<COMMENT><HR></HR>
        See if we can finish quickly.
<HR></HR></COMMENT>
         <TEST>if</TEST> ( dense  ) then
            lenD   = mleft * nleft
            nfree  = lu1 - 1

            <TEST>if</TEST> (nfree .ge. 2 * lenD) then

<COMMENT>              There is room to treat the remaining matrix as
              a dense matrix D.
              We may have to compress the column file first.
              12 Nov 1999: D used to be put at the
                           beginning of free storage (lD = lcol + 1).
                           Now put it at the end     (lD = lu1 - lenD)
                           so the left-shift in lu1ful will not
                           involve overlapping storage
                           (fatal with parallel dcopy).
</COMMENT>
               densLU = .true.
               ndens2 = nleft
               lD     = lu1 - lenD<DIV ALIGN=right><INFO>lusol.f-&gt;1322</INFO></DIV>
               <TEST>if</TEST> (lcol .ge. lD) then
                  call <!new fthcall lu1rec><A Name='C_1323'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( n, .true., luparm, lcol,
     &                         lena, a, indc, lenc, locc )</BRANCHEMENT>
                  lfile  = lcol
                  jlast  = indc(lcol + 1)
               end if

               go to <A Href=#lu1fad_L_900>900</A>
            end if
         end if<DIV ALIGN=right><INFO>lusol.f-&gt;1332</INFO></DIV>

<COMMENT><HR></HR>
        The best  aij  has been found.
        The pivot row  ibest  and the pivot column  jbest
        Define a dense matrix  D  of size  nrowd  by  ncold.
<HR></HR></COMMENT>
  <A Name=lu1fad_L_300>300</A>    ncold  = lenr(ibest)
         nrowd  = lenc(jbest)
         melim  = nrowd  - 1
         nelim  = ncold  - 1<DIV ALIGN=right><INFO>lusol.f-&gt;1342</INFO></DIV>
         mersum = mersum + mbest
         lenL   = lenL   + melim
         lenU   = lenU   + ncold
         <TEST>if</TEST> (lprint .ge. 50) then
            <TEST>if</TEST> (nrowu .eq. 1) then
               write(nout, 1100) 'lu1fad debug:'
            end if
            <TEST>if</TEST> ( TPP .or. TRP .or. TSP ) then
               write(nout, 1200) nrowu, ibest, jbest, nrowd, ncold
            else <COMMENT> TCP</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;1352</INFO></DIV>
               jmax   = Hj(1)
               imax   = indc(locc(jmax))
               write(nout, 1200) nrowu, ibest, jbest, nrowd, ncold,
     &                           imax , jmax , aijmax
            end if
         end if

<COMMENT><HR></HR>
        Allocate storage for the next column of  L  and next row of  U.
        Initially the top of a, indc, indr are used as follows:

                   ncold       melim       ncold        melim

        a      |...........|...........|ujbest..ujn|li1......lim|

        indc   |...........|  lenr(i)  |  lenc(j)  |  markl(i)  |

        indr   |...........| iqloc(i)  |  jfill(j) |  ifill(i)  |

              ^           ^             ^           ^            ^
              lfree   lsave             lu1         ll1          oldlu1

        Later the correct indices are inserted:

        indc   |           |           |           |i1........im|

        indr   |           |           |jbest....jn|ibest..ibest|

<HR></HR></COMMENT>
         <TEST>if</TEST> ( keepLU ) then<DIV ALIGN=right><INFO>lusol.f-&gt;1382</INFO></DIV>
<COMMENT>           relax</COMMENT>
         else
<COMMENT>           Always point to the top spot.
           Only the current column of L and row of U will
           take up space, overwriting the previous ones.</COMMENT>
            lu1    = ldiagU + 1
         end if
         ll1    = lu1   - melim
         lu1    = ll1   - ncold
         lsave  = lu1   - nrowd<DIV ALIGN=right><INFO>lusol.f-&gt;1392</INFO></DIV>
         lfree  = lsave - ncold

<COMMENT>        Make sure the column file has room.
        Also force a compression if its length exceeds a certain limit.
</COMMENT>
         limit  = uspace * lfile  +  m  +  n  +  1000
         minfre = ncold  + melim
         nfree  = lfree  - lcol
         <TEST>if</TEST> (nfree .lt. minfre  .or.  lcol .gt. limit) then
            call <!new fthcall lu1rec><A Name='C_1401'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( n, .true., luparm, lcol,
     &                   lena, a, indc, lenc, locc )</BRANCHEMENT>
            lfile  = lcol
            jlast  = indc(lcol + 1)
            nfree  = lfree - lcol
            <TEST>if</TEST> (nfree .lt. minfre) go to 970
         end if

<COMMENT>        Make sure the row file has room.
</COMMENT>
         minfre = melim + ncold<DIV ALIGN=right><INFO>lusol.f-&gt;1412</INFO></DIV>
         nfree  = lfree - lrow
         <TEST>if</TEST> (nfree .lt. minfre  .or.  lrow .gt. limit) then
            call <!new fthcall lu1rec><A Name='C_1414'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( m, .false., luparm, lrow,
     &                   lena, a, indr, lenr, locr )</BRANCHEMENT>
            lfile  = lrow
            ilast  = indr(lrow + 1)
            nfree  = lfree - lrow
            <TEST>if</TEST> (nfree .lt. minfre) go to 970
         end if

<COMMENT><HR></HR>
        Move the pivot element to the front of its row
        and to the top of its column.
<HR></HR></COMMENT>
         lpivr  = locr(ibest)
         lpivr1 = lpivr + 1
         lpivr2 = lpivr + nelim

         <LOOP><A Name=C_1430>do</A></LOOP> <A Href=#lu1fad_L_330>330</A> l = lpivr, lpivr2
            <TEST>if</TEST> (indr(l) .eq. jbest) go to 335
  <A Name=lu1fad_L_330>330</A>[<A Href=#C_1430>1</A>]    continue<DIV ALIGN=right><INFO>lusol.f-&gt;1433</INFO></DIV>

  <A Name=lu1fad_L_335>335</A>    indr(l)     = indr(lpivr)
         indr(lpivr) = jbest

         lpivc  = locc(jbest)
         lpivc1 = lpivc + 1
         lpivc2 = lpivc + melim

         <LOOP><A Name=C_1441>do</A></LOOP> <A Href=#lu1fad_L_340>340</A> l = lpivc, lpivc2
            <TEST>if</TEST> (indc(l) .eq. ibest) go to 345<DIV ALIGN=right><INFO>lusol.f-&gt;1443</INFO></DIV>
  <A Name=lu1fad_L_340>340</A>[<A Href=#C_1441>1</A>]    continue

  <A Name=lu1fad_L_345>345</A>    indc(l)     = indc(lpivc)
         indc(lpivc) = ibest
         abest       = a(l)
         a(l)        = a(lpivc)
         a(lpivc)    = abest

         <TEST>if</TEST> ( keepLU ) then
<COMMENT>           relax</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;1453</INFO></DIV>
         else
<COMMENT>           Store just the diagonal of U, in natural order.
!!         a(ldiagU + nrowu) = abest ! This was in pivot order.</COMMENT>
            a(ldiagU + jbest) = abest
         end if

<COMMENT><HR></HR>
 Delete pivot col from heap.
 Hk tells us where it is in the heap.
<HR></HR></COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;1463</INFO></DIV>
         <TEST>if</TEST> ( TCP ) then
            kbest  = Hk(jbest)
            Hlenin = Hlen
            call <!new fthcall Hdelete><A Name='C_1466'><a href="lusol_f_c.html#R_Hdelete">Hdelete</a></A><BRANCHEMENT>( Ha, Hj, Hk, Hlenin, Hlen, n, kbest, h )</BRANCHEMENT>
            hops   = hops + h
         end if

<COMMENT><HR></HR>
        Delete the pivot row from the column file
        and store it as the next row of  U.
        set  indr(lu) = 0     to initialize jfill ptrs on columns of D,
             indc(lu) = lenj  to save the original column lengths.
<HR></HR></COMMENT>
         a(lu1)    = abest
         indr(lu1) = jbest
         indc(lu1) = nrowd
         lu        = lu1

         diag      = abs( abest )
         Umax      = max(  Umax, diag )<DIV ALIGN=right><INFO>lusol.f-&gt;1483</INFO></DIV>
         DUmax     = max( DUmax, diag )
         DUmin     = min( DUmin, diag )

         <LOOP><A Name=C_1486>do</A></LOOP> <A Href=#lu1fad_L_360>360</A> lr   = lpivr1, lpivr2
            lu       = lu + 1
            j        = indr(lr)
            lenj     = lenc(j)
            lenc(j)  = lenj - 1
            lc1      = locc(j)
            last     = lc1 + lenc(j)<DIV ALIGN=right><INFO>lusol.f-&gt;1493</INFO></DIV>

            <LOOP><A Name=C_1494>do</A></LOOP> <A Href=#lu1fad_L_350>350</A> l = lc1, last
               <TEST>if</TEST> (indc(l) .eq. ibest) go to 355
  <A Name=lu1fad_L_350>350</A>[<A Href=#C_1494>1</A>]       continue

  <A Name=lu1fad_L_355>355</A>       a(lu)      = a(l)
            indr(lu)   = 0
            indc(lu)   = lenj
            Umax       = max( Umax, abs( a(lu) ) )
            a(l)       = a(last)<DIV ALIGN=right><INFO>lusol.f-&gt;1503</INFO></DIV>
            indc(l)    = indc(last)
            indc(last) = 0       <COMMENT> Free entry
???        if (j .eq. jlast) lcol = lcol - 1</COMMENT>
  <A Name=lu1fad_L_360>360</A>[<A Href=#C_1486>1</A>]    continue

<COMMENT><HR></HR>
        Delete the pivot column from the row file
        and store the nonzeros of the next column of  L.
        Set  indc(ll) = 0     to initialize markl(*) markers,
             indr(ll) = 0     to initialize ifill(*) row fill-in cntrs,
             indc(ls) = leni  to save the original row lengths,
             indr(ls) = iqloc(i)    to save parts of  iqloc(*),
             iqloc(i) = lsave - ls  to point to the nonzeros of  L
                      = -1, -2, -3, ... in mark(*).
<HR></HR></COMMENT>
         indc(lsave) = ncold
         <TEST>if</TEST> (melim .eq. 0) go to 700

         ll     = ll1 - 1
         ls     = lsave<DIV ALIGN=right><INFO>lusol.f-&gt;1523</INFO></DIV>
         abest  = one / abest

         <LOOP><A Name=C_1525>do</A></LOOP> <A Href=#lu1fad_L_390>390</A> lc   = lpivc1, lpivc2
            ll       = ll + 1
            ls       = ls + 1
            i        = indc(lc)
            leni     = lenr(i)
            lenr(i)  = leni - 1
            lr1      = locr(i)
            last     = lr1 + lenr(i)<DIV ALIGN=right><INFO>lusol.f-&gt;1533</INFO></DIV>

            <LOOP><A Name=C_1534>do</A></LOOP> <A Href=#lu1fad_L_380>380</A> l = lr1, last
               <TEST>if</TEST> (indr(l) .eq. jbest) go to 385
  <A Name=lu1fad_L_380>380</A>[<A Href=#C_1534>1</A>]       continue

  <A Name=lu1fad_L_385>385</A>       indr(l)    = indr(last)
            indr(last) = 0       <COMMENT> Free entry
???        if (i .eq. ilast) lrow = lrow - 1
</COMMENT>
            a(ll)      = - a(lc) * abest<DIV ALIGN=right><INFO>lusol.f-&gt;1543</INFO></DIV>
            Lij        = abs( a(ll) )
            Lmax       = max( Lmax, Lij )
<COMMENT>!!!! DEBUG
           if (Lij .gt. Ltol) then
              write( *  ,*) ' Big Lij!!!', nrowu
              write(nout,*) ' Big Lij!!!', nrowu
           end if
</COMMENT>
            indc(ll)   = 0
            indr(ll)   = 0<DIV ALIGN=right><INFO>lusol.f-&gt;1553</INFO></DIV>
            indc(ls)   = leni
            indr(ls)   = iqloc(i)
            iqloc(i)   = lsave - ls
  <A Name=lu1fad_L_390>390</A>[<A Href=#C_1525>1</A>]    continue

<COMMENT><HR></HR>
        Do the Gaussian elimination.
        This involves adding a multiple of the pivot column
        to all other columns in the pivot row.

        Sometimes more than one call to lu1gau is needed to allow
        compression of the column file.
        lfirst  says which column the elimination should start with.
        minfre  is a bound on the storage needed for any one column.
        lu      points to off-diagonals of u.
        nfill   keeps track of pending fill-in in the row file.
<HR></HR></COMMENT>
         <TEST>if</TEST> (nelim .eq. 0) go to 700
         lfirst = lpivr1
         minfre = mleft + nspare
         lu     = 1<DIV ALIGN=right><INFO>lusol.f-&gt;1574</INFO></DIV>
         nfill  = 0

<COMMENT> 400    call timer ( 'start ', eltime )</COMMENT>
  <A Name=lu1fad_L_400>400</A>    call <!new fthcall lu1gau><A Name='C_1577'><a href="lusol_f_c.html#R_lu1gau">lu1gau</a></A><BRANCHEMENT>( m     , melim , ncold , nspare, small ,
     &                lpivc1, lpivc2, lfirst, lpivr2, lfree , minfre,
     &                ilast , jlast , lrow  , lcol  , lu    , nfill ,
     &                a     , indc  , indr  ,
     &                lenc  , lenr  , locc  , locr  ,
     &                iqloc , a(ll1), indc(ll1),
     &                        a(lu1), indr(ll1), indr(lu1) )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;1584</INFO></DIV>
<COMMENT>        call timer ( 'finish', eltime )
</COMMENT>
         <TEST>if</TEST> (lfirst .gt. 0) then

<COMMENT>           The elimination was interrupted.
           Compress the column file and try again.
           lfirst, lu and nfill have appropriate new values.
</COMMENT>
            call <!new fthcall lu1rec><A Name='C_1592'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( n, .true., luparm, lcol,
     &                   lena, a, indc, lenc, locc )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;1594</INFO></DIV>
            lfile  = lcol
            jlast  = indc(lcol + 1)
            lpivc  = locc(jbest)
            lpivc1 = lpivc + 1
            lpivc2 = lpivc + melim
            nfree  = lfree - lcol
            <TEST>if</TEST> (nfree .lt. minfre) go to 970
            go to <A Href=#lu1fad_L_400>400</A>
         end if

<COMMENT><HR></HR>
        The column file has been fully updated.
        Deal with any pending fill-in in the row file.
<HR></HR></COMMENT>
         <TEST>if</TEST> (nfill .gt. 0) then

<COMMENT>           Compress the row file if necessary.
           lu1gau has set nfill to be the number of pending fill-ins
           plus the current length of any rows that need to be moved.
</COMMENT>
            minfre = nfill<DIV ALIGN=right><INFO>lusol.f-&gt;1615</INFO></DIV>
            nfree  = lfree - lrow
            <TEST>if</TEST> (nfree .lt. minfre) then
               call <!new fthcall lu1rec><A Name='C_1617'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( m, .false., luparm, lrow,
     &                      lena, a, indr, lenr, locr )</BRANCHEMENT>
               lfile  = lrow
               ilast  = indr(lrow + 1)
               lpivr  = locr(ibest)
               lpivr1 = lpivr + 1
               lpivr2 = lpivr + nelim
               nfree  = lfree - lrow<DIV ALIGN=right><INFO>lusol.f-&gt;1625</INFO></DIV>
               <TEST>if</TEST> (nfree .lt. minfre) go to 970
            end if

<COMMENT>           Move rows that have pending fill-in to end of the row file.
           Then insert the fill-in.
</COMMENT>
            call <!new fthcall lu1pen><A Name='C_1631'><a href="lusol_f_c.html#R_lu1pen">lu1pen</a></A><BRANCHEMENT>( m     , melim , ncold , nspare, ilast,
     &                   lpivc1, lpivc2, lpivr1, lpivr2, lrow ,
     &                   lenc  , lenr  , locc  , locr  ,
     &                   indc  , indr  , indr(ll1), indr(lu1) )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;1635</INFO></DIV>
         end if

<COMMENT><HR></HR>
        Restore the saved values of  iqloc.
        Insert the correct indices for the col of L and the row of U.
<HR></HR></COMMENT>
  <A Name=lu1fad_L_700>700</A>    lenr(ibest) = 0
         lenc(jbest) = 0

         ll          = ll1 - 1<DIV ALIGN=right><INFO>lusol.f-&gt;1645</INFO></DIV>
         ls          = lsave

         <LOOP><A Name=C_1647>do</A></LOOP> <A Href=#lu1fad_L_710>710</A>  lc  = lpivc1, lpivc2
            ll       = ll + 1
            ls       = ls + 1
            i        = indc(lc)
            iqloc(i) = indr(ls)
            indc(ll) = i
            indr(ll) = ibest
  <A Name=lu1fad_L_710>710</A>[<A Href=#C_1647>1</A>]    continue<DIV ALIGN=right><INFO>lusol.f-&gt;1655</INFO></DIV>

         lu          = lu1 - 1

         <LOOP><A Name=C_1658>do</A></LOOP> <A Href=#lu1fad_L_720>720</A>  lr  = lpivr, lpivr2
            lu       = lu + 1
            indr(lu) = indr(lr)
  <A Name=lu1fad_L_720>720</A>[<A Href=#C_1658>1</A>]    continue

<COMMENT><HR></HR>
        Free the space occupied by the pivot row
        and update the column permutation.
        Then free the space occupied by the pivot column
        and update the row permutation.

        nzchng is found in both calls to lu1pq2, but we use it only
        after the second.
<HR></HR></COMMENT>
         call <!new fthcall lu1pq2><A Name='C_1672'><a href="lusol_f_c.html#R_lu1pq2">lu1pq2</a></A><BRANCHEMENT>( ncold, nzchng,
     &                indr(lpivr), indc( lu1 ), lenc, iqloc, iq, iqinv )</BRANCHEMENT>

         call <!new fthcall lu1pq2><A Name='C_1675'><a href="lusol_f_c.html#R_lu1pq2">lu1pq2</a></A><BRANCHEMENT>( nrowd, nzchng,
     &                indc(lpivc), indc(lsave), lenr, iploc, ip, ipinv )</BRANCHEMENT>

         nzleft = nzleft + nzchng

<COMMENT><HR></HR>
        lu1mxr resets Amaxr(i) in each modified row i.
        lu1mxc moves the largest aij to the top of each modified col j.
        28 Jun 2002: Note that cols of L have an implicit diag of 1.0,
                     so lu1mxr is called with ll1, not ll1+1, whereas
                        lu1mxc is called with          lu1+1.
<HR></HR></COMMENT>
         <TEST>if</TEST> (Utri .and. TPP) then
<COMMENT> Relax -- we're not keeping big elements at the top yet.
</COMMENT>
         else
            <TEST>if</TEST> (TRP  .and.  melim .gt. 0) then
               call <!new fthcall lu1mxr><A Name='C_1692'><a href="lusol_f_c.html#R_lu1mxr">lu1mxr</a></A><BRANCHEMENT>( ll1, ll, indc, Amaxr,
     &                      a, indc, lenc, locc, indr, lenr, locr )</BRANCHEMENT>
            end if

            <TEST>if</TEST> (nelim .gt. 0) then<DIV ALIGN=right><INFO>lusol.f-&gt;1697</INFO></DIV>
               call <!new fthcall lu1mxc><A Name='C_1697'><a href="lusol_f_c.html#R_lu1mxc">lu1mxc</a></A><BRANCHEMENT>( lu1+1, lu, indr, a, indc, lenc, locc )</BRANCHEMENT>

               <TEST>if</TEST> (TCP) then <COMMENT> Update modified columns in heap</COMMENT>
                  <LOOP><A Name=C_1700>do</A></LOOP> kk = lu1+1, lu
                     j    = indr(kk)
                     k    = Hk(j)
                     v    = abs( a(locc(j)) ) <COMMENT> Biggest aij in column j</COMMENT>
                     call <!new fthcall Hchange><A Name='C_1704'><a href="lusol_f_c.html#R_Hchange">Hchange</a></A><BRANCHEMENT>( Ha, Hj, Hk, Hlen, n, k, v, j, h )</BRANCHEMENT>
                     hops = hops + h
                  <A Href=#C_1700>end do</A><DIV ALIGN=right><INFO>lusol.f-&gt;1707</INFO></DIV>
               end if
            end if
         end if

<COMMENT><HR></HR>
        Negate lengths of pivot row and column so they will be
        eliminated during compressions.
<HR></HR></COMMENT>
         lenr(ibest) = - ncold
         lenc(jbest) = - nrowd<DIV ALIGN=right><INFO>lusol.f-&gt;1717</INFO></DIV>

<COMMENT>        Test for fatal bug: row or column lists overwriting L and U.
</COMMENT>
         <TEST>if</TEST> (lrow .gt. lsave) go to 980
         <TEST>if</TEST> (lcol .gt. lsave) go to 980

<COMMENT>        Reset the file lengths if pivot row or col was at the end.
</COMMENT>
         <TEST>if</TEST> (ibest .eq. ilast) then
            lrow = locr(ibest)<DIV ALIGN=right><INFO>lusol.f-&gt;1727</INFO></DIV>
         end if

         <TEST>if</TEST> (jbest .eq. jlast) then
            lcol = locc(jbest)
         end if
  <A Name=lu1fad_L_800>800</A>[<A Href=#C_1086>1</A>] continue

<COMMENT><HR></HR>
     End of main loop.
<HR></HR>

<HR></HR>
     Normal exit.
     Move empty rows and cols to the end of ip, iq.
     Then finish with a dense LU if necessary.
<HR></HR></COMMENT>
  <A Name=lu1fad_L_900>900</A> inform = 0
      call <!new fthcall lu1pq3><A Name='C_1744'><a href="lusol_f_c.html#R_lu1pq3">lu1pq3</a></A><BRANCHEMENT>( m, lenr, ip, ipinv, mrank )</BRANCHEMENT>
      call <!new fthcall lu1pq3><A Name='C_1745'><a href="lusol_f_c.html#R_lu1pq3">lu1pq3</a></A><BRANCHEMENT>( n, lenc, iq, iqinv, nrank )</BRANCHEMENT>
      nrank  = min( mrank, nrank )<DIV ALIGN=right><INFO>lusol.f-&gt;1747</INFO></DIV>

      <TEST>if</TEST> ( densLU ) then
<COMMENT>        call timer ( 'start ', 17 )</COMMENT>
         call <!new fthcall lu1ful><A Name='C_1750'><a href="lusol_f_c.html#R_lu1ful">lu1ful</a></A><BRANCHEMENT>( m     , n    , lena , lenD , lu1 , TPP,
     &                mleft , nleft, nrank, nrowu,
     &                lenL  , lenU , nsing,
     &                keepLU, small,
     &                a     , a(lD), indc , indr , ip  , iq,
     &                lenc  , lenr , locc , ipinv, locr )</BRANCHEMENT>
<COMMENT>***     21 Dec 1994: Bug in next line.
***     nrank  = nrank - nsing.  Changed to next line:
***     nrank  = minmn - nsing

***     26 Mar 2006: Previous line caused bug with m&lt;n and nsing&gt;0.
        Don't mess with nrank any more.  Let end of lu1fac handle it.
        call timer ( 'finish', 17 )</COMMENT>
      end if

      minlen = lenL  +  lenU  +  2*(m + n)
      go to <A Href=#lu1fad_L_990>990</A><DIV ALIGN=right><INFO>lusol.f-&gt;1767</INFO></DIV>

<COMMENT>     Not enough space free after a compress.
     Set  minlen  to an estimate of the necessary value of  lena.
</COMMENT>
  <A Name=lu1fad_L_970>970</A> inform = 7
      minlen = lena  +  lfile  +  2*(m + n)
      go to <A Href=#lu1fad_L_990>990</A>

<COMMENT>     Fatal error.  This will never happen!
    (Famous last words.)
</COMMENT>
  <A Name=lu1fad_L_980>980</A> inform = 8
      go to <A Href=#lu1fad_L_990>990</A>

<COMMENT>     Fatal error with TSP.  Diagonal pivot not found.
</COMMENT>
  <A Name=lu1fad_L_985>985</A> inform = 9

<COMMENT>     Exit.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;1787</INFO></DIV>
  <A Name=lu1fad_L_990>990</A> continue
<COMMENT>     call timer ( 'finish', 3 )</COMMENT>
      return

 <A Name=lu1fad_L_1100>1100</A> format(/ 1x, a)
 <A Name=lu1fad_L_1200>1200</A> format(  ' nrowu', i7,
     &       '   i,jbest', 2i7,
     &       '   nrowd,ncold', 2i6,
     &       '   i,jmax', 2i7,
     &       '   aijmax', 1p, e10.2)<DIV ALIGN=right><INFO>lusol.f-&gt;1797</INFO></DIV>

      end subroutine <a href="lusol_f_c.html#R_lu1fad">lu1fad</a> <COMMENT> subroutine lu1fad

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1gau><A Name='R_lu1gau'><a target="index" href="lusol_f_i.html#R_lu1gau">lu1gau</a></A><ARGLIST>( m     , melim , ncold , nspare, small ,
     &                   lpivc1, lpivc2, lfirst, lpivr2, lfree , minfre,
     &                   ilast , jlast , lrow  , lcol  , lu    , nfill ,
     &                   a     , indc  , indr  ,
     &                   lenc  , lenr  , locc  , locr  ,
     &                   mark  , al    , markl ,
     &                           au    , ifill , jfill )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>double precision</DECLARE> <VARIABLE>a(*)        , al(melim)   , au(ncold)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(*)     , indr(*)     , lenc(*)  , lenr(*),</VARIABLE>
     &                   mark(*)     , markl(melim),
     &                   ifill(melim), jfill(ncold)
      <DECLARE>integer</DECLARE> <VARIABLE>locc(*)     , locr(*)</VARIABLE>

<COMMENT><HR></HR>
     lu1gau does most of the work for each step of
     Gaussian elimination.
     A multiple of the pivot column is added to each other column j
     in the pivot row.  The column list is fully updated.
     The row list is updated if there is room, but some fill-ins may
     remain, as indicated by ifill and jfill.


  Input:
     ilast    is the row    at the end of the row    list.
     jlast    is the column at the end of the column list.
     lfirst   is the first column to be processed.
     lu + 1   is the corresponding element of U in au(*).
     nfill    keeps track of pending fill-in.
     a(*)     contains the nonzeros for each column j.
     indc(*)  contains the row indices for each column j.
     al(*)    contains the new column of L.  A multiple of it is
              used to modify each column.
     mark(*)  has been set to -1, -2, -3, ... in the rows
              corresponding to nonzero 1, 2, 3, ... of the col of L.
     au(*)    contains the new row of U.  Each nonzero gives the
              required multiple of the column of L.

  Workspace:
     markl(*) marks the nonzeros of L actually used.
              (A different mark, namely j, is used for each column.)

  Output:
     ilast     New last row    in the row    list.
     jlast     New last column in the column list.
     lfirst    = 0 if all columns were completed,
               &gt; 0 otherwise.
     lu        returns the position of the last nonzero of U
               actually used, in case we come back in again.
     nfill     keeps track of the total extra space needed in the
               row file.
     ifill(ll) counts pending fill-in for rows involved in the new
               column of L.
     jfill(lu) marks the first pending fill-in stored in columns
               involved in the new row of U.

     16 Apr 1989: First version of lu1gau.
     23 Apr 1989: lfirst, lu, nfill are now input and output
                  to allow re-entry if elimination is interrupted.
     23 Mar 2001: Introduced ilast, jlast.
     27 Mar 2001: Allow fill-in "in situ" if there is already room
                  up to but NOT INCLUDING the end of the
                  row or column file.
                  Seems safe way to avoid overwriting empty rows/cols
                  at the end.  (May not be needed though, now that we
                  have ilast and jlast.)
<HR></HR>
</COMMENT>
      <DECLARE>logical</DECLARE> <VARIABLE>atend</VARIABLE>

      <LOOP><A Name=C_1873>do</A></LOOP> <A Href=#lu1gau_L_600>600</A> lr = lfirst, lpivr2
         j      = indr(lr)
         lenj   = lenc(j)
         nfree  = lfree - lcol
         <TEST>if</TEST> (nfree .lt. minfre) go to 900<DIV ALIGN=right><INFO>lusol.f-&gt;1878</INFO></DIV>

<COMMENT><HR></HR>
        Inner loop to modify existing nonzeros in column  j.
        Loop 440 performs most of the arithmetic involved in the
        whole LU factorization.
        ndone counts how many multipliers were used.
        ndrop counts how many modified nonzeros are negligibly small.
<HR></HR></COMMENT>
         lu     = lu + 1
         uj     = au(lu)<DIV ALIGN=right><INFO>lusol.f-&gt;1888</INFO></DIV>
         lc1    = locc(j)
         lc2    = lc1 + lenj - 1
         atend  = j .eq. jlast
         ndone  = 0
         <TEST>if</TEST> (lenj .eq. 0) go to 500

         ndrop  = 0

         <LOOP><A Name=C_1896>do</A></LOOP> <A Href=#lu1gau_L_440>440</A> l = lc1, lc2
            i        =   indc(l)<DIV ALIGN=right><INFO>lusol.f-&gt;1898</INFO></DIV>
            ll       = - mark(i)
            <TEST>if</TEST> (ll .gt. 0) then
               ndone     = ndone + 1
               markl(ll) = j
               a(l)      = a(l)  +  al(ll) * uj
               <TEST>if</TEST> (abs( a(l) ) .le. small) then
                  ndrop  = ndrop + 1
               end if
            end if
  <A Name=lu1gau_L_440>440</A>[<A Href=#C_1896>1</A>]    continue<DIV ALIGN=right><INFO>lusol.f-&gt;1908</INFO></DIV>

<COMMENT><HR></HR>
        Remove any negligible modified nonzeros from both
        the column file and the row file.
<HR></HR></COMMENT>
         <TEST>if</TEST> (ndrop .eq. 0) go to 500
         k      = lc1

         <LOOP><A Name=C_1916>do</A></LOOP> <A Href=#lu1gau_L_480>480</A> l = lc1, lc2
            i        = indc(l)<DIV ALIGN=right><INFO>lusol.f-&gt;1918</INFO></DIV>
            <TEST>if</TEST> (abs( a(l) ) .le. small) go to 460
            a(k)     = a(l)
            indc(k)  = i
            k        = k + 1
            go to <A Href=#lu1gau_L_480>480</A>

<COMMENT>           Delete the nonzero from the row file.
</COMMENT>
  <A Name=lu1gau_L_460>460</A>       lenj     = lenj    - 1
            lenr(i)  = lenr(i) - 1<DIV ALIGN=right><INFO>lusol.f-&gt;1928</INFO></DIV>
            lr1      = locr(i)
            last     = lr1 + lenr(i)

            <LOOP><A Name=C_1931>do</A></LOOP> <A Href=#lu1gau_L_470>470</A> lrep = lr1, last
               <TEST>if</TEST> (indr(lrep) .eq. j) go to 475
  <A Name=lu1gau_L_470>470</A>[<A Href=#C_1931>1</A>]       continue

  <A Name=lu1gau_L_475>475</A>       indr(lrep) = indr(last)
            indr(last) = 0
            <TEST>if</TEST> (i .eq. ilast) lrow = lrow - 1<DIV ALIGN=right><INFO>lusol.f-&gt;1938</INFO></DIV>
  <A Name=lu1gau_L_480>480</A>[<A Href=#C_1916>1</A>]    continue

<COMMENT>        Free the deleted elements from the column file.
</COMMENT>
         <LOOP><A Name=C_1942>do</A></LOOP> <A Href=#lu1gau_L_490>490</A>  l  = k, lc2
            indc(l) = 0
  <A Name=lu1gau_L_490>490</A>[<A Href=#C_1942>1</A>]    continue
         <TEST>if</TEST> (atend) lcol = k - 1

<COMMENT><HR></HR>
        Deal with the fill-in in column j.
<HR></HR></COMMENT>
  <A Name=lu1gau_L_500>500</A>    <TEST>if</TEST> (ndone .eq. melim) go to 590

<COMMENT>        See if column j already has room for the fill-in.
</COMMENT>
         <TEST>if</TEST> (atend) go to 540
         last   = lc1  + lenj - 1
         l1     = last + 1
         l2     = last + (melim - ndone)<DIV ALIGN=right><INFO>lusol.f-&gt;1958</INFO></DIV>
<COMMENT> 27 Mar 2001: Be sure it's not at or past end of the col file.</COMMENT>
         <TEST>if</TEST> (l2 .ge. lcol) go to 520

         <LOOP><A Name=C_1961>do</A></LOOP> <A Href=#lu1gau_L_510>510</A> l = l1, l2
            <TEST>if</TEST> (indc(l) .ne. 0) go to 520
  <A Name=lu1gau_L_510>510</A>[<A Href=#C_1961>1</A>]    continue
         go to <A Href=#lu1gau_L_540>540</A>

<COMMENT>        We must move column j to the end of the column file.
        First, leave some spare room at the end of the
        current last column.
</COMMENT>
  <A Name=lu1gau_L_520>520</A>    <LOOP><A Name=C_1970>do</A></LOOP> <A Href=#lu1gau_L_522>522</A>  l  = lcol + 1, lcol + nspare
            lcol    = l
            indc(l) = 0     <COMMENT> Spare space is free.</COMMENT>
  <A Name=lu1gau_L_522>522</A>[<A Href=#C_1970>1</A>]    continue

         atend   = .true.
         jlast   = j
         l1      = lc1<DIV ALIGN=right><INFO>lusol.f-&gt;1978</INFO></DIV>
         lc1     = lcol + 1
         locc(j) = lc1

         <LOOP><A Name=C_1981>do</A></LOOP> <A Href=#lu1gau_L_525>525</A>  l     = l1, last
            lcol       = lcol + 1
            a(lcol)    = a(l)
            indc(lcol) = indc(l)
            indc(l)    = 0      <COMMENT> Free space.</COMMENT>
  <A Name=lu1gau_L_525>525</A>[<A Href=#C_1981>1</A>]    continue

<COMMENT><HR></HR>
        Inner loop for the fill-in in column j.
        This is usually not very expensive.
<HR></HR></COMMENT>
  <A Name=lu1gau_L_540>540</A>    last          = lc1 + lenj - 1
         ll            = 0

         <LOOP><A Name=C_1995>do</A></LOOP> <A Href=#lu1gau_L_560>560</A>   lc   = lpivc1, lpivc2
            ll         = ll + 1
            <TEST>if</TEST> (markl(ll)  .eq. j    ) go to 560
            aij        = al(ll) * uj<DIV ALIGN=right><INFO>lusol.f-&gt;1999</INFO></DIV>
            <TEST>if</TEST> (abs( aij ) .le. small) go to 560
            lenj       = lenj + 1
            last       = last + 1
            a(last)    = aij
            i          = indc(lc)
            indc(last) = i
            leni       = lenr(i)

<COMMENT>           Add 1 fill-in to row i if there is already room.
           27 Mar 2001: Be sure it's not at or past the end
                        of the row file.
</COMMENT>
            l          = locr(i) + leni
            <TEST>if</TEST> (     l  .ge. lrow) go to 550
            <TEST>if</TEST> (indr(l) .gt.    0) go to 550

            indr(l)    = j
            lenr(i)    = leni + 1
            go to <A Href=#lu1gau_L_560>560</A>

<COMMENT>           Row i does not have room for the fill-in.
           Increment ifill(ll) to count how often this has
           happened to row i.  Also, add m to the row index
           indc(last) in column j to mark it as a fill-in that is
           still pending.

           If this is the first pending fill-in for row i,
           nfill includes the current length of row i
           (since the whole row has to be moved later).

           If this is the first pending fill-in for column j,
           jfill(lu) records the current length of column j
           (to shorten the search for pending fill-ins later).
</COMMENT>
  <A Name=lu1gau_L_550>550</A>       <TEST>if</TEST> (ifill(ll) .eq. 0) nfill     = nfill + leni + nspare
            <TEST>if</TEST> (jfill(lu) .eq. 0) jfill(lu) = lenj
            nfill      = nfill     + 1
            ifill(ll)  = ifill(ll) + 1
            indc(last) = m + i
  <A Name=lu1gau_L_560>560</A>[<A Href=#C_1995>1</A>]    continue

         <TEST>if</TEST> ( atend ) lcol = last<DIV ALIGN=right><INFO>lusol.f-&gt;2041</INFO></DIV>

<COMMENT>        End loop for column  j.  Store its final length.
</COMMENT>
  <A Name=lu1gau_L_590>590</A>    lenc(j) = lenj
  <A Name=lu1gau_L_600>600</A>[<A Href=#C_1873>1</A>] continue

<COMMENT>     Successful completion.
</COMMENT>
      lfirst = 0
      return<DIV ALIGN=right><INFO>lusol.f-&gt;2051</INFO></DIV>

<COMMENT>     Interruption.  We have to come back in after the
     column file is compressed.  Give lfirst a new value.
     lu and nfill will retain their current values.
</COMMENT>
  <A Name=lu1gau_L_900>900</A> lfirst = lr
      return

      end subroutine <a href="lusol_f_c.html#R_lu1gau">lu1gau</a> <COMMENT> subroutine lu1gau

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1mar><A Name='R_lu1mar'><a target="index" href="lusol_f_i.html#R_lu1mar">lu1mar</a></A><ARGLIST>( m    , n     , lena  , maxmn,
     &                   TCP  , aijtol, Ltol  , maxcol, maxrow,
     &                   ibest, jbest , mbest ,
     &                   a    , indc  , indr  , ip   , iq,
     &                   lenc , lenr  , locc  , locr ,
     &                   iploc, iqloc )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>logical</DECLARE> <VARIABLE>TCP</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;2072</INFO></DIV>
      <DECLARE>double precision</DECLARE> <VARIABLE>Ltol      , a(lena)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m)   , iq(n)   ,</VARIABLE>
     &                   lenc(n)   , lenr(m)   , iploc(n), iqloc(m)
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n)   , locr(m)</VARIABLE>

<COMMENT><HR></HR>
     lu1mar  uses a Markowitz criterion to select a pivot element
     for the next stage of a sparse LU factorization,
     subject to a Threshold Partial Pivoting stability criterion (TPP)
     that bounds the elements of L.

     00 Jan 1986  Version documented in LUSOL paper:
                  Gill, Murray, Saunders and Wright (1987),
                  Maintaining LU factors of a general sparse matrix,
                  Linear algebra and its applications 88/89, 239-270.

     02 Feb 1989  Following Suhl and Aittoniemi (1987), the largest
                  element in each column is now kept at the start of
                  the column, i.e. in position locc(j) of a and indc.
                  This should speed up the Markowitz searches.

     26 Apr 1989  Both columns and rows searched during spars1 phase.
                  Only columns searched during spars2 phase.
                  maxtie replaced by maxcol and maxrow.
     05 Nov 1993  Initializing  "mbest = m * n"  wasn't big enough when
                  m = 10, n = 3, and last column had 7 nonzeros.
     09 Feb 1994  Realised that "mbest = maxmn * maxmn" might overflow.
                  Changed to    "mbest = maxmn * 1000".
     27 Apr 2000  On large example from Todd Munson,
                  that allowed  "if (mbest .le. nz1**2) go to 900"
                  to exit before any pivot had been found.
                  Introduced kbest = mbest / nz1.
                  Most pivots can be rejected with no integer multiply.
                  True merit is evaluated only if it's as good as the
                  best so far (or better).  There should be no danger
                  of integer overflow unless A is incredibly
                  large and dense.

     10 Sep 2000  TCP, aijtol added for Threshold Complete Pivoting.

     Systems Optimization Laboratory, Stanford University.
<HR></HR>
</COMMENT>
      <DECLARE>double precision</DECLARE> <VARIABLE>abest, lbest</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>zero,           one,          gamma</VARIABLE>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0,  one = 1.0d+0, gamma  = 2.0d+0 )

<COMMENT>     gamma  is "gamma" in the tie-breaking rule TB4 in the LUSOL paper.

<HR></HR>
     Search cols of length nz = 1, then rows of length nz = 1,
     then   cols of length nz = 2, then rows of length nz = 2, etc.
<HR></HR></COMMENT>
      abest  = zero
      lbest  = zero
      ibest  = 0
      kbest  = maxmn + 1
      mbest  = -1
      ncol   = 0
      nrow   = 0
      nz1    = 0<DIV ALIGN=right><INFO>lusol.f-&gt;2133</INFO></DIV>

      <LOOP><A Name=C_2134>do</A></LOOP> nz = 1, maxmn
<COMMENT>        nz1    = nz - 1
        if (mbest .le. nz1**2) go to 900</COMMENT>
         <TEST>if</TEST> (kbest .le. nz1   ) go to 900
         <TEST>if</TEST> (ibest .gt. 0) then
            <TEST>if</TEST> (ncol  .ge. maxcol) go to 200
         end if
         <TEST>if</TEST> (nz    .gt. m     ) go to 200

<COMMENT><HR></HR>
        Search the set of columns of length  nz.
<HR></HR></COMMENT>
         lq1    = <!new fthcall iqloc><A Name='C_2146'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iqloc">iqloc</a></FONT></A><BRANCHEMENT>( nz)</BRANCHEMENT>
         lq2    = n
         <TEST>if</TEST> (nz .lt. m) lq2 = iqloc(nz + 1) - 1

         <LOOP><A Name=C_2150>do</A></LOOP> <A Href=#lu1mar_L_180>180</A> lq = lq1, lq2
            ncol   = ncol + 1
            j      = iq(lq)
            lc1    = locc(j)<DIV ALIGN=right><INFO>lusol.f-&gt;2154</INFO></DIV>
            lc2    = lc1 + nz1
            amax   = abs( a(lc1) )

<COMMENT>           Test all aijs in this column.
           amax is the largest element (the first in the column).
           cmax is the largest multiplier if aij becomes pivot.
</COMMENT>
            <TEST>if</TEST> ( TCP ) then
               <TEST>if</TEST> (amax .lt. aijtol) go to 180 <COMMENT> Nothing in whole column</COMMENT>
            end if<DIV ALIGN=right><INFO>lusol.f-&gt;2164</INFO></DIV>

            <LOOP><A Name=C_2165>do</A></LOOP> <A Href=#lu1mar_L_160>160</A> lc = lc1, lc2
               i      = indc(lc)
               len1   = <!new fthcall lenr><A Name='C_2167'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_lenr">lenr</a></FONT></A><BRANCHEMENT>( i)</BRANCHEMENT> - 1
<COMMENT>              merit  = nz1 * len1
              if (merit .gt. mbest) go to 160</COMMENT>
               <TEST>if</TEST> (len1  .gt. kbest) go to 160

<COMMENT>              aij  has a promising merit.
              Apply the stability test.
              We require  aij  to be sufficiently large compared to
              all other nonzeros in column  j.  This is equivalent
              to requiring cmax to be bounded by Ltol.
</COMMENT>
               <TEST>if</TEST> (lc .eq. lc1) then

<COMMENT>                 This is the maximum element, amax.
                 Find the biggest element in the rest of the column
                 and hence get cmax.  We know cmax .le. 1, but
                 we still want it exactly in order to break ties.
                 27 Apr 2002: Settle for cmax = 1.
</COMMENT>
                  aij    = amax
                  cmax   = one

<COMMENT>                 cmax   = zero
                 do 140 l = lc1 + 1, lc2
                    cmax  = max( cmax, abs( a(l) ) )
  140            continue
                 cmax   = cmax / amax</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;2194</INFO></DIV>
               else

<COMMENT>                 aij is not the biggest element, so cmax .ge. 1.
                 Bail out if cmax will be too big.
</COMMENT>
                  aij    = abs( a(lc) )
                  <TEST>if</TEST> ( TCP ) then <COMMENT> Absolute test for Complete Pivoting</COMMENT>
                     <TEST>if</TEST> (aij         .lt.  aijtol) go to 160
                  else <COMMENT>!! TPP</COMMENT>
                     <TEST>if</TEST> (aij * Ltol  .lt.  amax  ) go to 160<DIV ALIGN=right><INFO>lusol.f-&gt;2204</INFO></DIV>
                  end if
                  cmax   = amax / aij
               end if

<COMMENT>              aij  is big enough.  Its maximum multiplier is cmax.
</COMMENT>
               merit  = nz1 * len1
               <TEST>if</TEST> (merit .eq. mbest) then

<COMMENT>                 Break ties.
                 (Initializing mbest &lt; 0 prevents getting here if
                 nothing has been found yet.)
                 In this version we minimize cmax
                 but if it is already small we maximize the pivot.
</COMMENT>
                  <TEST>if</TEST> (lbest .le. gamma  .and.  cmax .le. gamma) then
                     <TEST>if</TEST> (abest .ge. aij ) go to 160
                  else
                     <TEST>if</TEST> (lbest .le. cmax) go to 160
                  end if<DIV ALIGN=right><INFO>lusol.f-&gt;2224</INFO></DIV>
               end if

<COMMENT>              aij  is the best pivot so far.
</COMMENT>
               ibest  = i
               jbest  = j
               kbest  = len1
               mbest  = merit
               abest  = aij
               lbest  = cmax<DIV ALIGN=right><INFO>lusol.f-&gt;2234</INFO></DIV>
               <TEST>if</TEST> (nz .eq. 1) go to 900
  <A Name=lu1mar_L_160>160</A>[<A Href=#C_2165>1</A>]       continue

<COMMENT>           Finished with that column.
</COMMENT>
            <TEST>if</TEST> (ibest .gt. 0) then
               <TEST>if</TEST> (ncol .ge. maxcol) go to 200
            end if
  <A Name=lu1mar_L_180>180</A>[<A Href=#C_2150>1</A>]    continue

<COMMENT><HR></HR>
        Search the set of rows of length  nz.
<HR></HR>
 200    if (mbest .le. nz*nz1) go to 900</COMMENT>
  <A Name=lu1mar_L_200>200</A>    <TEST>if</TEST> (kbest .le. nz    ) go to 900
         <TEST>if</TEST> (ibest .gt. 0) then
            <TEST>if</TEST> (nrow  .ge. maxrow) go to 290
         end if
         <TEST>if</TEST> (nz    .gt. n     ) go to 290

         lp1    = <!new fthcall iploc><A Name='C_2254'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iploc">iploc</a></FONT></A><BRANCHEMENT>( nz)</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;2255</INFO></DIV>
         lp2    = m
         <TEST>if</TEST> (nz .lt. n) lp2 = iploc(nz + 1) - 1

         <LOOP><A Name=C_2258>do</A></LOOP> <A Href=#lu1mar_L_280>280</A> lp = lp1, lp2
            nrow   = nrow + 1
            i      = ip(lp)
            lr1    = locr(i)
            lr2    = lr1 + nz1

            <LOOP><A Name=C_2264>do</A></LOOP> <A Href=#lu1mar_L_260>260</A> lr = lr1, lr2<DIV ALIGN=right><INFO>lusol.f-&gt;2265</INFO></DIV>
               j      = indr(lr)
               len1   = <!new fthcall lenc><A Name='C_2266'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_lenc">lenc</a></FONT></A><BRANCHEMENT>( j)</BRANCHEMENT> - 1
<COMMENT>              merit  = nz1 * len1
              if (merit .gt. mbest) go to 260</COMMENT>
               <TEST>if</TEST> (len1  .gt. kbest) go to 260

<COMMENT>              aij  has a promising merit.
              Find where  aij  is in column  j.
</COMMENT>
               lc1    = locc(j)<DIV ALIGN=right><INFO>lusol.f-&gt;2275</INFO></DIV>
               lc2    = lc1 + len1
               amax   = abs( a(lc1) )
               <LOOP><A Name=C_2277>do</A></LOOP> <A Href=#lu1mar_L_220>220</A> lc = lc1, lc2
                  <TEST>if</TEST> (indc(lc) .eq. i) go to 230
  <A Name=lu1mar_L_220>220</A>[<A Href=#C_2277>1</A>]          continue

<COMMENT>              Apply the same stability test as above.
</COMMENT>
  <A Name=lu1mar_L_230>230</A>          aij    = abs( a(lc) )
               <TEST>if</TEST> ( TCP ) then   <COMMENT>!! Absolute test for Complete Pivoting</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;2285</INFO></DIV>
                  <TEST>if</TEST> (aij .lt. aijtol) go to 260
               end if

               <TEST>if</TEST> (lc .eq. lc1) then

<COMMENT>                 This is the maximum element, amax.
                 Find the biggest element in the rest of the column
                 and hence get cmax.  We know cmax .le. 1, but
                 we still want it exactly in order to break ties.
                 27 Apr 2002: Settle for cmax = 1.
</COMMENT>
                  cmax   = one

<COMMENT>                 cmax   = zero
                 do 240 l = lc1 + 1, lc2
                    cmax  = max( cmax, abs( a(l) ) )
 240             continue
                 cmax   = cmax / amax</COMMENT>
               else

<COMMENT>                 aij is not the biggest element, so cmax .ge. 1.
                 Bail out if cmax will be too big.
</COMMENT>
                  <TEST>if</TEST> ( TCP ) then
<COMMENT> relax</COMMENT>
                  else
                     <TEST>if</TEST> (aij * Ltol  .lt.  amax) go to 260
                  end if
                  cmax   = amax / aij
               end if

<COMMENT>              aij  is big enough.  Its maximum multiplier is cmax.
</COMMENT>
               merit  = nz1 * len1
               <TEST>if</TEST> (merit .eq. mbest) then

<COMMENT>                 Break ties as before.
                 (Initializing mbest &lt; 0 prevents getting here if
                 nothing has been found yet.)
</COMMENT>
                  <TEST>if</TEST> (lbest .le. gamma  .and.  cmax .le. gamma) then
                     <TEST>if</TEST> (abest .ge. aij ) go to 260<DIV ALIGN=right><INFO>lusol.f-&gt;2327</INFO></DIV>
                  else
                     <TEST>if</TEST> (lbest .le. cmax) go to 260
                  end if
               end if

<COMMENT>              aij  is the best pivot so far.
</COMMENT>
               ibest  = i
               jbest  = j
               kbest  = len1<DIV ALIGN=right><INFO>lusol.f-&gt;2337</INFO></DIV>
               mbest  = merit
               abest  = aij
               lbest  = cmax
               <TEST>if</TEST> (nz .eq. 1) go to 900
  <A Name=lu1mar_L_260>260</A>[<A Href=#C_2264>1</A>]       continue

<COMMENT>           Finished with that row.
</COMMENT>
            <TEST>if</TEST> (ibest .gt. 0) then
               <TEST>if</TEST> (nrow .ge. maxrow) go to 290<DIV ALIGN=right><INFO>lusol.f-&gt;2347</INFO></DIV>
            end if
  <A Name=lu1mar_L_280>280</A>[<A Href=#C_2258>1</A>]    continue

<COMMENT>        See if it's time to quit.
</COMMENT>
  <A Name=lu1mar_L_290>290</A>    <TEST>if</TEST> (ibest .gt. 0) then
            <TEST>if</TEST> (nrow .ge. maxrow  .and.  ncol .ge. maxcol) go to 900
         end if

<COMMENT>        Press on with next nz.
</COMMENT>
         nz1    = nz
         <TEST>if</TEST> (ibest .gt. 0) kbest  = mbest / nz1
      <A Href=#C_2134>end do</A>

  <A Name=lu1mar_L_900>900</A> return

      end subroutine <a href="lusol_f_c.html#R_lu1mar">lu1mar</a> <COMMENT> subroutine lu1mar

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1mRP><A Name='R_lu1mRP'><a target="index" href="lusol_f_i.html#R_lu1mRP">lu1mRP</a></A><ARGLIST>( m    , n     , lena  , maxmn,
     &                   Ltol , maxcol, maxrow,
     &                   ibest, jbest , mbest ,
     &                   a    , indc  , indr  , ip   , iq,
     &                   lenc , lenr  , locc  , locr ,
     &                   iploc, iqloc , Amaxr )</ARGLIST>

      implicit
     &     none<DIV ALIGN=right><INFO>lusol.f-&gt;2377</INFO></DIV>
      integer
     &     m, n, lena, maxmn, maxcol, maxrow, ibest, jbest, mbest
      double precision
     &     Ltol
      integer
     &     indc(lena), indr(lena), ip(m)   , iq(n)   ,
     &     lenc(n)   , lenr(m)   , iploc(n), iqloc(m),
     &     locc(n)   , locr(m)
      double precision
     &     a(lena)   , Amaxr(m)<DIV ALIGN=right><INFO>lusol.f-&gt;2387</INFO></DIV>

<COMMENT><HR></HR>
     lu1mRP  uses a Markowitz criterion to select a pivot element
     for the next stage of a sparse LU factorization,
     subject to a Threshold Rook Pivoting stability criterion (TRP)
     that bounds the elements of L and U.

     11 Jun 2002: First version of lu1mRP derived from lu1mar.
     11 Jun 2002: Current version of lu1mRP.
<HR></HR>
</COMMENT>
      integer
     &     i, j, kbest, lc, lc1, lc2, len1,
     &     lp, lp1, lp2, lq, lq1, lq2, lr, lr1, lr2,
     &     merit, ncol, nrow, nz, nz1
      double precision
     &     abest, aij, amax, atoli, atolj

      <DECLARE>double precision</DECLARE> <VARIABLE>zero</VARIABLE>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )<DIV ALIGN=right><INFO>lusol.f-&gt;2407</INFO></DIV>

<COMMENT><HR></HR>
     Search cols of length nz = 1, then rows of length nz = 1,
     then   cols of length nz = 2, then rows of length nz = 2, etc.
<HR></HR></COMMENT>
      abest  = zero
      ibest  = 0
      kbest  = maxmn + 1
      mbest  = -1
      ncol   = 0<DIV ALIGN=right><INFO>lusol.f-&gt;2417</INFO></DIV>
      nrow   = 0
      nz1    = 0

      <LOOP><A Name=C_2420>do</A></LOOP> nz = 1, maxmn
<COMMENT>        nz1    = nz - 1
        if (mbest .le. nz1**2) go to 900</COMMENT>
         <TEST>if</TEST> (kbest .le. nz1   ) go to 900
         <TEST>if</TEST> (ibest .gt. 0) then
            <TEST>if</TEST> (ncol  .ge. maxcol) go to 200
         end if<DIV ALIGN=right><INFO>lusol.f-&gt;2427</INFO></DIV>
         <TEST>if</TEST> (nz    .gt. m     ) go to 200

<COMMENT><HR></HR>
        Search the set of columns of length  nz.
<HR></HR></COMMENT>
         lq1    = <!new fthcall iqloc><A Name='C_2432'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iqloc">iqloc</a></FONT></A><BRANCHEMENT>( nz)</BRANCHEMENT>
         lq2    = n
         <TEST>if</TEST> (nz .lt. m) lq2 = iqloc(nz + 1) - 1

         <LOOP><A Name=C_2436>do</A></LOOP> <A Href=#lu1mRP_L_180>180</A> lq = lq1, lq2<DIV ALIGN=right><INFO>lusol.f-&gt;2437</INFO></DIV>
            ncol   = ncol + 1
            j      = <!new fthcall iq><A Name='C_2438'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iq">iq</a></FONT></A><BRANCHEMENT>( lq)</BRANCHEMENT>
            lc1    = <!new fthcall locc><A Name='C_2439'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_locc">locc</a></FONT></A><BRANCHEMENT>( j)</BRANCHEMENT>
            lc2    = lc1 + nz1
            amax   = abs( a(lc1) )
            atolj  = amax / Ltol    <COMMENT> Min size of pivots in col j

           Test all aijs in this column.
</COMMENT>
            <LOOP><A Name=C_2446>do</A></LOOP> <A Href=#lu1mRP_L_160>160</A> lc = lc1, lc2<DIV ALIGN=right><INFO>lusol.f-&gt;2447</INFO></DIV>
               i      = <!new fthcall indc><A Name='C_2447'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indc">indc</a></FONT></A><BRANCHEMENT>( lc)</BRANCHEMENT>
               len1   = <!new fthcall lenr><A Name='C_2448'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_lenr">lenr</a></FONT></A><BRANCHEMENT>( i)</BRANCHEMENT> - 1
<COMMENT>              merit  = nz1 * len1
              if (merit .gt. mbest) go to 160</COMMENT>
               <TEST>if</TEST> (len1  .gt. kbest) go to 160

<COMMENT>              aij  has a promising merit.
              Apply the Threshold Rook Pivoting stability test.
              First we require aij to be sufficiently large
              compared to other nonzeros in column j.
              Then  we require aij to be sufficiently large
              compared to other nonzeros in row    i.
</COMMENT>
               aij    = abs( a(lc) )
               <TEST>if</TEST> (aij         .lt.  atolj   ) go to 160
               <TEST>if</TEST> (aij * Ltol  .lt.  Amaxr(i)) go to 160

<COMMENT>              aij  is big enough.
</COMMENT>
               merit  = nz1 * len1<DIV ALIGN=right><INFO>lusol.f-&gt;2467</INFO></DIV>
               <TEST>if</TEST> (merit .eq. mbest) then

<COMMENT>                 Break ties.
                 (Initializing mbest &lt; 0 prevents getting here if
                 nothing has been found yet.)
</COMMENT>
                  <TEST>if</TEST> (abest .ge. aij) go to 160
               end if

<COMMENT>              aij  is the best pivot so far.
</COMMENT>
               ibest  = i
               jbest  = j
               kbest  = len1
               mbest  = merit
               abest  = aij
               <TEST>if</TEST> (nz .eq. 1) go to 900
  <A Name=lu1mRP_L_160>160</A>[<A Href=#C_2446>1</A>]       continue

<COMMENT>           Finished with that column.
</COMMENT>
            <TEST>if</TEST> (ibest .gt. 0) then
               <TEST>if</TEST> (ncol .ge. maxcol) go to 200
            end if
  <A Name=lu1mRP_L_180>180</A>[<A Href=#C_2436>1</A>]    continue

<COMMENT><HR></HR>
        Search the set of rows of length  nz.
<HR></HR>
 200    if (mbest .le. nz*nz1) go to 900</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;2497</INFO></DIV>
  <A Name=lu1mRP_L_200>200</A>    <TEST>if</TEST> (kbest .le. nz    ) go to 900
         <TEST>if</TEST> (ibest .gt. 0) then
            <TEST>if</TEST> (nrow  .ge. maxrow) go to 290
         end if
         <TEST>if</TEST> (nz    .gt. n     ) go to 290

         lp1    = <!new fthcall iploc><A Name='C_2503'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iploc">iploc</a></FONT></A><BRANCHEMENT>( nz)</BRANCHEMENT>
         lp2    = m
         <TEST>if</TEST> (nz .lt. n) lp2 = iploc(nz + 1) - 1

         <LOOP><A Name=C_2507>do</A></LOOP> <A Href=#lu1mRP_L_280>280</A> lp = lp1, lp2<DIV ALIGN=right><INFO>lusol.f-&gt;2508</INFO></DIV>
            nrow   = nrow + 1
            i      = <!new fthcall ip><A Name='C_2509'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ip">ip</a></FONT></A><BRANCHEMENT>( lp)</BRANCHEMENT>
            lr1    = <!new fthcall locr><A Name='C_2510'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_locr">locr</a></FONT></A><BRANCHEMENT>( i)</BRANCHEMENT>
            lr2    = lr1 + nz1
            atoli  = <!new fthcall Amaxr><A Name='C_2512'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_amaxr">Amaxr</a></FONT></A><BRANCHEMENT>( i)</BRANCHEMENT> / Ltol   <COMMENT> Min size of pivots in row i
</COMMENT>
            <LOOP><A Name=C_2514>do</A></LOOP> <A Href=#lu1mRP_L_260>260</A> lr = lr1, lr2
               j      = <!new fthcall indr><A Name='C_2515'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indr">indr</a></FONT></A><BRANCHEMENT>( lr)</BRANCHEMENT>
               len1   = <!new fthcall lenc><A Name='C_2516'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_lenc">lenc</a></FONT></A><BRANCHEMENT>( j)</BRANCHEMENT> - 1
<COMMENT>              merit  = nz1 * len1
              if (merit .gt. mbest) go to 260</COMMENT>
               <TEST>if</TEST> (len1  .gt. kbest) go to 260

<COMMENT>              aij  has a promising merit.
              Find where  aij  is in column j.
</COMMENT>
               lc1    = <!new fthcall locc><A Name='C_2524'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_locc">locc</a></FONT></A><BRANCHEMENT>( j)</BRANCHEMENT>
               lc2    = lc1 + len1
               amax   = abs( a(lc1) )
               <LOOP><A Name=C_2527>do</A></LOOP> lc = lc1, lc2<DIV ALIGN=right><INFO>lusol.f-&gt;2528</INFO></DIV>
                  <TEST>if</TEST> (indc(lc) .eq. i) go to 230
               <A Href=#C_2527>end do</A>

<COMMENT>              Apply the Threshold Rook Pivoting stability test.
              First we require aij to be sufficiently large
              compared to other nonzeros in row    i.
              Then  we require aij to be sufficiently large
              compared to other nonzeros in column j.
</COMMENT>
  <A Name=lu1mRP_L_230>230</A>          aij    = abs( a(lc) )<DIV ALIGN=right><INFO>lusol.f-&gt;2538</INFO></DIV>
               <TEST>if</TEST> (aij         .lt.  atoli) go to 260
               <TEST>if</TEST> (aij * Ltol  .lt.  amax ) go to 260

<COMMENT>              aij  is big enough.
</COMMENT>
               merit  = nz1 * len1
               <TEST>if</TEST> (merit .eq. mbest) then

<COMMENT>                 Break ties as before.
                 (Initializing mbest &lt; 0 prevents getting here if
                 nothing has been found yet.)
</COMMENT>
                  <TEST>if</TEST> (abest .ge. aij ) go to 260
               end if

<COMMENT>              aij  is the best pivot so far.
</COMMENT>
               ibest  = i
               jbest  = j
               kbest  = len1<DIV ALIGN=right><INFO>lusol.f-&gt;2558</INFO></DIV>
               mbest  = merit
               abest  = aij
               <TEST>if</TEST> (nz .eq. 1) go to 900
  <A Name=lu1mRP_L_260>260</A>[<A Href=#C_2514>1</A>]       continue

<COMMENT>           Finished with that row.
</COMMENT>
            <TEST>if</TEST> (ibest .gt. 0) then
               <TEST>if</TEST> (nrow .ge. maxrow) go to 290
            end if<DIV ALIGN=right><INFO>lusol.f-&gt;2568</INFO></DIV>
  <A Name=lu1mRP_L_280>280</A>[<A Href=#C_2507>1</A>]    continue

<COMMENT>        See if it's time to quit.
</COMMENT>
  <A Name=lu1mRP_L_290>290</A>    <TEST>if</TEST> (ibest .gt. 0) then
            <TEST>if</TEST> (nrow .ge. maxrow  .and.  ncol .ge. maxcol) go to 900
         end if

<COMMENT>        Press on with next nz.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;2578</INFO></DIV>
         nz1    = nz
         <TEST>if</TEST> (ibest .gt. 0) kbest  = mbest / nz1
      <A Href=#C_2420>end do</A>

  <A Name=lu1mRP_L_900>900</A> return

      end subroutine <a href="lusol_f_c.html#R_lu1mRP">lu1mRP</a> <COMMENT> subroutine lu1mRP

<HR></HR>
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;2588</INFO></DIV>
      subroutine <!new fthrout lu1mCP><A Name='R_lu1mCP'><a target="index" href="lusol_f_i.html#R_lu1mCP">lu1mCP</a></A><ARGLIST>( m     , n     , lena  , aijtol,
     &                   ibest , jbest , mbest ,
     &                   a     , indc  , indr  ,
     &                   lenc  , lenr  , locc  ,
     &                   Hlen  , Ha    , Hj    )</ARGLIST>

      <DECLARE>integer</DECLARE> <VARIABLE>m, n, lena, ibest, jbest, mbest, Hlen</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena),</VARIABLE>
     &                   lenc(n)   , lenr(m)   , locc(n), Hj(Hlen)
      <DECLARE>double precision</DECLARE> <VARIABLE>aijtol</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;2598</INFO></DIV>
      <DECLARE>double precision</DECLARE> <VARIABLE>a(lena)   , Ha(Hlen)</VARIABLE>

<COMMENT><HR></HR>
     lu1mCP  uses a Markowitz criterion to select a pivot element
     for the next stage of a sparse LU factorization,
     subject to a Threshold Complete Pivoting stability criterion (TCP)
     that bounds the elements of L and U.

     09 May 2002: First version of lu1mCP.
                  It searches columns only, using the heap that
                  holds the largest element in each column.
     09 May 2002: Current version of lu1mCP.
<HR></HR>
</COMMENT>
      integer
     &     j, kheap, lc, lc1, lc2, lenj, maxcol, ncol, nz1
      double precision
     &     abest, aij, amax, cmax, lbest

      <DECLARE>double precision</DECLARE> <VARIABLE>zero,           one,          gamma</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;2618</INFO></DIV>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0,  one = 1.0d+0, gamma  = 2.0d+0 )

<COMMENT>     gamma  is "gamma" in the tie-breaking rule TB4 in the LUSOL paper.

<HR></HR>
     Search up to maxcol columns stored at the top of the heap.
     The very top column helps initialize mbest.
<HR></HR></COMMENT>
      abest  = zero
      lbest  = zero<DIV ALIGN=right><INFO>lusol.f-&gt;2628</INFO></DIV>
      ibest  = 0
      jbest  = <!new fthcall Hj><A Name='C_2629'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_hj">Hj</a></FONT></A><BRANCHEMENT>( 1)</BRANCHEMENT>               <COMMENT> Column at the top of the heap</COMMENT>
      lenj   = <!new fthcall lenc><A Name='C_2630'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_lenc">lenc</a></FONT></A><BRANCHEMENT>( jbest)</BRANCHEMENT>
      mbest  = lenj * Hlen         <COMMENT> Bigger than any possible merit</COMMENT>
      maxcol = 40                  <COMMENT> ??? Big question</COMMENT>
      ncol   = 0                   <COMMENT> No. of columns searched
</COMMENT>
      <LOOP><A Name=C_2635>do</A></LOOP> <A Href=#lu1mCP_L_500>500</A> kheap = 1, Hlen

         amax   = Ha(kheap)<DIV ALIGN=right><INFO>lusol.f-&gt;2638</INFO></DIV>
         <TEST>if</TEST> (amax .lt. aijtol) go to 500

         ncol   = ncol + 1
         j      = <!new fthcall Hj><A Name='C_2641'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_hj">Hj</a></FONT></A><BRANCHEMENT>( kheap)</BRANCHEMENT>

<COMMENT><HR></HR>
        This column has at least one entry big enough (the top one).
        Search the column for other possibilities.
<HR></HR></COMMENT>
         lenj   = <!new fthcall lenc><A Name='C_2647'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_lenc">lenc</a></FONT></A><BRANCHEMENT>( j)</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;2648</INFO></DIV>
         nz1    = lenj - 1
         lc1    = <!new fthcall locc><A Name='C_2649'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_locc">locc</a></FONT></A><BRANCHEMENT>( j)</BRANCHEMENT>
         lc2    = lc1 + nz1
<COMMENT>--      amax   = abs( a(lc1) )

        Test all aijs in this column.
        amax is the largest element (the first in the column).
        cmax is the largest multiplier if aij becomes pivot.
</COMMENT>
         <LOOP><A Name=C_2657>do</A></LOOP> <A Href=#lu1mCP_L_160>160</A> lc = lc1, lc2<DIV ALIGN=right><INFO>lusol.f-&gt;2658</INFO></DIV>
            i      = indc(lc)
            len1   = <!new fthcall lenr><A Name='C_2659'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_lenr">lenr</a></FONT></A><BRANCHEMENT>( i)</BRANCHEMENT> - 1
            merit  = nz1 * len1
            <TEST>if</TEST> (merit .gt. mbest) go to 160

<COMMENT>           aij  has a promising merit.
</COMMENT>
            <TEST>if</TEST> (lc .eq. lc1) then

<COMMENT>              This is the maximum element, amax.
              Find the biggest element in the rest of the column
              and hence get cmax.  We know cmax .le. 1, but
              we still want it exactly in order to break ties.
              27 Apr 2002: Settle for cmax = 1.
</COMMENT>
               aij    = amax
               cmax   = one

<COMMENT>              cmax   = zero
              do 140 l = lc1 + 1, lc2
                 cmax  = max( cmax, abs( a(l) ) )
  140         continue
              cmax   = cmax / amax</COMMENT>
            else

<COMMENT>              aij is not the biggest element, so cmax .ge. 1.
              Bail out if cmax will be too big.
</COMMENT>
               aij    = abs( a(lc) )
               <TEST>if</TEST> (aij   .lt.  aijtol    ) go to 160<DIV ALIGN=right><INFO>lusol.f-&gt;2688</INFO></DIV>
               cmax   = amax / aij
            end if

<COMMENT>           aij  is big enough.  Its maximum multiplier is cmax.
</COMMENT>
            <TEST>if</TEST> (merit .eq. mbest) then

<COMMENT>              Break ties.
              (Initializing mbest "too big" prevents getting here if
              nothing has been found yet.)
              In this version we minimize cmax
              but if it is already small we maximize the pivot.
</COMMENT>
               <TEST>if</TEST> (lbest .le. gamma  .and.  cmax .le. gamma) then
                  <TEST>if</TEST> (abest .ge. aij ) go to 160
               else
                  <TEST>if</TEST> (lbest .le. cmax) go to 160
               end if
            end if

<COMMENT>           aij  is the best pivot so far.
</COMMENT>
            ibest  = i
            jbest  = j
            mbest  = merit
            abest  = aij
            lbest  = cmax
            <TEST>if</TEST> (merit .eq. 0) go to 900 <COMMENT> Col or row of length 1</COMMENT>
  <A Name=lu1mCP_L_160>160</A>[<A Href=#C_2657>1</A>]    continue

         <TEST>if</TEST> (ncol .ge. maxcol) go to 900<DIV ALIGN=right><INFO>lusol.f-&gt;2719</INFO></DIV>
  <A Name=lu1mCP_L_500>500</A>[<A Href=#C_2635>1</A>] continue

  <A Name=lu1mCP_L_900>900</A> return

      end subroutine <a href="lusol_f_c.html#R_lu1mCP">lu1mCP</a> <COMMENT> subroutine lu1mCP

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1mSP><A Name='R_lu1mSP'><a target="index" href="lusol_f_i.html#R_lu1mSP">lu1mSP</a></A><ARGLIST>( m    , n     , lena  , maxmn,
     &                   Ltol , maxcol,
     &                   ibest, jbest , mbest ,
     &                   a    , indc  , iq    , locc , iqloc )</ARGLIST>

      implicit
     &     none
      integer
     &     m, n, lena, maxmn, maxcol, ibest, jbest, mbest
      double precision
     &     Ltol
      integer<DIV ALIGN=right><INFO>lusol.f-&gt;2739</INFO></DIV>
     &     indc(lena), iq(n), iqloc(m), locc(n)
      double precision
     &     a(lena)

<COMMENT><HR></HR>
     lu1mSP  is intended for symmetric matrices that are either
     definite or quasi-definite.
     lu1mSP  uses a Markowitz criterion to select a pivot element for
     the next stage of a sparse LU factorization of a symmetric matrix,
     subject to a Threshold Symmetric Pivoting stability criterion
     (TSP) restricted to diagonal elements to preserve symmetry.
     This bounds the elements of L and U and should have rank-revealing
     properties analogous to Threshold Rook Pivoting for unsymmetric
     matrices.

     14 Dec 2002: First version of lu1mSP derived from lu1mRP.
                  There is no safeguard to ensure that A is symmetric.
     14 Dec 2002: Current version of lu1mSP.
<HR></HR>
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;2759</INFO></DIV>
      integer
     &     i, j, kbest, lc, lc1, lc2,
     &     lq, lq1, lq2, merit, ncol, nz, nz1
      double precision
     &     abest, aij, amax, atolj

      <DECLARE>double precision</DECLARE> <VARIABLE>zero</VARIABLE>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )

<COMMENT><HR></HR>
     Search cols of length nz = 1, then cols of length nz = 2, etc.
<HR></HR></COMMENT>
      abest  = zero
      ibest  = 0
      kbest  = maxmn + 1
      mbest  = -1
      ncol   = 0
      nz1    = 0

      <LOOP><A Name=C_2778>do</A></LOOP> nz = 1, maxmn<DIV ALIGN=right><INFO>lusol.f-&gt;2779</INFO></DIV>
<COMMENT>        nz1    = nz - 1
        if (mbest .le. nz1**2) go to 900</COMMENT>
         <TEST>if</TEST> (kbest .le. nz1   ) go to 900
         <TEST>if</TEST> (ibest .gt. 0) then
            <TEST>if</TEST> (ncol  .ge. maxcol) go to 200
         end if
         <TEST>if</TEST> (nz    .gt. m     ) go to 200

<COMMENT><HR></HR>
        Search the set of columns of length  nz.
<HR></HR></COMMENT>
         lq1    = <!new fthcall iqloc><A Name='C_2790'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iqloc">iqloc</a></FONT></A><BRANCHEMENT>( nz)</BRANCHEMENT>
         lq2    = n
         <TEST>if</TEST> (nz .lt. m) lq2 = iqloc(nz + 1) - 1

         <LOOP><A Name=C_2794>do</A></LOOP> <A Href=#lu1mSP_L_180>180</A> lq = lq1, lq2
            ncol   = ncol + 1
            j      = <!new fthcall iq><A Name='C_2796'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iq">iq</a></FONT></A><BRANCHEMENT>( lq)</BRANCHEMENT>
            lc1    = <!new fthcall locc><A Name='C_2797'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_locc">locc</a></FONT></A><BRANCHEMENT>( j)</BRANCHEMENT>
            lc2    = lc1 + nz1<DIV ALIGN=right><INFO>lusol.f-&gt;2799</INFO></DIV>
            amax   = abs( a(lc1) )
            atolj  = amax / Ltol    <COMMENT> Min size of pivots in col j

           Test all aijs in this column.
           Ignore everything except the diagonal.
</COMMENT>
            <LOOP><A Name=C_2805>do</A></LOOP> <A Href=#lu1mSP_L_160>160</A> lc = lc1, lc2
               i      = <!new fthcall indc><A Name='C_2806'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indc">indc</a></FONT></A><BRANCHEMENT>( lc)</BRANCHEMENT>
               <TEST>if</TEST> (i .ne. j) go to 160     <COMMENT> Skip off-diagonals.
              merit  = nz1 * nz1
              if (merit .gt. mbest) go to 160</COMMENT>
               <TEST>if</TEST> (nz1   .gt. kbest) go to 160

<COMMENT>              aij  has a promising merit.
              Apply the Threshold Partial Pivoting stability test
              (which is equivalent to Threshold Rook Pivoting for
              symmetric matrices).
              We require aij to be sufficiently large
              compared to other nonzeros in column j.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;2819</INFO></DIV>
               aij    = abs( a(lc) )
               <TEST>if</TEST> (aij .lt. atolj  ) go to 160

<COMMENT>              aij  is big enough.
</COMMENT>
               merit  = nz1 * nz1
               <TEST>if</TEST> (merit .eq. mbest) then

<COMMENT>                 Break ties.
                 (Initializing mbest &lt; 0 prevents getting here if
                 nothing has been found yet.)
</COMMENT>
                  <TEST>if</TEST> (abest .ge. aij) go to 160
               end if

<COMMENT>              aij  is the best pivot so far.
</COMMENT>
               ibest  = i
               jbest  = j
               kbest  = nz1<DIV ALIGN=right><INFO>lusol.f-&gt;2839</INFO></DIV>
               mbest  = merit
               abest  = aij
               <TEST>if</TEST> (nz .eq. 1) go to 900
  <A Name=lu1mSP_L_160>160</A>[<A Href=#C_2805>1</A>]       continue

<COMMENT>           Finished with that column.
</COMMENT>
            <TEST>if</TEST> (ibest .gt. 0) then
               <TEST>if</TEST> (ncol .ge. maxcol) go to 200
            end if<DIV ALIGN=right><INFO>lusol.f-&gt;2849</INFO></DIV>
  <A Name=lu1mSP_L_180>180</A>[<A Href=#C_2794>1</A>]    continue

<COMMENT>        See if it's time to quit.
</COMMENT>
  <A Name=lu1mSP_L_200>200</A>    <TEST>if</TEST> (ibest .gt. 0) then
            <TEST>if</TEST> (ncol .ge. maxcol) go to 900
         end if

<COMMENT>        Press on with next nz.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;2859</INFO></DIV>
         nz1    = nz
         <TEST>if</TEST> (ibest .gt. 0) kbest  = mbest / nz1
      <A Href=#C_2778>end do</A>

  <A Name=lu1mSP_L_900>900</A> return

      end subroutine <a href="lusol_f_c.html#R_lu1mSP">lu1mSP</a> <COMMENT> subroutine lu1mSP

<HR></HR>
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;2869</INFO></DIV>
      subroutine <!new fthrout lu1pen><A Name='R_lu1pen'><a target="index" href="lusol_f_i.html#R_lu1pen">lu1pen</a></A><ARGLIST>( m     , melim , ncold , nspare, ilast,
     &                   lpivc1, lpivc2, lpivr1, lpivr2, lrow ,
     &                   lenc  , lenr  , locc  , locr  ,
     &                   indc  , indr  , ifill , jfill )</ARGLIST>

      <DECLARE>integer</DECLARE> <VARIABLE>indc(*)     , indr(*)     , lenc(*), lenr(*),</VARIABLE>
     &                   ifill(melim), jfill(ncold)
      <DECLARE>integer</DECLARE> <VARIABLE>locc(*)     , locr(*)</VARIABLE>

<COMMENT><HR></HR>
     lu1pen deals with pending fill-in in the row file.
     ifill(ll) says if a row involved in the new column of L
               has to be updated.  If positive, it is the total
               length of the final updated row.
     jfill(lu) says if a column involved in the new row of U
               contains any pending fill-ins.  If positive, it points
               to the first fill-in in the column that has yet to be
               added to the row file.

     16 Apr 1989: First version of lu1pen.
     23 Mar 2001: ilast used and updated.
<HR></HR>
</COMMENT>
         ll     = 0

         <LOOP><A Name=C_2894>do</A></LOOP> <A Href=#lu1pen_L_650>650</A> lc  = lpivc1, lpivc2
            ll      = ll + 1
            <TEST>if</TEST> (ifill(ll) .eq. 0) go to 650

<COMMENT> Another row has pending fill.
 First, add some spare space at the end
 of the current last row.
</COMMENT>
            <LOOP><A Name=C_2902>do</A></LOOP> <A Href=#lu1pen_L_620>620</A>  l  = lrow + 1, lrow + nspare
               lrow    = l
               indr(l) = 0
  <A Name=lu1pen_L_620>620</A>[<A Href=#C_2902>1</A>]       continue

<COMMENT> Now move row i to the end of the row file.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;2909</INFO></DIV>
            i       = indc(lc)
            ilast   = i
            lr1     = locr(i)
            lr2     = lr1 + lenr(i) - 1
            locr(i) = lrow + 1

            <LOOP><A Name=C_2915>do</A></LOOP> <A Href=#lu1pen_L_630>630</A> lr = lr1, lr2
               lrow       = lrow + 1
               indr(lrow) = indr(lr)
               indr(lr)   = 0<DIV ALIGN=right><INFO>lusol.f-&gt;2919</INFO></DIV>
  <A Name=lu1pen_L_630>630</A>[<A Href=#C_2915>1</A>]       continue

            lrow    = lrow + ifill(ll)
  <A Name=lu1pen_L_650>650</A>[<A Href=#C_2894>1</A>]    continue

<COMMENT>        Scan all columns of  D  and insert the pending fill-in
        into the row file.
</COMMENT>
         lu     = 1

         <LOOP><A Name=C_2929>do</A></LOOP> <A Href=#lu1pen_L_680>680</A> lr = lpivr1, lpivr2<DIV ALIGN=right><INFO>lusol.f-&gt;2930</INFO></DIV>
            lu     = lu + 1
            <TEST>if</TEST> (jfill(lu) .eq. 0) go to 680
            j      = indr(lr)
            lc1    = locc(j) + jfill(lu) - 1
            lc2    = locc(j) + lenc(j)   - 1

            <LOOP><A Name=C_2936>do</A></LOOP> <A Href=#lu1pen_L_670>670</A> lc = lc1, lc2
               i      = indc(lc) - m
               <TEST>if</TEST> (i .gt. 0) then
                  indc(lc)   = i<DIV ALIGN=right><INFO>lusol.f-&gt;2940</INFO></DIV>
                  last       = locr(i) + lenr(i)
                  indr(last) = j
                  lenr(i)    = lenr(i) + 1
               end if
  <A Name=lu1pen_L_670>670</A>[<A Href=#C_2936>1</A>]       continue
  <A Name=lu1pen_L_680>680</A>[<A Href=#C_2929>1</A>]    continue

      end subroutine <a href="lusol_f_c.html#R_lu1pen">lu1pen</a> <COMMENT> subroutine lu1pen

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1mxc><A Name='R_lu1mxc'><a target="index" href="lusol_f_i.html#R_lu1mxc">lu1mxc</a></A><ARGLIST>( k1, k2, iq,
     &                   a, indc, lenc, locc )</ARGLIST>

<DECLARE>      implicit           none</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>k1, k2</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>iq(k2), indc(*), lenc(*), locc(*)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>a(*)</VARIABLE>

<COMMENT><HR></HR>
     lu1mxc  moves the largest element in each of columns iq(k1:k2)
     to the top of its column.
     If k1 &gt; k2, nothing happens.

     06 May 2002: (and earlier)
                  All columns k1:k2 must have one or more elements.
     07 May 2002: Allow for empty columns.  The heap routines need to
                  find 0.0 as the "largest element".
<HR></HR>
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;2970</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>i, j, k, l, lc, lc1, lc2, lenj</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>amax</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>zero</VARIABLE>
<DECLARE>      parameter         </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )

      <LOOP><A Name=C_2975>do</A></LOOP> k = k1, k2
         j      = iq(k)
         lc1    = locc(j)
         lenj   = lenc(j)

         <TEST>if</TEST> (lenj .eq. 0) then<DIV ALIGN=right><INFO>lusol.f-&gt;2981</INFO></DIV>
            a(lc1) = zero
         else

<COMMENT> The next 10 lines are equivalent to
 l      = idamax( lenc(j), a(lc1), 1 )  +  lc1 - 1
 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</COMMENT>
            lc2    = lc1 + lenc(j) - 1
            amax   = abs( a(lc1) )
            l      = lc1

            <LOOP><A Name=C_2991>do</A></LOOP> lc = lc1+1, lc2<DIV ALIGN=right><INFO>lusol.f-&gt;2992</INFO></DIV>
               <TEST>if</TEST> (amax .lt. abs( a(lc) )) then
                  amax   =  abs( a(lc) )
                  l      =  lc
               end if
            <A Href=#C_2991>end do</A>
<COMMENT> &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</COMMENT>
            <TEST>if</TEST> (l .gt. lc1) then
               amax      = a(l)
               a(l)      = a(lc1)<DIV ALIGN=right><INFO>lusol.f-&gt;3002</INFO></DIV>
               a(lc1)    = amax
               i         = indc(l)
               indc(l)   = indc(lc1)
               indc(lc1) = i
            end if
         end if
      <A Href=#C_2975>end do</A>

      end subroutine <a href="lusol_f_c.html#R_lu1mxc">lu1mxc</a> <COMMENT> subroutine lu1mxc

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1mxr><A Name='R_lu1mxr'><a target="index" href="lusol_f_i.html#R_lu1mxr">lu1mxr</a></A><ARGLIST>( k1, k2, ip, Amaxr,
     &                   a, indc, lenc, locc, indr, lenr, locr )</ARGLIST>

<DECLARE>      implicit           none</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>k1, k2</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>ip(k2),</VARIABLE>
     &                   indc(*), lenc(*), locc(*),
     &                   indr(*), lenr(*), locr(*)
      <DECLARE>double precision</DECLARE> <VARIABLE>a(*), Amaxr(*)</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;3023</INFO></DIV>

<COMMENT><HR></HR>
     lu1mxr  finds the largest element in each of row ip(k1:k2)
     and stores it in Amaxr(*).  The nonzeros are stored column-wise
     in (a,indc,lenc,locc) and their structure is row-wise
     in (  indr,lenr,locr).
     If k1 &gt; k2, nothing happens.

     11 Jun 2002: First version of lu1mxr.
                  Allow for empty columns.
     19 Dec 2004: Declare Amaxr(*) instead of Amaxr(k2)
                  to stop grumbles from the NAG compiler.
                  (Mentioned by Mick Pont.)
<HR></HR>
</COMMENT>
      <DECLARE>integer</DECLARE> <VARIABLE>i, j, k, lc, lc1, lc2, lr, lr1, lr2</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>amax</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>zero</VARIABLE>
<DECLARE>      parameter         </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )

      <LOOP><A Name=C_3043>do</A></LOOP> k = k1, k2<DIV ALIGN=right><INFO>lusol.f-&gt;3044</INFO></DIV>
         amax   = zero
         i      = ip(k)

<COMMENT> Find largest element in row i.
</COMMENT>
         lr1    = <!new fthcall locr><A Name='C_3049'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_locr">locr</a></FONT></A><BRANCHEMENT>( i)</BRANCHEMENT>
         lr2    = lr1 + lenr(i) - 1

         <LOOP><A Name=C_3052>do</A></LOOP> lr = lr1, lr2
            j      = <!new fthcall indr><A Name='C_3053'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indr">indr</a></FONT></A><BRANCHEMENT>( lr)</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;3054</INFO></DIV>

<COMMENT> Find where  aij  is in column  j.
</COMMENT>
            lc1    = <!new fthcall locc><A Name='C_3057'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_locc">locc</a></FONT></A><BRANCHEMENT>( j)</BRANCHEMENT>
            lc2    = lc1 + lenc(j) - 1
            <LOOP><A Name=C_3059>do</A></LOOP> lc = lc1, lc2
               <TEST>if</TEST> (indc(lc) .eq. i) go to 230
            <A Href=#C_3059>end do</A>

  <A Name=lu1mxr_L_230>230</A>       amax   = max( amax, abs( a(lc) ) )<DIV ALIGN=right><INFO>lusol.f-&gt;3064</INFO></DIV>
         <A Href=#C_3052>end do</A>

         Amaxr(i) = amax
      <A Href=#C_3043>end do</A>

      end subroutine <a href="lusol_f_c.html#R_lu1mxr">lu1mxr</a> <COMMENT> subroutine lu1mxr

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1or1><A Name='R_lu1or1'><a target="index" href="lusol_f_i.html#R_lu1or1">lu1or1</a></A><ARGLIST>( m, n, nelem, lena, small,
     &                   a, indc, indr, lenc, lenr,
     &                   Amax, numnz, lerr, inform )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>double precision</DECLARE> <VARIABLE>a(lena)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>lenc(n), lenr(m)</VARIABLE>

<COMMENT><HR></HR>
     lu1or1  organizes the elements of an  m by n  matrix  A  as
     follows.  On entry, the parallel arrays   a, indc, indr,
     contain  nelem  entries of the form     aij,    i,    j,
     in any order.  nelem  must be positive.

     Entries not larger than the input parameter  small  are treated as
     zero and removed from   a, indc, indr.  The remaining entries are
     defined to be nonzero.  numnz  returns the number of such nonzeros
     and  Amax  returns the magnitude of the largest nonzero.
     The arrays  lenc, lenr  return the number of nonzeros in each
     column and row of  A.

     inform = 0  on exit, except  inform = 1  if any of the indices in
     indc, indr  imply that the element  aij  lies outside the  m by n
     dimensions of  A.

     xx Feb 1985: Original version.
     17 Oct 2000: a, indc, indr now have size lena to allow nelem = 0.
<HR></HR></COMMENT>
      <LOOP><A Name=C_3102>do</A></LOOP> <A Href=#lu1or1_L_10>10</A> i = 1, m
         lenr(i) = 0<DIV ALIGN=right><INFO>lusol.f-&gt;3104</INFO></DIV>
   <A Name=lu1or1_L_10>10</A>[<A Href=#C_3102>1</A>] continue

      <LOOP><A Name=C_3106>do</A></LOOP> <A Href=#lu1or1_L_20>20</A> j = 1, n
         lenc(j) = 0
   <A Name=lu1or1_L_20>20</A>[<A Href=#C_3106>1</A>] continue

      Amax   = 0.0d+0
      numnz  = nelem
      l      = nelem + 1

      <LOOP><A Name=C_3114>do</A></LOOP> <A Href=#lu1or1_L_100>100</A> ldummy = 1, nelem<DIV ALIGN=right><INFO>lusol.f-&gt;3115</INFO></DIV>
         l      = l - 1
         <TEST>if</TEST> (abs( a(l) ) .gt. small) then
            i      = indc(l)
            j      = indr(l)
            Amax   = max( Amax, abs( a(l) ) )
            <TEST>if</TEST> (i .lt. 1  .or.  i .gt. m) go to 910
            <TEST>if</TEST> (j .lt. 1  .or.  j .gt. n) go to 910
            lenr(i) = lenr(i) + 1
            lenc(j) = lenc(j) + 1
         else<DIV ALIGN=right><INFO>lusol.f-&gt;3125</INFO></DIV>

<COMMENT>           Replace a negligible element by last element.  Since
           we are going backwards, we know the last element is ok.
</COMMENT>
            a(l)    = a(numnz)
            indc(l) = indc(numnz)
            indr(l) = indr(numnz)
            numnz   = numnz - 1
         end if
  <A Name=lu1or1_L_100>100</A>[<A Href=#C_3114>1</A>] continue<DIV ALIGN=right><INFO>lusol.f-&gt;3135</INFO></DIV>

      inform = 0
      return

  <A Name=lu1or1_L_910>910</A> lerr   = l
      inform = 1
      return

      end subroutine <a href="lusol_f_c.html#R_lu1or1">lu1or1</a> <COMMENT> subroutine lu1or1

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1or2><A Name='R_lu1or2'><a target="index" href="lusol_f_i.html#R_lu1or2">lu1or2</a></A><ARGLIST>( n, numa, lena, a, inum, jnum, len, loc )</ARGLIST>
      <DECLARE>integer</DECLARE> <VARIABLE>inum(lena), jnum(lena), len(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>loc(n)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>a(lena), ace, acep</VARIABLE>

<COMMENT><HR></HR>
     lu1or2  sorts a list of matrix elements  a(i,j)  into column
     order, given  numa  entries  a(i,j),  i,  j  in the parallel
     arrays  a, inum, jnum  respectively.  The matrix is assumed
     to have  n  columns and an arbitrary number of rows.

     On entry,  len(*)  must contain the length of each column.

     On exit,  a(*) and inum(*)  are sorted,  jnum(*) = 0,  and
     loc(j)  points to the start of column j.

     lu1or2  is derived from  mc20ad,  a routine in the Harwell
     Subroutine Library, author J. K. Reid.

     xx Feb 1985: Original version.
     17 Oct 2000: a, inum, jnum now have size lena to allow nelem = 0.
<HR></HR>

     Set  loc(j)  to point to the beginning of column  j.
</COMMENT>
      l = 1
      <LOOP><A Name=C_3173>do</A></LOOP> <A Href=#lu1or2_L_150>150</A> j  = 1, n
         loc(j) = l
         l      = l + len(j)
  <A Name=lu1or2_L_150>150</A>[<A Href=#C_3173>1</A>] continue<DIV ALIGN=right><INFO>lusol.f-&gt;3177</INFO></DIV>

<COMMENT>     Sort the elements into column order.
     The algorithm is an in-place sort and is of order  numa.
</COMMENT>
      <LOOP><A Name=C_3181>do</A></LOOP> <A Href=#lu1or2_L_230>230</A> i = 1, numa
<COMMENT>        Establish the current entry.</COMMENT>
         jce     = jnum(i)
         <TEST>if</TEST> (jce .eq. 0) go to 230
         ace     = a(i)
         ice     = inum(i)<DIV ALIGN=right><INFO>lusol.f-&gt;3187</INFO></DIV>
         jnum(i) = 0

<COMMENT>        Chain from current entry.
</COMMENT>
         <LOOP><A Name=C_3191>do</A></LOOP> <A Href=#lu1or2_L_200>200</A> j = 1, numa

<COMMENT>           The current entry is not in the correct position.
           Determine where to store it.
</COMMENT>
            l        = loc(jce)<DIV ALIGN=right><INFO>lusol.f-&gt;3197</INFO></DIV>
            loc(jce) = loc(jce) + 1

<COMMENT>           Save the contents of that location.
</COMMENT>
            acep = a(l)
            icep = inum(l)
            jcep = jnum(l)

<COMMENT>           Store current entry.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;3207</INFO></DIV>
            a(l)    = ace
            inum(l) = ice
            jnum(l) = 0

<COMMENT>           If next current entry needs to be processed,
           copy it into current entry.
</COMMENT>
            <TEST>if</TEST> (jcep .eq. 0) go to 230
            ace = acep
            ice = icep<DIV ALIGN=right><INFO>lusol.f-&gt;3217</INFO></DIV>
            jce = jcep
  <A Name=lu1or2_L_200>200</A>[<A Href=#C_3191>1</A>]    continue
  <A Name=lu1or2_L_230>230</A>[<A Href=#C_3181>1</A>] continue

<COMMENT>     Reset loc(j) to point to the start of column j.
</COMMENT>
      ja = 1
      <LOOP><A Name=C_3224>do</A></LOOP> <A Href=#lu1or2_L_250>250</A> j  = 1, n
         jb     = loc(j)
         loc(j) = ja<DIV ALIGN=right><INFO>lusol.f-&gt;3227</INFO></DIV>
         ja     = jb
  <A Name=lu1or2_L_250>250</A>[<A Href=#C_3224>1</A>] continue

      end subroutine <a href="lusol_f_c.html#R_lu1or2">lu1or2</a> <COMMENT> subroutine lu1or2

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1or3><A Name='R_lu1or3'><a target="index" href="lusol_f_i.html#R_lu1or3">lu1or3</a></A><ARGLIST>( m, n, lena,
     &                   indc, lenc, locc, iw,
     &                   lerr, inform )</ARGLIST><DIV ALIGN=right><INFO>lusol.f-&gt;3237</INFO></DIV>

      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), lenc(n), iw(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n)</VARIABLE>

<COMMENT><HR></HR>
     lu1or3  looks for duplicate elements in an  m by n  matrix  A
     defined by the column list  indc, lenc, locc.
     iw  is used as a work vector of length  m.

     xx Feb 1985: Original version.
     17 Oct 2000: indc, indr now have size lena to allow nelem = 0.
<HR></HR>
</COMMENT>
      <LOOP><A Name=C_3250>do</A></LOOP> <A Href=#lu1or3_L_100>100</A> i = 1, m
         iw(i) = 0
  <A Name=lu1or3_L_100>100</A>[<A Href=#C_3250>1</A>] continue

      <LOOP><A Name=C_3254>do</A></LOOP> <A Href=#lu1or3_L_200>200</A> j = 1, n
         <TEST>if</TEST> (lenc(j) .gt. 0) then
            l1    = locc(j)<DIV ALIGN=right><INFO>lusol.f-&gt;3257</INFO></DIV>
            l2    = l1 + lenc(j) - 1

            <LOOP><A Name=C_3259>do</A></LOOP> <A Href=#lu1or3_L_150>150</A> l = l1, l2
               i     = indc(l)
               <TEST>if</TEST> (iw(i) .eq. j) go to 910
               iw(i) = j
  <A Name=lu1or3_L_150>150</A>[<A Href=#C_3259>1</A>]       continue
         end if
  <A Name=lu1or3_L_200>200</A>[<A Href=#C_3254>1</A>] continue

      inform = 0<DIV ALIGN=right><INFO>lusol.f-&gt;3268</INFO></DIV>
      return

  <A Name=lu1or3_L_910>910</A> lerr   = l
      inform = 1
      return

      end subroutine <a href="lusol_f_c.html#R_lu1or3">lu1or3</a> <COMMENT> subroutine lu1or3

<HR></HR>
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;3278</INFO></DIV>
      subroutine <!new fthrout lu1or4><A Name='R_lu1or4'><a target="index" href="lusol_f_i.html#R_lu1or4">lu1or4</a></A><ARGLIST>( m, n, nelem, lena,
     &                   indc, indr, lenc, lenr, locc, locr )</ARGLIST>

      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), lenc(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

<COMMENT><HR></HR>
     lu1or4     constructs a row list  indr, locr
     from a corresponding column list  indc, locc,
     given the lengths of both columns and rows in  lenc, lenr.

     xx Feb 1985: Original version.
     17 Oct 2000: indc, indr now have size lena to allow nelem = 0.
<HR></HR>

     Initialize  locr(i)  to point just beyond where the
     last component of row  i  will be stored.
</COMMENT>
      l      = 1
      <LOOP><A Name=C_3297>do</A></LOOP> <A Href=#lu1or4_L_10>10</A> i = 1, m<DIV ALIGN=right><INFO>lusol.f-&gt;3298</INFO></DIV>
         l       = l + lenr(i)
         locr(i) = l
   <A Name=lu1or4_L_10>10</A>[<A Href=#C_3297>1</A>] continue

<COMMENT>     By processing the columns backwards and decreasing  locr(i)
     each time it is accessed, it will end up pointing to the
     beginning of row  i  as required.
</COMMENT>
      l2     = nelem
      j      = n + 1<DIV ALIGN=right><INFO>lusol.f-&gt;3308</INFO></DIV>

      <LOOP><A Name=C_3309>do</A></LOOP> <A Href=#lu1or4_L_40>40</A> jdummy = 1, n
         j  = j - 1
         <TEST>if</TEST> (lenc(j) .gt. 0) then
            l1 = locc(j)

            <LOOP><A Name=C_3314>do</A></LOOP> <A Href=#lu1or4_L_30>30</A> l = l1, l2
               i        = indc(l)
               lr       = locr(i) - 1
               locr(i)  = lr<DIV ALIGN=right><INFO>lusol.f-&gt;3318</INFO></DIV>
               indr(lr) = j
   <A Name=lu1or4_L_30>30</A>[<A Href=#C_3314>1</A>]       continue

            l2     = l1 - 1
         end if
   <A Name=lu1or4_L_40>40</A>[<A Href=#C_3309>1</A>] continue

      end subroutine <a href="lusol_f_c.html#R_lu1or4">lu1or4</a> <COMMENT> subroutine lu1or4

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1pq1><A Name='R_lu1pq1'><a target="index" href="lusol_f_i.html#R_lu1pq1">lu1pq1</a></A><ARGLIST>( m, n, len, iperm, loc, inv, num )</ARGLIST>

      <DECLARE>integer</DECLARE> <VARIABLE>len(m), iperm(m), loc(n), inv(m), num(n)</VARIABLE>

<COMMENT><HR></HR>
     lu1pq1  constructs a permutation  iperm  from the array  len.

     On entry:
     len(i)  holds the number of nonzeros in the i-th row (say)
             of an m by n matrix.
     num(*)  can be anything (workspace).

     On exit:
     iperm   contains a list of row numbers in the order
             rows of length 0,  rows of length 1,..., rows of length n.
     loc(nz) points to the first row containing  nz  nonzeros,
             nz = 1, n.
     inv(i)  points to the position of row i within iperm(*).
<HR></HR>

     Count the number of rows of each length.
</COMMENT>
      nzero  = 0
      <LOOP><A Name=C_3352>do</A></LOOP> <A Href=#lu1pq1_L_10>10</A>  nz  = 1, n
         num(nz) = 0
         loc(nz) = 0
   <A Name=lu1pq1_L_10>10</A>[<A Href=#C_3352>1</A>] continue

      <LOOP><A Name=C_3357>do</A></LOOP> <A Href=#lu1pq1_L_20>20</A>  i   = 1, m<DIV ALIGN=right><INFO>lusol.f-&gt;3358</INFO></DIV>
         nz      = len(i)
         <TEST>if</TEST> (nz .eq. 0) then
            nzero   = nzero   + 1
         else
            num(nz) = num(nz) + 1
         end if
   <A Name=lu1pq1_L_20>20</A>[<A Href=#C_3357>1</A>] continue

<COMMENT>     Set starting locations for each length.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;3368</INFO></DIV>
      l      = nzero + 1
      <LOOP><A Name=C_3369>do</A></LOOP> <A Href=#lu1pq1_L_60>60</A>  nz  = 1, n
         loc(nz) = l
         l       = l + num(nz)
         num(nz) = 0
   <A Name=lu1pq1_L_60>60</A>[<A Href=#C_3369>1</A>] continue

<COMMENT>     Form the list.
</COMMENT>
      nzero  = 0<DIV ALIGN=right><INFO>lusol.f-&gt;3378</INFO></DIV>
      <LOOP><A Name=C_3378>do</A></LOOP> <A Href=#lu1pq1_L_100>100</A>  i   = 1, m
         nz       = len(i)
         <TEST>if</TEST> (nz .eq. 0) then
            nzero    = nzero + 1
            iperm(nzero) = i
         else
            l        = loc(nz) + num(nz)
            iperm(l) = i
            num(nz)  = num(nz) + 1
         end if<DIV ALIGN=right><INFO>lusol.f-&gt;3388</INFO></DIV>
  <A Name=lu1pq1_L_100>100</A>[<A Href=#C_3378>1</A>] continue

<COMMENT>     Define the inverse of iperm.
</COMMENT>
      <LOOP><A Name=C_3392>do</A></LOOP> <A Href=#lu1pq1_L_120>120</A> l  = 1, m
         i      = iperm(l)
         inv(i) = l
  <A Name=lu1pq1_L_120>120</A>[<A Href=#C_3392>1</A>] continue

      end subroutine <a href="lusol_f_c.html#R_lu1pq1">lu1pq1</a> <COMMENT> subroutine lu1pq1

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1pq2><A Name='R_lu1pq2'><a target="index" href="lusol_f_i.html#R_lu1pq2">lu1pq2</a></A><ARGLIST>( nzpiv, nzchng,
     &                   indr , lenold, lennew, iqloc, iq, iqinv )</ARGLIST>

      <DECLARE>integer</DECLARE> <VARIABLE>indr(nzpiv), lenold(nzpiv), lennew(*),</VARIABLE>
     &                   iqloc(*)   , iq(*)        , iqinv(*)

<COMMENT><HR></HR>
     lu1pq2 frees the space occupied by the pivot row,
     and updates the column permutation iq.

     Also used to free the pivot column and update the row perm ip.

     nzpiv   (input)    is the length of the pivot row (or column).
     nzchng  (output)   is the net change in total nonzeros.

     14 Apr 1989  First version.
<HR></HR>
</COMMENT>
      nzchng = 0

      <LOOP><A Name=C_3421>do</A></LOOP> <A Href=#lu1pq2_L_200>200</A>  lr  = 1, nzpiv
         j        = indr(lr)
         indr(lr) = 0
         nz       = lenold(lr)
         nznew    = lennew(j)

         <TEST>if</TEST> (nz .ne. nznew) then<DIV ALIGN=right><INFO>lusol.f-&gt;3428</INFO></DIV>
            l        = <!new fthcall iqinv><A Name='C_3428'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iqinv">iqinv</a></FONT></A><BRANCHEMENT>( j)</BRANCHEMENT>
            nzchng   = nzchng + (nznew - nz)

<COMMENT>           l above is the position of column j in iq  (so j = iq(l)).
</COMMENT>
            <TEST>if</TEST> (nz .lt. nznew) then

<COMMENT>              Column  j  has to move towards the end of  iq.
</COMMENT>
  <A Name=lu1pq2_L_110>110</A>          next        = nz + 1<DIV ALIGN=right><INFO>lusol.f-&gt;3438</INFO></DIV>
               lnew        = <!new fthcall iqloc><A Name='C_3438'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iqloc">iqloc</a></FONT></A><BRANCHEMENT>( next)</BRANCHEMENT> - 1
               <TEST>if</TEST> (lnew .ne. l) then
                  jnew        = <!new fthcall iq><A Name='C_3440'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iq">iq</a></FONT></A><BRANCHEMENT>( lnew)</BRANCHEMENT>
                  iq(l)       = jnew
                  iqinv(jnew) = l
               end if
               l           = lnew
               iqloc(next) = lnew
               nz          = next
               <TEST>if</TEST> (nz .lt. nznew) go to 110<DIV ALIGN=right><INFO>lusol.f-&gt;3448</INFO></DIV>
            else

<COMMENT>              Column  j  has to move towards the front of  iq.
</COMMENT>
  <A Name=lu1pq2_L_120>120</A>          lnew        = <!new fthcall iqloc><A Name='C_3452'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iqloc">iqloc</a></FONT></A><BRANCHEMENT>( nz)</BRANCHEMENT>
               <TEST>if</TEST> (lnew .ne. l) then
                  jnew        = <!new fthcall iq><A Name='C_3454'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iq">iq</a></FONT></A><BRANCHEMENT>( lnew)</BRANCHEMENT>
                  iq(l)       = jnew
                  iqinv(jnew) = l
               end if<DIV ALIGN=right><INFO>lusol.f-&gt;3458</INFO></DIV>
               l           = lnew
               iqloc(nz)   = lnew + 1
               nz          = nz   - 1
               <TEST>if</TEST> (nz .gt. nznew) go to 120
            end if

            iq(lnew) = j
            iqinv(j) = lnew
         end if
  <A Name=lu1pq2_L_200>200</A>[<A Href=#C_3421>1</A>] continue<DIV ALIGN=right><INFO>lusol.f-&gt;3468</INFO></DIV>

      end subroutine <a href="lusol_f_c.html#R_lu1pq2">lu1pq2</a> <COMMENT> subroutine lu1pq2

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1pq3><A Name='R_lu1pq3'><a target="index" href="lusol_f_i.html#R_lu1pq3">lu1pq3</a></A><ARGLIST>( n, len, iperm, iw, nrank )</ARGLIST>

      <DECLARE>integer</DECLARE> <VARIABLE>len(n), iperm(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>iw(n)</VARIABLE>

<COMMENT><HR></HR>
     lu1pq3  looks at the permutation  iperm(*)  and moves any entries
     to the end whose corresponding length  len(*)  is zero.

     09 Feb 1994: Added work array iw(*) to improve efficiency.
<HR></HR>
</COMMENT>
      nrank  = 0
      nzero  = 0

      <LOOP><A Name=C_3488>do</A></LOOP> <A Href=#lu1pq3_L_10>10</A> k = 1, n<DIV ALIGN=right><INFO>lusol.f-&gt;3489</INFO></DIV>
         i    = iperm(k)

         <TEST>if</TEST> (len(i) .eq. 0) then
            nzero        = nzero + 1
            iw(nzero)    = i
         else
            nrank        = nrank + 1
            iperm(nrank) = i
         end if
   <A Name=lu1pq3_L_10>10</A>[<A Href=#C_3488>1</A>] continue<DIV ALIGN=right><INFO>lusol.f-&gt;3499</INFO></DIV>

      <LOOP><A Name=C_3500>do</A></LOOP> <A Href=#lu1pq3_L_20>20</A> k = 1, nzero
         iperm(nrank + k) = iw(k)
   <A Name=lu1pq3_L_20>20</A>[<A Href=#C_3500>1</A>] continue

      end subroutine <a href="lusol_f_c.html#R_lu1pq3">lu1pq3</a> <COMMENT> subroutine lu1pq3

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1rec><A Name='R_lu1rec'><a target="index" href="lusol_f_i.html#R_lu1rec">lu1rec</a></A><ARGLIST>( n, reals, luparm, ltop,
     &                   lena, a, ind, len, loc )</ARGLIST>

      <DECLARE>logical</DECLARE> <VARIABLE>reals</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30), ltop</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>a(lena)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>ind(lena), len(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>loc(n)</VARIABLE>

<COMMENT><HR></HR>
     00 Jun 1983: Original version of lu1rec followed John Reid's
                  compression routine in LA05.  It recovered
                  space in ind(*) and optionally a(*)
                  by eliminating entries with ind(l) = 0.
                  The elements of ind(*) could not be negative.
                  If len(i) was positive, entry i contained
                  that many elements, starting at  loc(i).
                  Otherwise, entry i was eliminated.

     23 Mar 2001: Realised we could have len(i) = 0 in rare cases!
                  (Mostly during TCP when the pivot row contains
                  a column of length 1 that couldn't be a pivot.)
                  Revised storage scheme to
                     keep        entries with       ind(l) &gt;  0,
                     squeeze out entries with -n &lt;= ind(l) &lt;= 0,
                  and to allow len(i) = 0.
                  Empty items are moved to the end of the compressed
                  ind(*) and/or a(*) arrays are given one empty space.
                  Items with len(i) &lt; 0 are still eliminated.

     27 Mar 2001: Decided to use only ind(l) &gt; 0 and = 0 in lu1fad.
                  Still have to keep entries with len(i) = 0.

     On exit:
     ltop         is the length of useful entries in ind(*), a(*).
     ind(ltop+1)  is "i" such that len(i), loc(i) belong to the last
                  item in ind(*), a(*).
<HR></HR>
</COMMENT>
      nempty = 0

      <LOOP><A Name=C_3549>do</A></LOOP> <A Href=#lu1rec_L_10>10</A> i = 1, n<DIV ALIGN=right><INFO>lusol.f-&gt;3550</INFO></DIV>
         leni = len(i)
         <TEST>if</TEST> (leni .gt. 0) then
            l      = loc(i) + leni - 1
            len(i) = ind(l)
            ind(l) = - (n + i)
         else if (leni .eq. 0) then
            nempty = nempty + 1
         end if
   <A Name=lu1rec_L_10>10</A>[<A Href=#C_3549>1</A>] continue

      k      = 0<DIV ALIGN=right><INFO>lusol.f-&gt;3561</INFO></DIV>
      klast  = 0    <COMMENT> Previous k</COMMENT>
      ilast  = 0    <COMMENT> Last entry moved.
</COMMENT>
      <LOOP><A Name=C_3564>do</A></LOOP> <A Href=#lu1rec_L_20>20</A> l = 1, ltop
         i    = ind(l)
         <TEST>if</TEST> (i .gt. 0) then
            k      = k + 1
            ind(k) = i
            <TEST>if</TEST> (reals) a(k) = a(l)

         else if (i .lt. -n) then<DIV ALIGN=right><INFO>lusol.f-&gt;3572</INFO></DIV>

<COMMENT>           This is the end of entry  i.
</COMMENT>
            i      = - (i + n)
            ilast  = i
            k      = k + 1
            ind(k) = len(i)
            <TEST>if</TEST> (reals) a(k) = a(l)
            loc(i) = klast + 1
            len(i) = k     - klast<DIV ALIGN=right><INFO>lusol.f-&gt;3582</INFO></DIV>
            klast  = k
         end if
   <A Name=lu1rec_L_20>20</A>[<A Href=#C_3564>1</A>] continue

<COMMENT>     Move any empty items to the end, adding 1 free entry for each.
</COMMENT>
      <TEST>if</TEST> (nempty .gt. 0) then
         <LOOP><A Name=C_3589>do</A></LOOP> i = 1, n
            <TEST>if</TEST> (len(i) .eq. 0) then
               k      = k + 1<DIV ALIGN=right><INFO>lusol.f-&gt;3592</INFO></DIV>
               loc(i) = k
               ind(k) = 0
               ilast  = i
            end if
         <A Href=#C_3589>end do</A>
      end if

      nout   = luparm(1)
      lprint = luparm(2)
      <TEST>if</TEST> (lprint .ge. 50) write(nout, 1000) ltop, k, reals, nempty<DIV ALIGN=right><INFO>lusol.f-&gt;3602</INFO></DIV>
      luparm(26) = luparm(26) + 1  <COMMENT> ncp

     Return ilast in ind(ltop + 1).
</COMMENT>
      ltop        = k
      ind(ltop+1) = ilast
      return

 <A Name=lu1rec_L_1000>1000</A> format(' lu1rec.  File compressed from', i10, '   to', i10, l3,
     &       '  nempty =', i8)<DIV ALIGN=right><INFO>lusol.f-&gt;3612</INFO></DIV>

      end subroutine <a href="lusol_f_c.html#R_lu1rec">lu1rec</a> <COMMENT> subroutine lu1rec

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1slk><A Name='R_lu1slk'><a target="index" href="lusol_f_i.html#R_lu1slk">lu1slk</a></A><ARGLIST>( m, n, lena, iq, iqloc, a, locc, w )</ARGLIST>

<DECLARE>      implicit           none</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>m, n, lena</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>iq(n), iqloc(m), locc(n)</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;3622</INFO></DIV>
      <DECLARE>double precision</DECLARE> <VARIABLE>a(lena), w(n)</VARIABLE>

<COMMENT><HR></HR>
     lu1slk  sets w(j) &gt; 0 if column j is a unit vector.

     21 Nov 2000: First version.  lu1fad needs it for TCP.
                  Note that w(*) is nominally an integer array,
                  but the only spare space is the double array w(*).
<HR></HR>
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;3632</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>j, lc1, lq, lq1, lq2</VARIABLE>

      <LOOP><A Name=C_3634>do</A></LOOP> j = 1, n
         w(j) = 0.0d+0
      <A Href=#C_3634>end do</A>

      lq1    = iqloc(1)
      lq2    = n
      <TEST>if</TEST> (m .gt. 1) lq2 = iqloc(2) - 1

      <LOOP><A Name=C_3642>do</A></LOOP> lq = lq1, lq2<DIV ALIGN=right><INFO>lusol.f-&gt;3643</INFO></DIV>
         j      = iq(lq)
         lc1    = locc(j)
         <TEST>if</TEST> (abs( a(lc1) ) .eq. 1.0d+0) then
            w(j) = 1.0d+0
         end if
      <A Href=#C_3642>end do</A>

      end subroutine <a href="lusol_f_c.html#R_lu1slk">lu1slk</a> <COMMENT> subroutine lu1slk

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1ful><A Name='R_lu1ful'><a target="index" href="lusol_f_i.html#R_lu1ful">lu1ful</a></A><ARGLIST>( m     , n    , lena , lenD , lu1 , TPP,
     &                   mleft , nleft, nrank, nrowu,
     &                   lenL  , lenU , nsing,
     &                   keepLU, small,
     &                   a     , d    , indc , indr , ip  , iq,
     &                   lenc  , lenr , locc , ipinv, ipvt )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>logical</DECLARE> <VARIABLE>TPP       , keepLU</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;3663</INFO></DIV>
      <DECLARE>double precision</DECLARE> <VARIABLE>a(lena)   , d(lenD)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m)   , iq(n),</VARIABLE>
     &                   lenc(n)   , lenr(m)   , ipinv(m)
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n)   , ipvt(m)</VARIABLE>

<COMMENT><HR></HR>
     lu1ful computes a dense (full) LU factorization of the
     mleft by nleft matrix that remains to be factored at the
     beginning of the nrowu-th pass through the main loop of lu1fad.

     02 May 1989: First version.
     05 Feb 1994: Column interchanges added to lu1DPP.
     08 Feb 1994: ipinv reconstructed, since lu1pq3 may alter ip.
<HR></HR>
</COMMENT>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )


<COMMENT><HR></HR>
     If lu1pq3 moved any empty rows, reset ipinv = inverse of ip.
<HR></HR></COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;3684</INFO></DIV>
      <TEST>if</TEST> (nrank .lt. m) then
         <LOOP><A Name=C_3685>do</A></LOOP> <A Href=#lu1ful_L_100>100</A> l    = 1, m
            i        = ip(l)
            ipinv(i) = l
  <A Name=lu1ful_L_100>100</A>[<A Href=#C_3685>1</A>]    continue
      end if

<COMMENT><HR></HR>
     Copy the remaining matrix into the dense matrix D.
<HR></HR>
     call dload ( lenD, zero, d, 1 )</COMMENT>
      <LOOP><A Name=C_3695>do</A></LOOP> j = 1, lenD
         d(j) = zero
      <A Href=#C_3695>end do</A>
      ipbase = nrowu - 1
      ldbase = 1 - nrowu

      <LOOP><A Name=C_3701>do</A></LOOP> <A Href=#lu1ful_L_200>200</A> lq = nrowu, n
         j      = iq(lq)
         lc1    = locc(j)<DIV ALIGN=right><INFO>lusol.f-&gt;3704</INFO></DIV>
         lc2    = lc1 + lenc(j) - 1

         <LOOP><A Name=C_3706>do</A></LOOP> <A Href=#lu1ful_L_150>150</A> lc = lc1, lc2
            i      = indc(lc)
            ld     = ldbase + ipinv(i)
            d(ld)  = a(lc)
  <A Name=lu1ful_L_150>150</A>[<A Href=#C_3706>1</A>]    continue

         ldbase = ldbase + mleft
  <A Name=lu1ful_L_200>200</A>[<A Href=#C_3701>1</A>] continue<DIV ALIGN=right><INFO>lusol.f-&gt;3714</INFO></DIV>

<COMMENT><HR></HR>
     Call our favorite dense LU factorizer.
<HR></HR></COMMENT>
      <TEST>if</TEST> ( TPP ) then
         call <!new fthcall lu1DPP><A Name='C_3719'><a href="lusol_f_c.html#R_lu1DPP">lu1DPP</a></A><BRANCHEMENT>( d, mleft, mleft, nleft, small, nsing,
     &                ipvt, iq(nrowu) )</BRANCHEMENT>
      else
         call <!new fthcall lu1DCP><A Name='C_3722'><a href="lusol_f_c.html#R_lu1DCP">lu1DCP</a></A><BRANCHEMENT>( d, mleft, mleft, nleft, small, nsing,
     &                ipvt, iq(nrowu) )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;3724</INFO></DIV>
      end if

<COMMENT><HR></HR>
     Move D to the beginning of A,
     and pack L and U at the top of a, indc, indr.
     In the process, apply the row permutation to ip.
     lkk points to the diagonal of U.
<HR></HR></COMMENT>
      call <!new fthcall dcopy><A Name='C_3732'><a href="lusol_f_c.html#R_dcopy">dcopy</a></A><BRANCHEMENT>( lenD, d, 1, a, 1 )</BRANCHEMENT>

      ldiagU = lena   - n<DIV ALIGN=right><INFO>lusol.f-&gt;3735</INFO></DIV>
      lkk    = 1
      lkn    = lenD  - mleft + 1
      lu     = lu1

      <LOOP><A Name=C_3739>do</A></LOOP> <A Href=#lu1ful_L_450>450</A>  k = 1, min( mleft, nleft )
         l1     = ipbase + k
         l2     = ipbase + ipvt(k)
         <TEST>if</TEST> (l1 .ne. l2) then
            i      = ip(l1)
            ip(l1) = ip(l2)<DIV ALIGN=right><INFO>lusol.f-&gt;3745</INFO></DIV>
            ip(l2) = i
         end if
         ibest  = ip( l1 )
         jbest  = iq( l1 )

         <TEST>if</TEST> ( keepLU ) then
<COMMENT><HR></HR>
           Pack the next column of L.
<HR></HR></COMMENT>
            la     = lkk<DIV ALIGN=right><INFO>lusol.f-&gt;3755</INFO></DIV>
            ll     = lu
            nrowd  = 1

            <LOOP><A Name=C_3758>do</A></LOOP> <A Href=#lu1ful_L_410>410</A>  i = k + 1, mleft
               la     = la + 1
               ai     = a(la)
               <TEST>if</TEST> (abs( ai ) .gt. small) then
                  nrowd    = nrowd + 1
                  ll       = ll    - 1
                  a(ll)    = ai<DIV ALIGN=right><INFO>lusol.f-&gt;3765</INFO></DIV>
                  indc(ll) = ip( ipbase + i )
                  indr(ll) = ibest
               end if
  <A Name=lu1ful_L_410>410</A>[<A Href=#C_3758>1</A>]       continue

<COMMENT><HR></HR>
           Pack the next row of U.
           We go backwards through the row of D
           so the diagonal ends up at the front of the row of  U.
           Beware -- the diagonal may be zero.
<HR></HR></COMMENT>
            la     = lkn + mleft
            lu     = ll
            ncold  = 0

            <LOOP><A Name=C_3780>do</A></LOOP> <A Href=#lu1ful_L_420>420</A>  j = nleft, k, -1
               la     = la - mleft
               aj     = a(la)
               <TEST>if</TEST> (abs( aj ) .gt. small  .or.  j .eq. k) then
                  ncold    = ncold + 1<DIV ALIGN=right><INFO>lusol.f-&gt;3785</INFO></DIV>
                  lu       = lu    - 1
                  a(lu)    = aj
                  indr(lu) = iq( ipbase + j )
               end if
  <A Name=lu1ful_L_420>420</A>[<A Href=#C_3780>1</A>]       continue

            lenr(ibest) = - ncold
            lenc(jbest) = - nrowd
            lenL        =   lenL + nrowd - 1
            lenU        =   lenU + ncold<DIV ALIGN=right><INFO>lusol.f-&gt;3795</INFO></DIV>
            lkn         =   lkn  + 1

         else
<COMMENT><HR></HR>
           Store just the diagonal of U, in natural order.
<HR></HR></COMMENT>
            a(ldiagU + jbest) = a(lkk)
         end if

         lkk    = lkk  + mleft + 1<DIV ALIGN=right><INFO>lusol.f-&gt;3805</INFO></DIV>
  <A Name=lu1ful_L_450>450</A>[<A Href=#C_3739>1</A>] continue

      end subroutine <a href="lusol_f_c.html#R_lu1ful">lu1ful</a> <COMMENT> subroutine lu1ful

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1DPP><A Name='R_lu1DPP'><a target="index" href="lusol_f_i.html#R_lu1DPP">lu1DPP</a></A><ARGLIST>( a, lda, m, n, small, nsing,
     &                   ipvt, iq )</ARGLIST>

<DECLARE>      implicit           none</DECLARE><DIV ALIGN=right><INFO>lusol.f-&gt;3815</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>lda, m, n, nsing</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>ipvt(m), iq(n)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>a(lda,n), small</VARIABLE>

<COMMENT><HR></HR>
     lu1DPP factors a dense m x n matrix A by Gaussian elimination,
     using row interchanges for stability, as in dgefa from LINPACK.
     This version also uses column interchanges if all elements in a
     pivot column are smaller than (or equal to) "small".  Such columns
     are changed to zero and permuted to the right-hand end.

     As in LINPACK, ipvt(*) keeps track of pivot rows.
     Rows of U are interchanged, but we don't have to physically
     permute rows of L.  In contrast, column interchanges are applied
     directly to the columns of both L and U, and to the column
     permutation vector iq(*).

     02 May 1989: First version derived from dgefa
                  in LINPACK (version dated 08/14/78).
     05 Feb 1994: Generalized to treat rectangular matrices
                  and use column interchanges when necessary.
                  ipvt is retained, but column permutations are applied
                  directly to iq(*).
     21 Dec 1994: Bug found via example from Steve Dirkse.
                  Loop 100 added to set ipvt(*) for singular rows.
     26 Mar 2006: nsing redefined (see below).
                  Changed to implicit none.
<HR></HR>

     On entry:

        a       Array holding the matrix A to be factored.

        lda     The leading dimension of the array  a.

        m       The number of rows    in  A.

        n       The number of columns in  A.

        small   A drop tolerance.  Must be zero or positive.

     On exit:

        a       An upper triangular matrix and the multipliers
                which were used to obtain it.
                The factorization can be written  A = L*U  where
                L  is a product of permutation and unit lower
                triangular matrices and  U  is upper triangular.

        nsing   Number of singularities detected.
                26 Mar 2006: nsing redefined to be more meaningful.
                Users may define rankU = n - nsing and regard
                U as upper-trapezoidal, with the first rankU columns
                being triangular and the rest trapezoidal.
                It would be better to return rankU, but we still
                return nsing for compatibility (even though lu1fad
                no longer uses it).

        ipvt    Records the pivot rows.

        iq      A vector to which column interchanges are applied.
<HR></HR>
</COMMENT>
      <DECLARE>double precision</DECLARE> <VARIABLE>t</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>idamax, i, j, k, kp1, l, last, lencol, rankU</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>zero         ,  one</VARIABLE>
<DECLARE>      parameter         </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0,  one = 1.0d+0 )


      rankU  = 0
      k      = 1<DIV ALIGN=right><INFO>lusol.f-&gt;3886</INFO></DIV>
      last   = n

<COMMENT><HR></HR>
     Start of elimination loop.
<HR></HR></COMMENT>
   <A Name=lu1DPP_L_10>10</A> kp1    = k + 1
      lencol = m - k + 1

<COMMENT> Find l, the pivot row.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;3896</INFO></DIV>
      l       = idamax( lencol, a(k,k), 1 ) + k - 1
      ipvt(k) = l

      <TEST>if</TEST> (abs( a(l,k) ) .le. small) then
<COMMENT><HR></HR>
 Do column interchange, changing old pivot column to zero.
 Reduce "last" and try again with same k.
<HR></HR></COMMENT>
         j        = iq(last)
         iq(last) = iq(k)<DIV ALIGN=right><INFO>lusol.f-&gt;3906</INFO></DIV>
         iq(k)    = j

         <LOOP><A Name=C_3908>do</A></LOOP> i = 1, k - 1
            t         = a(i,last)
            a(i,last) = a(i,k)
            a(i,k)    = t
         <A Href=#C_3908>end do</A>

         <LOOP><A Name=C_3914>do</A></LOOP> i = k, m
            t         = a(i,last)<DIV ALIGN=right><INFO>lusol.f-&gt;3916</INFO></DIV>
            a(i,last) = zero
            a(i,k)    = t
         <A Href=#C_3914>end do</A>

         last     = last - 1
         <TEST>if</TEST> (k .le. last) go to 10

      else
         rankU  = rankU + 1
         <TEST>if</TEST> (k .lt. m) then<DIV ALIGN=right><INFO>lusol.f-&gt;3926</INFO></DIV>
<COMMENT><HR></HR>
Do row interchange if necessary.
<HR></HR></COMMENT>
            <TEST>if</TEST> (l .ne. k) then
               t      = a(l,k)
               a(l,k) = a(k,k)
               a(k,k) = t
            end if

<COMMENT><HR></HR>
 Compute multipliers.
 Do row elimination with column indexing.
<HR></HR></COMMENT>
            t = - one / a(k,k)
            call <!new fthcall dscal><A Name='C_3940'><a href="lusol_f_c.html#R_dscal">dscal</a></A><BRANCHEMENT>( m-k, t, a(kp1,k), 1 )</BRANCHEMENT>

            <LOOP><A Name=C_3942>do</A></LOOP> j = kp1, last
               t    = a(l,j)
               <TEST>if</TEST> (l .ne. k) then
                  a(l,j) = a(k,j)<DIV ALIGN=right><INFO>lusol.f-&gt;3946</INFO></DIV>
                  a(k,j) = t
               end if
               call <!new fthcall daxpy><A Name='C_3948'><a href="lusol_f_c.html#R_daxpy">daxpy</a></A><BRANCHEMENT>( m-k, t, a(kp1,k), 1, a(kp1,j), 1 )</BRANCHEMENT>
            <A Href=#C_3942>end do</A>

            k = k + 1
            <TEST>if</TEST> (k .le. last) go to 10
         end if
      end if

<COMMENT> Set ipvt(*) for singular rows.
</COMMENT>
      <LOOP><A Name=C_3958>do</A></LOOP> <A Href=#lu1DPP_L_100>100</A> k = last + 1, m
         ipvt(k) = k
  <A Name=lu1DPP_L_100>100</A>[<A Href=#C_3958>1</A>] continue

      nsing  = n - rankU

      end subroutine <a href="lusol_f_c.html#R_lu1DPP">lu1DPP</a> <COMMENT> subroutine lu1DPP

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu1DCP><A Name='R_lu1DCP'><a target="index" href="lusol_f_i.html#R_lu1DCP">lu1DCP</a></A><ARGLIST>( a, lda, m, n, small, nsing,
     &                   ipvt, iq )</ARGLIST>

<DECLARE>      implicit           none</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>lda, m, n, nsing</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>ipvt(m), iq(n)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>a(lda,n), small</VARIABLE>

<COMMENT><HR></HR>
     lu1DCP factors a dense m x n matrix A by Gaussian elimination,
     using Complete Pivoting (row and column interchanges) for
     stability.
     This version also uses column interchanges if all elements in a
     pivot column are smaller than (or equal to) "small".  Such columns
     are changed to zero and permuted to the right-hand end.

     As in LINPACK's dgefa, ipvt(*) keeps track of pivot rows.
     Rows of U are interchanged, but we don't have to physically
     permute rows of L.  In contrast, column interchanges are applied
     directly to the columns of both L and U, and to the column
     permutation vector iq(*).

     01 May 2002: First dense Complete Pivoting, derived from lu1DPP.
     07 May 2002: Another break needed at end of first loop.
     26 Mar 2006: Cosmetic mods while looking for "nsing" bug when m&lt;n.
                  nsing redefined (see below).
                  Changed to implicit none.
<HR></HR>

     On entry:

        a       Array holding the matrix A to be factored.

        lda     The leading dimension of the array  a.

        m       The number of rows    in  A.

        n       The number of columns in  A.

        small   A drop tolerance.  Must be zero or positive.

     On exit:

        a       An upper triangular matrix and the multipliers
                which were used to obtain it.
                The factorization can be written  A = L*U  where
                L  is a product of permutation and unit lower
                triangular matrices and  U  is upper triangular.

        nsing   Number of singularities detected.
                26 Mar 2006: nsing redefined to be more meaningful.
                Users may define rankU = n - nsing and regard
                U as upper-trapezoidal, with the first rankU columns
                being triangular and the rest trapezoidal.
                It would be better to return rankU, but we still
                return nsing for compatibility (even though lu1fad
                no longer uses it).

        ipvt    Records the pivot rows.

        iq      A vector to which column interchanges are applied.
<HR></HR>
</COMMENT>
      <DECLARE>double precision</DECLARE> <VARIABLE>aijmax, ajmax, t</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>idamax, i, imax, j, jlast, jmax, jnew,</VARIABLE>
     &                    k, kp1, l, last, lencol, rankU
      <DECLARE>double precision</DECLARE> <VARIABLE>zero         ,  one</VARIABLE>
<DECLARE>      parameter         </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0,  one = 1.0d+0 )


      rankU  = 0<DIV ALIGN=right><INFO>lusol.f-&gt;4039</INFO></DIV>
      lencol = m + 1
      last   = n

<COMMENT><HR></HR>
 Start of elimination loop.
<HR></HR></COMMENT>
      <LOOP><A Name=C_4045>do</A></LOOP> k = 1, n
         kp1    = k + 1
         lencol = lencol - 1

<COMMENT> Find the biggest aij in row imax and column jmax.
</COMMENT>
         aijmax = zero
         imax   = k
         jmax   = k
         jlast  = last

         <LOOP><A Name=C_4056>do</A></LOOP> j = k, jlast
   <A Name=lu1DCP_L_10>10</A>       l      = idamax( lencol, a(k,j), 1 ) + k - 1
            ajmax  = abs( a(l,j) )

            <TEST>if</TEST> (ajmax .le. small) then<DIV ALIGN=right><INFO>lusol.f-&gt;4061</INFO></DIV>
<COMMENT><HR></HR>
 Do column interchange, changing old column to zero.
 Reduce  "last"  and try again with same j.
<HR></HR></COMMENT>
               jnew     = iq(last)
               iq(last) = iq(j)
               iq(j)    = jnew

               <LOOP><A Name=C_4069>do</A></LOOP> i = 1, k - 1
                  t         = a(i,last)<DIV ALIGN=right><INFO>lusol.f-&gt;4071</INFO></DIV>
                  a(i,last) = a(i,j)
                  a(i,j)    = t
               <A Href=#C_4069>end do</A>

               <LOOP><A Name=C_4075>do</A></LOOP> i = k, m
                  t         = a(i,last)
                  a(i,last) = zero
                  a(i,j)    = t
               <A Href=#C_4075>end do</A>

               last   = last - 1<DIV ALIGN=right><INFO>lusol.f-&gt;4082</INFO></DIV>
               <TEST>if</TEST> (j .le. last) go to 10 <COMMENT> repeat</COMMENT>
               go to <A Href=#lu1DCP_L_200>200</A>                 <COMMENT> break</COMMENT>
            end if

<COMMENT> Check if this column has biggest aij so far.
</COMMENT>
            <TEST>if</TEST> (aijmax .lt. ajmax) then
                aijmax  =   ajmax
                imax    =   l
                jmax    =   j<DIV ALIGN=right><INFO>lusol.f-&gt;4092</INFO></DIV>
            end if

            <TEST>if</TEST> (j .ge. last) go to 200   <COMMENT> break</COMMENT>
         <A Href=#C_4056>end do</A>

  <A Name=lu1DCP_L_200>200</A>    ipvt(k) = imax

         <TEST>if</TEST> (jmax .ne. k) then
<COMMENT><HR></HR>
 Do column interchange (k and jmax).
<HR></HR></COMMENT>
            jnew     = iq(jmax)
            iq(jmax) = iq(k)
            iq(k)    = jnew

            <LOOP><A Name=C_4107>do</A></LOOP> i = 1, m
               t         = a(i,jmax)
               a(i,jmax) = a(i,k)
               a(i,k)    = t
            <A Href=#C_4107>end do</A><DIV ALIGN=right><INFO>lusol.f-&gt;4112</INFO></DIV>
         end if

         <TEST>if</TEST> (k .lt. m) then
<COMMENT><HR></HR>
 Do row interchange if necessary.
<HR></HR></COMMENT>
            t         = a(imax,k)
            <TEST>if</TEST> (imax .ne. k) then
               a(imax,k) = a(k,k)
               a(k,k)    = t<DIV ALIGN=right><INFO>lusol.f-&gt;4122</INFO></DIV>
            end if

<COMMENT><HR></HR>
 Compute multipliers.
 Do row elimination with column indexing.
<HR></HR></COMMENT>
            t      = - one / t
            call <!new fthcall dscal><A Name='C_4129'><a href="lusol_f_c.html#R_dscal">dscal</a></A><BRANCHEMENT>( m-k, t, a(kp1,k), 1 )</BRANCHEMENT>

            <LOOP><A Name=C_4131>do</A></LOOP> j = kp1, last<DIV ALIGN=right><INFO>lusol.f-&gt;4132</INFO></DIV>
               t         = a(imax,j)
               <TEST>if</TEST> (imax .ne. k) then
                  a(imax,j) = a(k,j)
                  a(k,j)    = t
               end if
               call <!new fthcall daxpy><A Name='C_4137'><a href="lusol_f_c.html#R_daxpy">daxpy</a></A><BRANCHEMENT>( m-k, t, a(kp1,k), 1, a(kp1,j), 1 )</BRANCHEMENT>
            <A Href=#C_4131>end do</A>

         else
            go to <A Href=#lu1DCP_L_500>500</A>               <COMMENT> break</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4142</INFO></DIV>
         end if

         <TEST>if</TEST> (k .ge. last) go to 500 <COMMENT> break</COMMENT>
      <A Href=#C_4045>end do</A>

<COMMENT> Set ipvt(*) for singular rows.
</COMMENT>
  <A Name=lu1DCP_L_500>500</A> <LOOP><A Name=C_4149>do</A></LOOP> k = last + 1, m
         ipvt(k) = k
      <A Href=#C_4149>end do</A><DIV ALIGN=right><INFO>lusol.f-&gt;4152</INFO></DIV>

      nsing  = n - rankU

      end subroutine <a href="lusol_f_c.html#R_lu1DCP">lu1DCP</a> <COMMENT> subroutine lu1DCP</COMMENT>
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*
*     File  lusol2.f
*
*     Hbuild   Hchange  Hdelete  Hdown    Hinsert  Hup
*<DIV ALIGN=right><INFO>lusol.f-&gt;4162</INFO></DIV>
*     Heap-management routines for LUSOL's lu1fac.
*     May be useful for other applications.
*
* 11 Feb 2002: MATLAB version derived from "Algorithms" by R. Sedgewick.
* 03 Mar 2002: F77    version derived from MATLAB version.
* 07 May 2002: Safeguard input parameters k, N, Nk.
*              We don't want them to be output
* 19 Dec 2004: Hdelete: Nin is new input parameter for length of Hj, Ha.
* 19 Dec 2004: Current version of lusol2.f.
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<DIV ALIGN=right><INFO>lusol.f-&gt;4172</INFO></DIV>

<COMMENT>     For LUSOL, the heap structure involves three arrays of length N.
     N        is the current number of entries in the heap.
     Ha(1:N)  contains the values that the heap is partially sorting.
              For LUSOL they are double precision values -- the largest
              element in each remaining column of the updated matrix.
              The biggest entry is in Ha(1), the top of the heap.
     Hj(1:N)  contains column numbers j.
              Ha(k) is the biggest entry in column j = Hj(k).
     Hk(1:N)  contains indices within the heap.  It is the
              inverse of Hj(1:N), so  k = Hk(j)  &lt;=&gt;  j = Hj(k).
              Column j is entry k in the heap.
     hops     is the number of heap operations,
              i.e., the number of times an entry is moved
              (the number of "hops" up or down the heap).
     Together, Hj and Hk let us find values inside the heap
     whenever we want to change one of the values in Ha.
     For other applications, Ha may need to be some other data type,
     like the keys that sort routines operate on.</COMMENT>
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<DIV ALIGN=right><INFO>lusol.f-&gt;4192</INFO></DIV>

      subroutine <!new fthrout Hbuild><A Name='R_Hbuild'><a target="index" href="lusol_f_i.html#R_Hbuild">Hbuild</a></A><ARGLIST>( Ha, Hj, Hk, N, Nk, hops )</ARGLIST>

      implicit
     &     none
      integer
     &     N, Nk, hops, Hj(N), Hk(Nk)
      double precision
     &     Ha(N)

*     ==================================================================<DIV ALIGN=right><INFO>lusol.f-&gt;4203</INFO></DIV>
*     Hbuild initializes the heap by inserting each element of Ha.
*     Input:  Ha, Hj.
*     Output: Ha, Hj, Hk, hops.
*
*     01 May 2002: Use k for new length of heap, not k-1 for old length.
*     05 May 2002: Use kk in call <!new fthcall to><A Name='C_4208'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_to">to</a></FONT></A>stop loop variable k being altered.
*                  (Actually Hinsert no longer alters that parameter.)
*     07 May 2002: ftnchek wants us to protect Nk, Ha(k), Hj(k) too.
*     07 May 2002: Current version of Hbuild.
*     ==================================================================<DIV ALIGN=right><INFO>lusol.f-&gt;4213</INFO></DIV>

      integer
     &     h, jv, k, kk, Nkk
      double precision
     &     v

      Nkk  = Nk
      hops = 0
      <LOOP><A Name=C_4221>do</A></LOOP> k = 1, N
         kk    = k<DIV ALIGN=right><INFO>lusol.f-&gt;4223</INFO></DIV>
         v     = <!new fthcall Ha><A Name='C_4223'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ha">Ha</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
         jv    = <!new fthcall Hj><A Name='C_4224'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_hj">Hj</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
         call <!new fthcall Hinsert><A Name='C_4225'><a href="lusol_f_c.html#R_Hinsert">Hinsert</a></A><BRANCHEMENT>( Ha, Hj, Hk, kk, Nkk, v, jv, h )</BRANCHEMENT>
         hops  = hops + h
      <A Href=#C_4221>end do</A>

      end subroutine <a href="lusol_f_c.html#R_Hbuild">Hbuild</a> <COMMENT> subroutine Hbuild
</COMMENT>
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine <!new fthrout Hchange><A Name='R_Hchange'><a target="index" href="lusol_f_i.html#R_Hchange">Hchange</a></A><ARGLIST>( Ha, Hj, Hk, N, Nk, k, v, jv, hops )</ARGLIST><DIV ALIGN=right><INFO>lusol.f-&gt;4234</INFO></DIV>

      implicit
     &     none
      integer
     &     N, Nk, k, jv, hops, Hj(N), Hk(Nk)
      double precision
     &     v, Ha(N)

*     ==================================================================
*     Hchange changes Ha(k) to v in heap of length N.<DIV ALIGN=right><INFO>lusol.f-&gt;4244</INFO></DIV>
*
*     01 May 2002: Need Nk for length of Hk.
*     07 May 2002: Protect input parameters N, Nk, k.
*     07 May 2002: Current version of Hchange.
*     ==================================================================

      integer
     &     kx, Nx, Nkx
      double precision
     &     v1<DIV ALIGN=right><INFO>lusol.f-&gt;4254</INFO></DIV>

      Nx     = N
      Nkx    = Nk
      kx     = k
      v1     = <!new fthcall Ha><A Name='C_4258'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ha">Ha</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
      Ha(k)  = v
      Hj(k)  = jv
      Hk(jv) = k
      <TEST>if</TEST> (v1 .lt. v) then
         call <!new fthcall Hup><A Name='C_4263'><a href="lusol_f_c.html#R_Hup">Hup</a></A><BRANCHEMENT>( Ha, Hj, Hk, Nx, Nkx, kx, hops )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4264</INFO></DIV>
      else
         call <!new fthcall Hdown><A Name='C_4265'><a href="lusol_f_c.html#R_Hdown">Hdown</a></A><BRANCHEMENT>( Ha, Hj, Hk, Nx, Nkx, kx, hops )</BRANCHEMENT>
      end if

      end subroutine <a href="lusol_f_c.html#R_Hchange">Hchange</a> <COMMENT> subroutine Hchange
</COMMENT>
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine <!new fthrout Hdelete><A Name='R_Hdelete'><a target="index" href="lusol_f_i.html#R_Hdelete">Hdelete</a></A><ARGLIST>( Ha, Hj, Hk, Nin, N, Nk, k, hops )</ARGLIST>

      implicit<DIV ALIGN=right><INFO>lusol.f-&gt;4275</INFO></DIV>
     &     none
      integer
     &     N, Nin, Nk, k, hops, Hj(Nin), Hk(Nk)
      double precision
     &     Ha(Nin)

*     ==================================================================
*     Hdelete deletes Ha(k) from heap of length N.
*
*     03 Apr 2002: Current version of Hdelete.<DIV ALIGN=right><INFO>lusol.f-&gt;4285</INFO></DIV>
*     01 May 2002: Need Nk for length of Hk.
*     07 May 2002: Protect input parameters N, Nk, k.
*     19 Dec 2004: Nin is new input parameter for length of Hj, Ha.
*     19 Dec 2004: Current version of Hdelete.
*     ==================================================================

      integer
     &     jv, kx, Nkx, Nx
      double precision
     &     v<DIV ALIGN=right><INFO>lusol.f-&gt;4295</INFO></DIV>

      kx    = k
      Nkx   = Nk
      Nx    = N
      v     = <!new fthcall Ha><A Name='C_4299'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ha">Ha</a></FONT></A><BRANCHEMENT>( N)</BRANCHEMENT>
      jv    = <!new fthcall Hj><A Name='C_4300'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_hj">Hj</a></FONT></A><BRANCHEMENT>( N)</BRANCHEMENT>
      N     = N - 1
      hops  = 0
      <TEST>if</TEST> (k .le. N) then
         call <!new fthcall Hchange><A Name='C_4304'><a href="lusol_f_c.html#R_Hchange">Hchange</a></A><BRANCHEMENT>( Ha, Hj, Hk, Nx, Nkx, kx, v, jv, hops )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4305</INFO></DIV>
      end if

      end subroutine <a href="lusol_f_c.html#R_Hdelete">Hdelete</a> <COMMENT> subroutine Hdelete
</COMMENT>
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine <!new fthrout Hdown><A Name='R_Hdown'><a target="index" href="lusol_f_i.html#R_Hdown">Hdown</a></A><ARGLIST>( Ha, Hj, Hk, N, Nk, kk, hops )</ARGLIST>

      implicit
     &     none<DIV ALIGN=right><INFO>lusol.f-&gt;4315</INFO></DIV>
      integer
     &     N, Nk, kk, hops, Hj(N), Hk(Nk)
      double precision
     &     Ha(N)

*     ==================================================================
*     Hdown  updates heap by moving down tree from node k.
*
*     01 May 2002: Need Nk for length of Hk.
*     05 May 2002: Change input paramter k to kk to stop k being output.<DIV ALIGN=right><INFO>lusol.f-&gt;4325</INFO></DIV>
*     05 May 2002: Current version of Hdown.
*     ==================================================================

      integer
     &     j, jj, jv, k, N2
      double precision
     &     v

      k     = kk
      hops  = 0<DIV ALIGN=right><INFO>lusol.f-&gt;4335</INFO></DIV>
      v     = <!new fthcall Ha><A Name='C_4335'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ha">Ha</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
      jv    = <!new fthcall Hj><A Name='C_4336'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_hj">Hj</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
      N2    = N/2

<COMMENT>     while 1</COMMENT>
  <A Name=Hdown_L_100>100</A>    <TEST>if</TEST> (k .gt. N2   ) go to 200   <COMMENT> break</COMMENT>
         hops   = hops + 1
         j      = k+k
         <TEST>if</TEST> (j .lt. N) then
            <TEST>if</TEST> (Ha(j) .lt. Ha(j+1)) j = j+1<DIV ALIGN=right><INFO>lusol.f-&gt;4345</INFO></DIV>
         end if
         <TEST>if</TEST> (v .ge. Ha(j)) go to 200   <COMMENT> break</COMMENT>
         Ha(k)  = Ha(j)
         jj     = <!new fthcall Hj><A Name='C_4348'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_hj">Hj</a></FONT></A><BRANCHEMENT>( j)</BRANCHEMENT>
         Hj(k)  = jj
         Hk(jj) =  k
         k      =  j
         go to <A Href=#Hdown_L_100>100</A>
<COMMENT>     end while
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4355</INFO></DIV>
  <A Name=Hdown_L_200>200</A> Ha(k)  =  v
      Hj(k)  = jv
      Hk(jv) =  k

      end subroutine <a href="lusol_f_c.html#R_Hdown">Hdown</a> <COMMENT> subroutine Hdown
</COMMENT>
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine <!new fthrout Hinsert><A Name='R_Hinsert'><a target="index" href="lusol_f_i.html#R_Hinsert">Hinsert</a></A><ARGLIST>( Ha, Hj, Hk, N, Nk, v, jv, hops )</ARGLIST>

      implicit<DIV ALIGN=right><INFO>lusol.f-&gt;4366</INFO></DIV>
     &     none
      integer
     &     N, Nk, jv, hops, Hj(N), Hk(Nk)
      double precision
     &     v, Ha(N)

*     ==================================================================
*     Hinsert inserts (v,jv) into heap of length N-1
*     to make heap of length N.
*<DIV ALIGN=right><INFO>lusol.f-&gt;4376</INFO></DIV>
*     03 Apr 2002: First version of Hinsert.
*     01 May 2002: Require N to be final length, not old length.
*                  Need Nk for length of Hk.
*     07 May 2002: Protect input parameters N, Nk.
*     07 May 2002: Current version of Hinsert.
*     ==================================================================

      integer
     &     kk, Nkk, Nnew

      Nnew     = N<DIV ALIGN=right><INFO>lusol.f-&gt;4387</INFO></DIV>
      Nkk      = Nk
      kk       = Nnew
      Ha(Nnew) =  v
      Hj(Nnew) = jv
      Hk(jv)   = Nnew
      call <!new fthcall Hup><A Name='C_4392'><a href="lusol_f_c.html#R_Hup">Hup</a></A><BRANCHEMENT>( Ha, Hj, Hk, Nnew, Nkk, kk, hops )</BRANCHEMENT>

      end subroutine <a href="lusol_f_c.html#R_Hinsert">Hinsert</a> <COMMENT> subroutine Hinsert
</COMMENT>
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<DIV ALIGN=right><INFO>lusol.f-&gt;4397</INFO></DIV>

      subroutine <!new fthrout Hup><A Name='R_Hup'><a target="index" href="lusol_f_i.html#R_Hup">Hup</a></A><ARGLIST>( Ha, Hj, Hk, N, Nk, kk, hops )</ARGLIST>

      implicit
     &     none
      integer
     &     N, Nk, kk, hops, Hj(N), Hk(Nk)
      double precision
     &     Ha(N)

*     ==================================================================<DIV ALIGN=right><INFO>lusol.f-&gt;4408</INFO></DIV>
*     Hup updates heap by moving up tree from node k.
*
*     01 May 2002: Need Nk for length of Hk.
*     05 May 2002: Change input paramter k to kk to stop k being output.
*     05 May 2002: Current version of Hup.
*     ==================================================================

      integer
     &     j, jv, k, k2
      double precision<DIV ALIGN=right><INFO>lusol.f-&gt;4418</INFO></DIV>
     &     v

      k     = kk
      hops  = 0
      v     = <!new fthcall Ha><A Name='C_4422'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ha">Ha</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
      jv    = <!new fthcall Hj><A Name='C_4423'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_hj">Hj</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
<COMMENT>     while 1</COMMENT>
  <A Name=Hup_L_100>100</A>    <TEST>if</TEST> (k .lt.  2    ) go to 200   <COMMENT> break</COMMENT>
         k2    = k/2
         <TEST>if</TEST> (v .lt. Ha(k2)) go to 200   <COMMENT> break</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4428</INFO></DIV>
         hops  = hops + 1
         Ha(k) = Ha(k2)
         j     = <!new fthcall Hj><A Name='C_4430'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_hj">Hj</a></FONT></A><BRANCHEMENT>( k2)</BRANCHEMENT>
         Hj(k) =  j
         Hk(j) =  k
         k     = k2
         go to <A Href=#Hup_L_100>100</A>
<COMMENT>     end while
</COMMENT>
  <A Name=Hup_L_200>200</A> Ha(k)  =  v<DIV ALIGN=right><INFO>lusol.f-&gt;4438</INFO></DIV>
      Hj(k)  = jv
      Hk(jv) =  k

      end subroutine <a href="lusol_f_c.html#R_Hup">Hup</a> <COMMENT> subroutine Hup
<HR></HR>

     File  lusol6a.f

     lu6sol   lu6L     lu6Lt     lu6U     Lu6Ut   lu6LD
     lu6chk

 26 Apr 2002: lu6 routines put into a separate file.
 15 Dec 2002: lu6sol modularized via lu6L, lu6Lt, lu6U, lu6Ut.
              lu6LD implemented to allow solves with LDL' or L|D|L'.
 23 Apr 2004: lu6chk modified.  TRP can judge singularity better
              by comparing all diagonals to DUmax.
 27 Jun 2004: lu6chk.  Allow write only if nout .gt. 0 .
<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu6sol><A Name='R_lu6sol'><a target="index" href="lusol_f_i.html#R_lu6sol">lu6sol</a></A><ARGLIST>( mode, m, n, v, w,
     &                   lena, luparm, parmlu,
     &                   a, indc, indr, ip, iq,
     &                   lenc, lenr, locc, locr,
     &                   inform )</ARGLIST>

      implicit
     &     none
      integer
     &     luparm(30), mode, m, n, lena, inform,
     &     indc(lena), indr(lena), ip(m), iq(n),<DIV ALIGN=right><INFO>lusol.f-&gt;4468</INFO></DIV>
     &     lenc(n), lenr(m), locc(n), locr(m)
      double precision
     &     parmlu(30), a(lena), v(m), w(n)

<COMMENT><HR></HR>
     lu6sol  uses the factorization  A = L U  as follows:

     mode
      1    v  solves   L v = v(input).   w  is not touched.
      2    v  solves   L'v = v(input).   w  is not touched.
      3    w  solves   U w = v.          v  is not altered.
      4    v  solves   U'v = w.          w  is destroyed.
      5    w  solves   A w = v.          v  is altered as in 1.
      6    v  solves   A'v = w.          w  is destroyed.

     If mode = 3,4,5,6, v and w must not be the same arrays.

     If lu1fac has just been used to factorize a symmetric matrix A
     (which must be definite or quasi-definite), the factors A = L U
     may be regarded as A = LDL', where D = diag(U).  In such cases,

     mode
      7    v  solves   A v = L D L'v = v(input).   w  is not touched.
      8    v  solves       L |D| L'v = v(input).   w  is not touched.

     ip(*), iq(*)      hold row and column numbers in pivotal order.
     lenc(k)           is the length of the k-th column of initial L.
     lenr(i)           is the length of the i-th row of U.
     locc(*)           is not used.
     locr(i)           is the start  of the i-th row of U.

     U is assumed to be in upper-trapezoidal form (nrank by n).
     The first entry for each row is the diagonal element
     (according to the permutations  ip, iq).  It is stored at
     location locr(i) in a(*), indr(*).

     On exit, inform = 0 except as follows.
     If mode = 3,4,5,6 and if U (and hence A) is singular, then
     inform = 1 if there is a nonzero residual in solving the system
     involving U.  parmlu(20) returns the norm of the residual.

       July 1987: Early version.
     09 May 1988: f77 version.
     27 Apr 2000: Abolished the dreaded "computed go to".
                  But hard to change other "go to"s to "if then else".
     15 Dec 2002: lu6L, lu6Lt, lu6U, lu6Ut added to modularize lu6sol.
<HR></HR>
</COMMENT>
      <TEST>if</TEST>      (mode .eq. 1) then             <COMMENT> Solve  L v(new) = v.</COMMENT>
         call <!new fthcall lu6L><A Name='C_4517'><a href="lusol_f_c.html#R_lu6L">lu6L</a></A><BRANCHEMENT>(
     &        inform, m, n, v,
     &        lena, luparm, parmlu,
     &        a, indc, indr, lenc )</BRANCHEMENT>

      else if (mode .eq. 2) then             <COMMENT> Solve  L'v(new) = v.</COMMENT>
         call <!new fthcall lu6Lt><A Name='C_4523'><a href="lusol_f_c.html#R_lu6Lt">lu6Lt</a></A><BRANCHEMENT>(
     &        inform, m, n, v,
     &        lena, luparm, parmlu,
     &        a, indc, indr, lenc )</BRANCHEMENT>

      else if (mode .eq. 3) then             <COMMENT> Solve  U w = v.</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4529</INFO></DIV>
         call <!new fthcall lu6U><A Name='C_4529'><a href="lusol_f_c.html#R_lu6U">lu6U</a></A><BRANCHEMENT>(
     &        inform, m, n, v, w,
     &        lena, luparm, parmlu,
     &        a, indr, ip, iq, lenr, locr )</BRANCHEMENT>

      else if (mode .eq. 4) then             <COMMENT> Solve  U'v = w.</COMMENT>
         call <!new fthcall lu6Ut><A Name='C_4535'><a href="lusol_f_c.html#R_lu6Ut">lu6Ut</a></A><BRANCHEMENT>(
     &        inform, m, n, v, w,
     &        lena, luparm, parmlu,
     &        a, indr, ip, iq, lenr, locr )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4539</INFO></DIV>

      else if (mode .eq. 5) then             <COMMENT> Solve  A w      = v</COMMENT>
         call <!new fthcall lu6L><A Name='C_4541'><a href="lusol_f_c.html#R_lu6L">lu6L</a></A><BRANCHEMENT>(                        
     &        inform, m, n, v,
     &        lena, luparm, parmlu,
     &        a, indc, indr, lenc )</BRANCHEMENT><COMMENT> via    L v(new) = v</COMMENT>
         call <!new fthcall lu6U><A Name='C_4545'><a href="lusol_f_c.html#R_lu6U">lu6U</a></A><BRANCHEMENT>(                        
     &        inform, m, n, v, w,
     &        lena, luparm, parmlu,
     &        a, indr, ip, iq, lenr, locr )</BRANCHEMENT><COMMENT> and    U w = v(new).
</COMMENT>
      else if (mode .eq. 6) then             <COMMENT> Solve  A'v = w</COMMENT>
         call <!new fthcall lu6Ut><A Name='C_4551'><a href="lusol_f_c.html#R_lu6Ut">lu6Ut</a></A><BRANCHEMENT>(                        
     &        inform, m, n, v, w,
     &        lena, luparm, parmlu,
     &        a, indr, ip, iq, lenr, locr )</BRANCHEMENT><COMMENT> via    U'v = w</COMMENT>
         call <!new fthcall lu6Lt><A Name='C_4555'><a href="lusol_f_c.html#R_lu6Lt">lu6Lt</a></A><BRANCHEMENT>(                        
     &        inform, m, n, v,
     &        lena, luparm, parmlu,
     &        a, indc, indr, lenc )</BRANCHEMENT><COMMENT> and    L'v(new) = v.
</COMMENT>
      else if (mode .eq. 7) then
         call <!new fthcall lu6LD><A Name='C_4561'><a href="lusol_f_c.html#R_lu6LD">lu6LD</a></A><BRANCHEMENT>(                        
     &        inform, 1, m, n, v,
     &        lena, luparm, parmlu,
     &        a, indc, indr, lenc, locr )</BRANCHEMENT><COMMENT> Solve  LDv(bar) = v</COMMENT>
         call <!new fthcall lu6Lt><A Name='C_4565'><a href="lusol_f_c.html#R_lu6Lt">lu6Lt</a></A><BRANCHEMENT>(                        
     &        inform, m, n, v,
     &        lena, luparm, parmlu,
     &        a, indc, indr, lenc )</BRANCHEMENT><COMMENT> and    L'v(new) = v(bar).
</COMMENT>
      else if (mode .eq. 8) then
         call <!new fthcall lu6LD><A Name='C_4571'><a href="lusol_f_c.html#R_lu6LD">lu6LD</a></A><BRANCHEMENT>(                        
     &        inform, 2, m, n, v,
     &        lena, luparm, parmlu,
     &        a, indc, indr, lenc, locr )</BRANCHEMENT><COMMENT> Solve  L|D|v(bar) = v</COMMENT>
         call <!new fthcall lu6Lt><A Name='C_4575'><a href="lusol_f_c.html#R_lu6Lt">lu6Lt</a></A><BRANCHEMENT>(                        
     &        inform, m, n, v,
     &        lena, luparm, parmlu,
     &        a, indc, indr, lenc )</BRANCHEMENT><COMMENT> and    L'v(new) = v(bar).</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4579</INFO></DIV>
      end if

      end subroutine <a href="lusol_f_c.html#R_lu6sol">lu6sol</a> <COMMENT> subroutine lu6sol

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu6L><A Name='R_lu6L'><a target="index" href="lusol_f_i.html#R_lu6L">lu6L</a></A><ARGLIST>(
     &     inform, m, n, v,
     &     lena, luparm, parmlu,
     &     a, indc, indr, lenc )</ARGLIST><DIV ALIGN=right><INFO>lusol.f-&gt;4589</INFO></DIV>

      implicit
     &     none
      integer
     &     inform, m, n, lena, luparm(30),
     &     indc(lena), indr(lena), lenc(n)
      double precision
     &     parmlu(30), a(lena), v(m)

<COMMENT><HR></HR>
     lu6L   solves   L v = v(input).

     15 Dec 2002: First version derived from lu6sol.
     15 Dec 2002: Current version.
<HR></HR>
</COMMENT>
      integer
     &     i, ipiv, j, k, l, l1, ldummy, len, lenL, lenL0, numL, numL0
      double precision
     &     small, vpiv<DIV ALIGN=right><INFO>lusol.f-&gt;4609</INFO></DIV>

      numL0  = <!new fthcall luparm><A Name='C_4610'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 20)</BRANCHEMENT>
      lenL0  = <!new fthcall luparm><A Name='C_4611'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 21)</BRANCHEMENT>
      lenL   = <!new fthcall luparm><A Name='C_4612'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 23)</BRANCHEMENT>
      small  = <!new fthcall parmlu><A Name='C_4613'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_parmlu">parmlu</a></FONT></A><BRANCHEMENT>( 3)</BRANCHEMENT>
      inform = 0
      l1     = lena + 1

      <LOOP><A Name=C_4617>do</A></LOOP> k = 1, numL0
         len   = <!new fthcall lenc><A Name='C_4618'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_lenc">lenc</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4619</INFO></DIV>
         l     = l1
         l1    = l1 - len
         ipiv  = <!new fthcall indr><A Name='C_4621'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indr">indr</a></FONT></A><BRANCHEMENT>( l1)</BRANCHEMENT>
         vpiv  = <!new fthcall v><A Name='C_4622'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_v">v</a></FONT></A><BRANCHEMENT>( ipiv)</BRANCHEMENT>

         <TEST>if</TEST> (abs( vpiv ) .gt. small) then
<COMMENT>***** This loop could be coded specially.</COMMENT>
            <LOOP><A Name=C_4626>do</A></LOOP> ldummy = 1, len
               l    = l - 1
               j    = <!new fthcall indc><A Name='C_4628'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indc">indc</a></FONT></A><BRANCHEMENT>( l)</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4629</INFO></DIV>
               v(j) = v(j)  +  a(l) * vpiv
            <A Href=#C_4626>end do</A>
         end if
      <A Href=#C_4617>end do</A>

      l      = lena - lenL0 + 1
      numL   = lenL - lenL0

<COMMENT>***** This loop could be coded specially.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4639</INFO></DIV>
      <LOOP><A Name=C_4639>do</A></LOOP> ldummy = 1, numL
         l      = l - 1
         i      = <!new fthcall indr><A Name='C_4641'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indr">indr</a></FONT></A><BRANCHEMENT>( l)</BRANCHEMENT>
         <TEST>if</TEST> (abs( v(i) ) .gt. small) then
            j    = <!new fthcall indc><A Name='C_4643'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indc">indc</a></FONT></A><BRANCHEMENT>( l)</BRANCHEMENT>
            v(j) = v(j)  +  a(l) * v(i)
         end if
      <A Href=#C_4639>end do</A>

<COMMENT>     Exit.
</COMMENT>
      luparm(10) = inform

      end subroutine <a href="lusol_f_c.html#R_lu6L">lu6L</a> <COMMENT> subroutine lu6L

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu6Lt><A Name='R_lu6Lt'><a target="index" href="lusol_f_i.html#R_lu6Lt">lu6Lt</a></A><ARGLIST>(
     &     inform, m, n, v,
     &     lena, luparm, parmlu,
     &     a, indc, indr, lenc )</ARGLIST>

      implicit
     &     none
      integer
     &     inform, m, n, lena, luparm(30),
     &     indc(lena), indr(lena), lenc(n)
      double precision
     &     parmlu(30), a(lena), v(m)

<COMMENT><HR></HR>
     lu6Lt  solves   L'v = v(input).

     15 Dec 2002: First version derived from lu6sol.
     15 Dec 2002: Current version.
<HR></HR>
</COMMENT>
      integer
     &     i, ipiv, j, k, l, l1, l2, len, lenL, lenL0, numL0
      double precision
     &     small, sum<DIV ALIGN=right><INFO>lusol.f-&gt;4680</INFO></DIV>

<COMMENT><HR></HR></COMMENT>
      <DECLARE>double precision</DECLARE> <VARIABLE>zero</VARIABLE>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )
<COMMENT><HR></HR>
</COMMENT>
      numL0  = <!new fthcall luparm><A Name='C_4686'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 20)</BRANCHEMENT>
      lenL0  = <!new fthcall luparm><A Name='C_4687'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 21)</BRANCHEMENT>
      lenL   = <!new fthcall luparm><A Name='C_4688'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 23)</BRANCHEMENT>
      small  = <!new fthcall parmlu><A Name='C_4689'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_parmlu">parmlu</a></FONT></A><BRANCHEMENT>( 3)</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4690</INFO></DIV>
      inform = 0
      l1     = lena - lenL + 1
      l2     = lena - lenL0

<COMMENT>***** This loop could be coded specially.</COMMENT>
      <LOOP><A Name=C_4695>do</A></LOOP> l = l1, l2
         j     = <!new fthcall indc><A Name='C_4696'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indc">indc</a></FONT></A><BRANCHEMENT>( l)</BRANCHEMENT>
         <TEST>if</TEST> (abs( v(j) ) .gt. small) then
            i     = <!new fthcall indr><A Name='C_4698'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indr">indr</a></FONT></A><BRANCHEMENT>( l)</BRANCHEMENT>
            v(i)  = v(i)  +  a(l) * v(j)<DIV ALIGN=right><INFO>lusol.f-&gt;4700</INFO></DIV>
         end if
      <A Href=#C_4695>end do</A>

      <LOOP><A Name=C_4703>do</A></LOOP> k = numL0, 1, -1
         len   = <!new fthcall lenc><A Name='C_4704'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_lenc">lenc</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
         sum   = zero
         l1    = l2 + 1
         l2    = l2 + len

<COMMENT>***** This loop could be coded specially.</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4710</INFO></DIV>
         <LOOP><A Name=C_4710>do</A></LOOP> l = l1, l2
            j     = <!new fthcall indc><A Name='C_4711'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indc">indc</a></FONT></A><BRANCHEMENT>( l)</BRANCHEMENT>
            sum   = sum  +  a(l) * v(j)
         <A Href=#C_4710>end do</A>

         ipiv    = <!new fthcall indr><A Name='C_4715'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indr">indr</a></FONT></A><BRANCHEMENT>( l1)</BRANCHEMENT>
         v(ipiv) = v(ipiv) + sum
      <A Href=#C_4703>end do</A>

<COMMENT>     Exit.
</COMMENT>
      luparm(10) = inform

      end subroutine <a href="lusol_f_c.html#R_lu6Lt">lu6Lt</a> <COMMENT> subroutine lu6Lt

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu6U><A Name='R_lu6U'><a target="index" href="lusol_f_i.html#R_lu6U">lu6U</a></A><ARGLIST>(
     &     inform, m, n, v, w,
     &     lena, luparm, parmlu,
     &     a, indr, ip, iq, lenr, locr )</ARGLIST>

      implicit
     &     none
      integer
     &     inform, m, n, lena, luparm(30),
     &     indr(lena), ip(m), iq(n), lenr(m), locr(m)
      double precision
     &     parmlu(30), a(lena), v(m), w(n)

<COMMENT><HR></HR>
     lu6U   solves   U w = v.          v  is not altered.

     15 Dec 2002: First version derived from lu6sol.
     15 Dec 2002: Current version.
<HR></HR>
</COMMENT>
      integer
     &     i, j, k, klast, l, l1, l2, l3, nrank, nrank1
      double precision
     &     resid, small, t<DIV ALIGN=right><INFO>lusol.f-&gt;4751</INFO></DIV>

<COMMENT><HR></HR></COMMENT>
      <DECLARE>double precision</DECLARE> <VARIABLE>zero</VARIABLE>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )
<COMMENT><HR></HR>
</COMMENT>
      nrank  = <!new fthcall luparm><A Name='C_4757'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 16)</BRANCHEMENT>
      small  = <!new fthcall parmlu><A Name='C_4758'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_parmlu">parmlu</a></FONT></A><BRANCHEMENT>( 3)</BRANCHEMENT>
      inform = 0
      nrank1 = nrank + 1<DIV ALIGN=right><INFO>lusol.f-&gt;4761</INFO></DIV>
      resid  = zero

<COMMENT>     Find the first nonzero in v(1:nrank), counting backwards.
</COMMENT>
      <LOOP><A Name=C_4765>do</A></LOOP> klast = nrank, 1, -1
         i      = <!new fthcall ip><A Name='C_4766'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ip">ip</a></FONT></A><BRANCHEMENT>( klast)</BRANCHEMENT>
         <TEST>if</TEST> (abs( v(i) ) .gt. small) go to 320
      <A Href=#C_4765>end do</A>

  <A Name=lu6U_L_320>320</A> <LOOP><A Name=C_4770>do</A></LOOP> k = klast + 1, n<DIV ALIGN=right><INFO>lusol.f-&gt;4771</INFO></DIV>
         j     = <!new fthcall iq><A Name='C_4771'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iq">iq</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
         w(j)  = zero
      <A Href=#C_4770>end do</A>

<COMMENT>     Do the back-substitution, using rows 1:klast of U.
</COMMENT>
      <LOOP><A Name=C_4777>do</A></LOOP> k  = klast, 1, -1
         i      = <!new fthcall ip><A Name='C_4778'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ip">ip</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
         t      = <!new fthcall v><A Name='C_4779'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_v">v</a></FONT></A><BRANCHEMENT>( i)</BRANCHEMENT>
         l1     = <!new fthcall locr><A Name='C_4780'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_locr">locr</a></FONT></A><BRANCHEMENT>( i)</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4781</INFO></DIV>
         l2     = l1 + 1
         l3     = l1 + lenr(i) - 1

<COMMENT>***** This loop could be coded specially.</COMMENT>
         <LOOP><A Name=C_4785>do</A></LOOP> l = l2, l3
            j     = <!new fthcall indr><A Name='C_4786'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indr">indr</a></FONT></A><BRANCHEMENT>( l)</BRANCHEMENT>
            t     = t  -  a(l) * w(j)
         <A Href=#C_4785>end do</A>

         j      = <!new fthcall iq><A Name='C_4790'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iq">iq</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4791</INFO></DIV>
         <TEST>if</TEST> (abs( t ) .le. small) then
            w(j)  = zero
         else
            w(j)  = t / a(l1)
         end if
      <A Href=#C_4777>end do</A>

<COMMENT>     Compute residual for overdetermined systems.
</COMMENT>
      <LOOP><A Name=C_4800>do</A></LOOP> k = nrank1, m<DIV ALIGN=right><INFO>lusol.f-&gt;4801</INFO></DIV>
         i     = <!new fthcall ip><A Name='C_4801'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ip">ip</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
         resid = resid  +  abs( v(i) )
      <A Href=#C_4800>end do</A>

<COMMENT>     Exit.
</COMMENT>
      <TEST>if</TEST> (resid .gt. zero) inform = 1
      luparm(10) = inform
      parmlu(20) = resid

      end subroutine <a href="lusol_f_c.html#R_lu6U">lu6U</a> <COMMENT> subroutine lu6U

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu6Ut><A Name='R_lu6Ut'><a target="index" href="lusol_f_i.html#R_lu6Ut">lu6Ut</a></A><ARGLIST>(
     &     inform, m, n, v, w,
     &     lena, luparm, parmlu,
     &     a, indr, ip, iq, lenr, locr )</ARGLIST>

      implicit
     &     none<DIV ALIGN=right><INFO>lusol.f-&gt;4822</INFO></DIV>
      integer
     &     inform, m, n, lena, luparm(30),
     &     indr(lena), ip(m), iq(n), lenr(m), locr(m)
      double precision
     &     parmlu(30), a(lena), v(m), w(n)

<COMMENT><HR></HR>
     lu6Ut  solves   U'v = w.          w  is destroyed.

     15 Dec 2002: First version derived from lu6sol.
     15 Dec 2002: Current version.
<HR></HR>
</COMMENT>
      integer
     &     i, j, k, l, l1, l2, nrank, nrank1
      double precision
     &     resid, small, t

<COMMENT><HR></HR></COMMENT>
      <DECLARE>double precision</DECLARE> <VARIABLE>zero</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;4842</INFO></DIV>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )
<COMMENT><HR></HR>
</COMMENT>
      nrank  = <!new fthcall luparm><A Name='C_4845'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 16)</BRANCHEMENT>
      small  = <!new fthcall parmlu><A Name='C_4846'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_parmlu">parmlu</a></FONT></A><BRANCHEMENT>( 3)</BRANCHEMENT>
      inform = 0
      nrank1 = nrank + 1
      resid  = zero

      <LOOP><A Name=C_4851>do</A></LOOP> k = nrank1, m<DIV ALIGN=right><INFO>lusol.f-&gt;4852</INFO></DIV>
         i     = <!new fthcall ip><A Name='C_4852'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ip">ip</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
         v(i)  = zero
      <A Href=#C_4851>end do</A>

<COMMENT>     Do the forward-substitution, skipping columns of U(transpose)
     when the associated element of w(*) is negligible.
</COMMENT>
      <LOOP><A Name=C_4859>do</A></LOOP> <A Href=#lu6Ut_L_480>480</A> k = 1, nrank
         i      = <!new fthcall ip><A Name='C_4860'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ip">ip</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
         j      = <!new fthcall iq><A Name='C_4861'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iq">iq</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4862</INFO></DIV>
         t      = <!new fthcall w><A Name='C_4862'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_w">w</a></FONT></A><BRANCHEMENT>( j)</BRANCHEMENT>
         <TEST>if</TEST> (abs( t ) .le. small) then
            v(i) = zero
            go to <A Href=#lu6Ut_L_480>480</A>
         end if

         l1     = <!new fthcall locr><A Name='C_4868'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_locr">locr</a></FONT></A><BRANCHEMENT>( i)</BRANCHEMENT>
         t      = t / a(l1)
         v(i)   = t
         l2     = l1 + lenr(i) - 1<DIV ALIGN=right><INFO>lusol.f-&gt;4872</INFO></DIV>
         l1     = l1 + 1

<COMMENT>***** This loop could be coded specially.</COMMENT>
         <LOOP><A Name=C_4875>do</A></LOOP> l = l1, l2
            j     = <!new fthcall indr><A Name='C_4876'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indr">indr</a></FONT></A><BRANCHEMENT>( l)</BRANCHEMENT>
            w(j)  = w(j)  -  t * a(l)
         <A Href=#C_4875>end do</A>
  <A Name=lu6Ut_L_480>480</A>[<A Href=#C_4859>1</A>] continue

<COMMENT>     Compute residual for overdetermined systems.
</COMMENT>
      <LOOP><A Name=C_4883>do</A></LOOP> k = nrank1, n
         j     = <!new fthcall iq><A Name='C_4884'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iq">iq</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
         resid = resid  +  abs( w(j) )
      <A Href=#C_4883>end do</A>

<COMMENT>     Exit.
</COMMENT>
      <TEST>if</TEST> (resid .gt. zero) inform = 1
      luparm(10) = inform<DIV ALIGN=right><INFO>lusol.f-&gt;4892</INFO></DIV>
      parmlu(20) = resid

      end subroutine <a href="lusol_f_c.html#R_lu6Ut">lu6Ut</a> <COMMENT> subroutine lu6Ut

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu6LD><A Name='R_lu6LD'><a target="index" href="lusol_f_i.html#R_lu6LD">lu6LD</a></A><ARGLIST>(
     &     inform, mode, m, n, v,
     &     lena, luparm, parmlu,
     &     a, indc, indr, lenc, locr )</ARGLIST><DIV ALIGN=right><INFO>lusol.f-&gt;4902</INFO></DIV>

      implicit
     &     none
      integer
     &     luparm(30), inform, mode, m, n, lena,
     &     indc(lena), indr(lena), lenc(n), locr(m)
      double precision
     &     parmlu(30), a(lena), v(m)

<COMMENT><HR></HR>
     lu6LD  assumes lu1fac has computed factors A = LU of a
     symmetric definite or quasi-definite matrix A,
     using Threshold Symmetric Pivoting (TSP),   luparm(6) = 3,
     or    Threshold Diagonal  Pivoting (TDP),   luparm(6) = 4.
     It also assumes that no updates have been performed.
     In such cases,  U = D L', where D = diag(U).
     lu6LDL returns v as follows:

     mode
      1    v  solves   L D v = v(input).
      2    v  solves   L|D|v = v(input).

     15 Dec 2002: First version of lu6LD.
     15 Dec 2002: Current version.
<HR></HR>

 Solve L D v(new) = v  or  L|D|v(new) = v, depending on mode.
 The code for L is the same as in lu6L,
 but when a nonzero entry of v arises, we divide by
 the corresponding entry of D or |D|.
</COMMENT>
      integer
     &     ipiv, j, k, l, l1, ldummy, len, numL0
      double precision
     &     diag, small, vpiv

      numL0  = <!new fthcall luparm><A Name='C_4938'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 20)</BRANCHEMENT>
      small  = <!new fthcall parmlu><A Name='C_4939'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_parmlu">parmlu</a></FONT></A><BRANCHEMENT>( 3)</BRANCHEMENT>
      inform = 0
      l1     = lena + 1<DIV ALIGN=right><INFO>lusol.f-&gt;4942</INFO></DIV>

      <LOOP><A Name=C_4943>do</A></LOOP> k = 1, numL0
         len   = <!new fthcall lenc><A Name='C_4944'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_lenc">lenc</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
         l     = l1
         l1    = l1 - len
         ipiv  = <!new fthcall indr><A Name='C_4947'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indr">indr</a></FONT></A><BRANCHEMENT>( l1)</BRANCHEMENT>
         vpiv  = <!new fthcall v><A Name='C_4948'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_v">v</a></FONT></A><BRANCHEMENT>( ipiv)</BRANCHEMENT>

         <TEST>if</TEST> (abs( vpiv ) .gt. small) then
<COMMENT>***** This loop could be coded specially.</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4952</INFO></DIV>
            <LOOP><A Name=C_4952>do</A></LOOP> ldummy = 1, len
               l    = l - 1
               j    = <!new fthcall indc><A Name='C_4954'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indc">indc</a></FONT></A><BRANCHEMENT>( l)</BRANCHEMENT>
               v(j) = v(j)  +  a(l) * vpiv
            <A Href=#C_4952>end do</A>

<COMMENT> Find diag = U(ipiv,ipiv) and divide by diag or |diag|.
</COMMENT>
            l    = <!new fthcall locr><A Name='C_4960'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_locr">locr</a></FONT></A><BRANCHEMENT>( ipiv)</BRANCHEMENT>
            diag = <!new fthcall A><A Name='C_4961'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_a">A</a></FONT></A><BRANCHEMENT>( l)</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;4962</INFO></DIV>
            <TEST>if</TEST> (mode .eq. 2) diag = abs( diag )
            v(ipiv) = vpiv / diag
         end if
      <A Href=#C_4943>end do</A>

      end subroutine <a href="lusol_f_c.html#R_lu6LD">lu6LD</a> <COMMENT> subroutine lu6LD

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu6chk><A Name='R_lu6chk'><a target="index" href="lusol_f_i.html#R_lu6chk">lu6chk</a></A><ARGLIST>( mode, m, n, w,
     &                   lena, luparm, parmlu,
     &                   a, indc, indr, ip, iq,
     &                   lenc, lenr, locc, locr,
     &                   inform )</ARGLIST>

      implicit
     &     none
      integer
     &     mode, m, n, lena, inform,
     &     luparm(30), indc(lena), indr(lena), ip(m), iq(n),<DIV ALIGN=right><INFO>lusol.f-&gt;4982</INFO></DIV>
     &     lenc(n), lenr(m), locc(n), locr(m)
      double precision
     &     parmlu(30), a(lena), w(n)

<COMMENT><HR></HR>
     lu6chk  looks at the LU factorization  A = L*U.

     If mode = 1, lu6chk is being called by lu1fac.
     (Other modes not yet implemented.)
     The important input parameters are

                    lprint = luparm(2)
                             luparm(6) = 1 if TRP
                    keepLU = luparm(8)
                    Utol1  = parmlu(4)
                    Utol2  = parmlu(5)

     and the significant output parameters are

                    inform = luparm(10)
                    nsing  = luparm(11)
                    jsing  = luparm(12)
                    jumin  = luparm(19)
                    Lmax   = parmlu(11)
                    Umax   = parmlu(12)
                    DUmax  = parmlu(13)
                    DUmin  = parmlu(14)
                    and      w(*).

     Lmax  and Umax  return the largest elements in L and U.
     DUmax and DUmin return the largest and smallest diagonals of U
                     (excluding diagonals that are exactly zero).

     In general, w(j) is set to the maximum absolute element in
     the j-th column of U.  However, if the corresponding diagonal
     of U is small in absolute terms or relative to w(j)
     (as judged by the parameters Utol1, Utol2 respectively),
     then w(j) is changed to - w(j).

     Thus, if w(j) is not positive, the j-th column of A
     appears to be dependent on the other columns of A.
     The number of such columns, and the position of the last one,
     are returned as nsing and jsing.

     Note that nrank is assumed to be set already, and is not altered.
     Typically, nsing will satisfy      nrank + nsing = n,  but if
     Utol1 and Utol2 are rather large,  nsing &gt; n - nrank   may occur.

     If keepLU = 0,
     Lmax  and Umax  are already set by lu1fac.
     The diagonals of U are in the top of A.
     Only Utol1 is used in the singularity test to set w(*).

     inform = 0  if  A  appears to have full column rank  (nsing = 0).
     inform = 1  otherwise  (nsing .gt. 0).

     00 Jul 1987: Early version.
     09 May 1988: f77 version.
     11 Mar 2001: Allow for keepLU = 0.
     17 Nov 2001: Briefer output for singular factors.
     05 May 2002: Comma needed in format 1100 (via Kenneth Holmstrom).
     06 May 2002: With keepLU = 0, diags of U are in natural order.
                  They were not being extracted correctly.
     23 Apr 2004: TRP can judge singularity better by comparing
                  all diagonals to DUmax.
     27 Jun 2004: (PEG) Allow write only if nout .gt. 0 .
<HR></HR>
</COMMENT>
      character
     &     mnkey<DIV ALIGN=right><INFO>lusol.f-&gt;5052</INFO></DIV>
      logical
     &     keepLU, TRP
      integer
     &     i, j, jsing, jumin, k, l, l1, l2, ldiagU, lenL, lprint,
     &     ndefic, nout, nrank, nsing
      double precision
     &     aij, diag, DUmax, DUmin, Lmax, Umax, Utol1, Utol2

      <DECLARE>double precision</DECLARE> <VARIABLE>zero</VARIABLE>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )<DIV ALIGN=right><INFO>lusol.f-&gt;5062</INFO></DIV>

      nout   = <!new fthcall luparm><A Name='C_5063'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 1)</BRANCHEMENT>
      lprint = <!new fthcall luparm><A Name='C_5064'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 2)</BRANCHEMENT>
      TRP    = <!new fthcall luparm><A Name='C_5065'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 6)</BRANCHEMENT> .eq. 1  <COMMENT> Threshold Rook Pivoting</COMMENT>
      keepLU = <!new fthcall luparm><A Name='C_5066'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 8)</BRANCHEMENT> .ne. 0
      nrank  = <!new fthcall luparm><A Name='C_5067'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 16)</BRANCHEMENT>
      lenL   = <!new fthcall luparm><A Name='C_5068'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_luparm">luparm</a></FONT></A><BRANCHEMENT>( 23)</BRANCHEMENT>
      Utol1  = <!new fthcall parmlu><A Name='C_5069'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_parmlu">parmlu</a></FONT></A><BRANCHEMENT>( 4)</BRANCHEMENT>
      Utol2  = <!new fthcall parmlu><A Name='C_5070'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_parmlu">parmlu</a></FONT></A><BRANCHEMENT>( 5)</BRANCHEMENT>

      inform = 0<DIV ALIGN=right><INFO>lusol.f-&gt;5073</INFO></DIV>
      Lmax   = zero
      Umax   = zero
      nsing  = 0
      jsing  = 0
      jumin  = 0
      DUmax  = zero
      DUmin  = 1.0d+30

      <LOOP><A Name=C_5081>do</A></LOOP> j = 1, n
         w(j) = zero<DIV ALIGN=right><INFO>lusol.f-&gt;5083</INFO></DIV>
      <A Href=#C_5081>end do</A>


      <TEST>if</TEST> (keepLU) then
<COMMENT><HR></HR>
 Find  Lmax.
<HR></HR></COMMENT>
         <LOOP><A Name=C_5090>do</A></LOOP> l = lena + 1 - lenL, lena
            Lmax  = max( Lmax, abs(a(l)) )
         <A Href=#C_5090>end do</A><DIV ALIGN=right><INFO>lusol.f-&gt;5093</INFO></DIV>

<COMMENT><HR></HR>
 Find Umax and set w(j) = maximum element in j-th column of U.
<HR></HR></COMMENT>
         <LOOP><A Name=C_5097>do</A></LOOP> k = 1, nrank
            i     = <!new fthcall ip><A Name='C_5098'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ip">ip</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
            l1    = <!new fthcall locr><A Name='C_5099'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_locr">locr</a></FONT></A><BRANCHEMENT>( i)</BRANCHEMENT>
            l2    = l1 + lenr(i) - 1

            <LOOP><A Name=C_5102>do</A></LOOP> l = l1, l2<DIV ALIGN=right><INFO>lusol.f-&gt;5103</INFO></DIV>
               j     = <!new fthcall indr><A Name='C_5103'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_indr">indr</a></FONT></A><BRANCHEMENT>( l)</BRANCHEMENT>
               aij   = abs( a(l) )
               w(j)  = max( w(j), aij )
               Umax  = max( Umax, aij )
            <A Href=#C_5102>end do</A>
         <A Href=#C_5097>end do</A>

         parmlu(11) = Lmax
         parmlu(12) = Umax

<COMMENT><HR></HR>
 Find DUmax and DUmin, the extreme diagonals of U.
<HR></HR></COMMENT>
         <LOOP><A Name=C_5116>do</A></LOOP> k = 1, nrank
            j      = <!new fthcall iq><A Name='C_5117'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iq">iq</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
            i      = <!new fthcall ip><A Name='C_5118'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ip">ip</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
            l1     = <!new fthcall locr><A Name='C_5119'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_locr">locr</a></FONT></A><BRANCHEMENT>( i)</BRANCHEMENT>
            diag   = abs( a(l1) )
            DUmax  = max( DUmax, diag )
            <TEST>if</TEST> (DUmin .gt. diag) then
               DUmin  =   diag<DIV ALIGN=right><INFO>lusol.f-&gt;5124</INFO></DIV>
               jumin  =   j
            end if
         <A Href=#C_5116>end do</A>

      else
<COMMENT><HR></HR>
 keepLU = 0.
 Only diag(U) is stored.  Set w(*) accordingly.
 Find DUmax and DUmin, the extreme diagonals of U.
<HR></HR></COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;5134</INFO></DIV>
         ldiagU = lena - n

         <LOOP><A Name=C_5136>do</A></LOOP> k = 1, nrank
            j      = <!new fthcall iq><A Name='C_5137'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iq">iq</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
<COMMENT>!diag   = abs( a(ldiagU + k) ) ! 06 May 2002: Diags</COMMENT>
            diag   = abs( a(ldiagU + j) ) <COMMENT> are in natural order</COMMENT>
            w(j)   = diag
            DUmax  = max( DUmax, diag )
            <TEST>if</TEST> (DUmin .gt. diag) then
               DUmin  =   diag<DIV ALIGN=right><INFO>lusol.f-&gt;5144</INFO></DIV>
               jumin  =   j
            end if
         <A Href=#C_5136>end do</A>
      end if


<COMMENT><HR></HR>
 Negate w(j) if the corresponding diagonal of U is
 too small in absolute terms or relative to the other elements
 in the same column of  U.

 23 Apr 2004: TRP ensures that diags are NOT small relative to
              other elements in their own column.
              Much better, we can compare all diags to DUmax.
<HR></HR></COMMENT>
      <TEST>if</TEST> (mode .eq. 1  .and.  TRP) then
         Utol1 = max( Utol1, Utol2*DUmax )
      end if

      <TEST>if</TEST> (keepLU) then<DIV ALIGN=right><INFO>lusol.f-&gt;5164</INFO></DIV>
         <LOOP><A Name=C_5164>do</A></LOOP> k = 1, n
            j     = <!new fthcall iq><A Name='C_5165'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iq">iq</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
            <TEST>if</TEST> (k .gt. nrank) then
               diag   = zero
            else
               i      = <!new fthcall ip><A Name='C_5169'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_ip">ip</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT>
               l1     = <!new fthcall locr><A Name='C_5170'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_locr">locr</a></FONT></A><BRANCHEMENT>( i)</BRANCHEMENT>
               diag   = abs( a(l1) )
            end if

            <TEST>if</TEST> (diag .le. Utol1  .or.  diag .le. Utol2*w(j)) then<DIV ALIGN=right><INFO>lusol.f-&gt;5175</INFO></DIV>
               nsing  =   nsing + 1
               jsing  =   j
               w(j)   = - w(j)
            end if
         <A Href=#C_5164>end do</A>

      else <COMMENT> keepLU = 0
</COMMENT>
         <LOOP><A Name=C_5183>do</A></LOOP> k = 1, n
            j      = <!new fthcall iq><A Name='C_5184'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_iq">iq</a></FONT></A><BRANCHEMENT>( k)</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;5185</INFO></DIV>
            diag   = <!new fthcall w><A Name='C_5185'><FONT COLOR=GREEN><a target="source" href="externalindex_c.html#R_w">w</a></FONT></A><BRANCHEMENT>( j)</BRANCHEMENT>

            <TEST>if</TEST> (diag .le. Utol1) then
               nsing  =   nsing + 1
               jsing  =   j
               w(j)   = - w(j)
            end if
         <A Href=#C_5183>end do</A>
      end if


<COMMENT><HR></HR>
 Set output parameters.
<HR></HR></COMMENT>
      <TEST>if</TEST> (jumin .eq. 0) DUmin = zero
      luparm(11) = nsing
      luparm(12) = jsing
      luparm(19) = jumin
      parmlu(13) = DUmax
      parmlu(14) = DUmin

      <TEST>if</TEST> (nsing .gt. 0) then  <COMMENT> The matrix has been judged singular.</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;5207</INFO></DIV>
         inform = 1
         ndefic = n - nrank
         <TEST>if</TEST> (nout .gt. 0  .and.  lprint .ge. 0) then
            <TEST>if</TEST> (m .gt. n) then
               mnkey  = '&gt;'
            else if (m .eq. n) then
               mnkey  = '='
            else
               mnkey  = '&lt;'
            end if<DIV ALIGN=right><INFO>lusol.f-&gt;5217</INFO></DIV>
            write(nout, 1100) mnkey, nrank, ndefic, nsing
         end if
      end if

<COMMENT>     Exit.
</COMMENT>
      luparm(10) = inform
      return

 <A Name=lu6chk_L_1100>1100</A> format(' Singular(m', a, 'n)',<DIV ALIGN=right><INFO>lusol.f-&gt;5227</INFO></DIV>
     &       '  rank', i9, '  n-rank', i8, '  nsing', i9)

      end subroutine <a href="lusol_f_c.html#R_lu6chk">lu6chk</a> <COMMENT> subroutine lu6chk

<HR></HR>
<HR></HR>

     File  lusol6b.f

     lu6mul   lu6prt   lu6set

 03 Mar 2004: lusol6b.f is essentially lu6b.for from VMS days.
              integer*4 changed to integer  .
<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu6mul><A Name='R_lu6mul'><a target="index" href="lusol_f_i.html#R_lu6mul">lu6mul</a></A><ARGLIST>( mode, m, n, v, w,
     $                   lena, luparm, parmlu,
     $                   a, indc, indr, ip, iq,
     $                   lenc, lenr, locc, locr )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE><DIV ALIGN=right><INFO>lusol.f-&gt;5248</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena), v(m), w(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>lenc(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

<COMMENT><HR></HR>
     lu6mul  uses the factorization   A = L*U   as follows...

     mode
<HR></HR>
      1    v  is changed to  L*v.             w  is not touched.
      2    v  is changed to  L(t)*v.          w  is not touched.
      3    v  is set to      U*w.             w  is not altered.
      4    w  is set to      U(t)*v.          v  is not altered.
      5    v  is set to      A*w.             w  is not altered.
      6    w  is set to      A(t)*v.          v  is changed to  L(t)*v.

     If  mode .ge. 3,  v  and  w  must not be the same arrays.

     lenc(*)  and  locc(*)  are not used.

     09 May 1988: First F77 version.
     30 Jan 1996: Converted to lower case (finally!).
     03 Mar 2004: Time to abolish the computed go to!!
<HR></HR>
</COMMENT>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )

      nrank  = luparm(16)
      lenl   = luparm(23)<DIV ALIGN=right><INFO>lusol.f-&gt;5279</INFO></DIV>
<COMMENT>!!! go to (100, 200, 300, 400, 300, 200), mode</COMMENT>
      <TEST>if</TEST> (mode .eq. 1) go to 100
      <TEST>if</TEST> (mode .eq. 2) go to 200
      <TEST>if</TEST> (mode .eq. 3) go to 300
      <TEST>if</TEST> (mode .eq. 4) go to 400
      <TEST>if</TEST> (mode .eq. 5) go to 300
      <TEST>if</TEST> (mode .eq. 6) go to 200

<COMMENT><HR></HR>
     mode = 1 or 5.    Set  v = L*v.
<HR></HR></COMMENT>
  <A Name=lu6mul_L_100>100</A> l1     = lena + 1 - lenl
      <LOOP><A Name=C_5291>do</A></LOOP> l = l1, lena
         i     = indr(l)
         <TEST>if</TEST> (v(i) .ne. zero) then
            j     = indc(l)
            v(j)  = v(j) - a(l)*v(i)
         end if
      <A Href=#C_5291>end do</A>

      return<DIV ALIGN=right><INFO>lusol.f-&gt;5300</INFO></DIV>

<COMMENT><HR></HR>
     mode = 2 or 6.    Set  v = L(t)*v.
<HR></HR></COMMENT>
  <A Name=lu6mul_L_200>200</A> <LOOP><A Name=C_5304>do</A></LOOP> l = lenl, 1, -1
         j     = indc(l)
         <TEST>if</TEST> (v(j) .ne. zero) then
            i     = indr(l)
            v(i)  = v(i)  -  a(l) * v(j)
         end if<DIV ALIGN=right><INFO>lusol.f-&gt;5310</INFO></DIV>
      <A Href=#C_5304>end do</A>

      <TEST>if</TEST> (mode .eq. 6) go to 400
      return

<COMMENT><HR></HR>
     mode = 3 or 5.    set  v = U*w.
<HR></HR>

 Find the last nonzero in  w(*).
</COMMENT>
  <A Name=lu6mul_L_300>300</A> <LOOP><A Name=C_5321>do</A></LOOP> klast = n, 1, -1
         j     = iq(klast)
         <TEST>if</TEST> (w(j) .ne. zero) go to 320
      <A Href=#C_5321>end do</A>

  <A Name=lu6mul_L_320>320</A> klast  = min( klast, nrank )
      <LOOP><A Name=C_5327>do</A></LOOP> k = klast + 1, m
         i     = ip(k)
         v(i)  = zero<DIV ALIGN=right><INFO>lusol.f-&gt;5330</INFO></DIV>
      <A Href=#C_5327>end do</A>

<COMMENT> Form U*w, using rows 1 to klast of U.
</COMMENT>
      <LOOP><A Name=C_5334>do</A></LOOP> k = 1, klast
         t     = zero
         i     = ip(k)
         l1    = locr(i)
         l2    = l1 + lenr(i) - 1

         <LOOP><A Name=C_5340>do</A></LOOP> l = l1, l2<DIV ALIGN=right><INFO>lusol.f-&gt;5341</INFO></DIV>
            j     = indr(l)
            t     = t  +  a(l) * w(j)
         <A Href=#C_5340>end do</A>

         v(i)  = t
      <A Href=#C_5334>end do</A>

      <TEST>if</TEST> (mode .eq. 5) go to 100
      return

<COMMENT><HR></HR>
     mode = 4.    set  w = U(transpose)*v.
<HR></HR>

 Find the last nonzero in  v(*).
</COMMENT>
  <A Name=lu6mul_L_400>400</A> <LOOP><A Name=C_5357>do</A></LOOP> klast = m, 1, -1
         i     = ip(klast)
         <TEST>if</TEST> (v(i) .ne. zero) go to 420
      <A Href=#C_5357>end do</A>

  <A Name=lu6mul_L_420>420</A> klast  = min( klast, nrank )<DIV ALIGN=right><INFO>lusol.f-&gt;5363</INFO></DIV>

      <LOOP><A Name=C_5364>do</A></LOOP> j = 1, n
         w(j)  = zero
      <A Href=#C_5364>end do</A>

      <LOOP><A Name=C_5368>do</A></LOOP> <A Href=#lu6mul_L_480>480</A> k = 1, klast
         i     = ip(k)
         t     = v(i)
         <TEST>if</TEST> (t .eq. zero) go to 480
         l1    = locr(i)<DIV ALIGN=right><INFO>lusol.f-&gt;5373</INFO></DIV>
         l2    = l1 + lenr(i) - 1

         <LOOP><A Name=C_5375>do</A></LOOP> l = l1, l2
            j     = indr(l)
            w(j)  = w(j)  +  a(l) * t
         <A Href=#C_5375>end do</A>
  <A Name=lu6mul_L_480>480</A>[<A Href=#C_5368>1</A>] continue

      end subroutine <a href="lusol_f_c.html#R_lu6mul">lu6mul</a> <COMMENT> subroutine lu6mul

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu6prt><A Name='R_lu6prt'><a target="index" href="lusol_f_i.html#R_lu6prt">lu6prt</a></A><ARGLIST>( m, n, v, w,
     $                   lena, luparm, parmlu,
     $                   a, indc, indr, ip, iq,
     $                   lenc, lenr, locc, locr )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena), v(m), w(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n)</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;5394</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>lenc(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

<COMMENT><HR></HR>
     lu6prt  prints details of the current LU factorization, and
     prints the matrix A = L*U row by row.  The amount of output
     is controlled by lprint = luparm(2).

     If  lprint = 0,  nothing is printed.
     If  lprint = 1,  current LU statistics are printed.
     If  lprint = 2,  the leading 10 by 10 submatrix is printed.
     If  lprint = 3   or more, all rows are printed.

     lenc(*), locc(*)  are not used.

     09 May 1988: First F77 version.
     03 Mar 2004: Current version.
<HR></HR>
</COMMENT>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0,  one = 1.0d+0 )<DIV ALIGN=right><INFO>lusol.f-&gt;5414</INFO></DIV>

      nout   = luparm(1)
      lprint = luparm(2)
      imax   = m
      jmax   = n
      <TEST>if</TEST> (lprint .le. 0) return
      <TEST>if</TEST> (lprint .le. 2) imax = min( imax, 10 )
      <TEST>if</TEST> (lprint .le. 2) jmax = min( jmax, 10 )
      write(nout, 1000) m, n, lena

<COMMENT><HR></HR>
     Print LU statistics.
<HR></HR></COMMENT>
      lamin  = luparm(13)
      nrank  = luparm(16)
      lenl   = luparm(23)
      lenu   = luparm(24)
      lrow   = luparm(25)
      ncp    = luparm(26)
      mersum = luparm(27)
      amax   = parmlu(10)<DIV ALIGN=right><INFO>lusol.f-&gt;5435</INFO></DIV>
      elmax  = parmlu(11)
      umax   = parmlu(12)
      dumin  = parmlu(14)

      avgmer = mersum
      floatm = m
      avgmer = avgmer / floatm
      growth = umax / (amax + 1.0d-20)
      write(nout, 2000) ncp, avgmer, lenl, lenu, nrank,
     $                  elmax, amax, umax, dumin, growth<DIV ALIGN=right><INFO>lusol.f-&gt;5445</INFO></DIV>
      write(nout, 2100) (ip(i), i = 1, imax)
      write(nout, 2200) (iq(j), j = 1, jmax)
      <TEST>if</TEST> (lprint .le. 1) return

<COMMENT><HR></HR>
     lprint = 2 or more.    Print the first imax rows of  A.
<HR></HR></COMMENT>
      <LOOP><A Name=C_5452>do</A></LOOP> i = 1, imax
         <LOOP><A Name=C_5453>do</A></LOOP> k = 1, m
            v(k) = zero<DIV ALIGN=right><INFO>lusol.f-&gt;5455</INFO></DIV>
         <A Href=#C_5453>end do</A>
         v(i)   = one  <COMMENT> v = i-th unit vector

 Set  w = A(t)*v = U(t)*L(t)*v.
</COMMENT>
         call <!new fthcall lu6mul><A Name='C_5460'><a href="lusol_f_c.html#R_lu6mul">lu6mul</a></A><BRANCHEMENT>( 6, m, n, v, w,
     $                lena, luparm, parmlu,
     $                a, indc, indr, ip, iq, lenc, lenr, locc, locr )</BRANCHEMENT>

         write(nout, 1100) (w(j), j = 1, jmax)<DIV ALIGN=right><INFO>lusol.f-&gt;5465</INFO></DIV>
      <A Href=#C_5452>end do</A>
      return

 <A Name=lu6prt_L_1000>1000</A> format(/ ' -----------------------------------------------------'
     $       / ' lu6prt.      m =', i6, '     n =', i6, '   lena =', i8
     $       / ' -----------------------------------------------------')
 <A Name=lu6prt_L_1100>1100</A> format(/ (1x, 10g13.5))
 <A Name=lu6prt_L_2000>2000</A> format(/ ' -----------------------------------------------------'
     $       / ' LU factorization statistics.'
     $       / ' -----------------------------------------------------'<DIV ALIGN=right><INFO>lusol.f-&gt;5475</INFO></DIV>
     $       //' compressns', i5, '    merit', 1p, e10.1,
     $         '    lenl', i11, '    lenu', i11, '    rank', i11
     $       / ' lmax', e11.1, '    bmax', e11.1,
     $         '    umax', e11.1, '    umin', e11.1,
     $         '    growth', e9.1)
 <A Name=lu6prt_L_2100>2100</A> format(//' Row    permutation  ip' / (1x, 10i7))
 <A Name=lu6prt_L_2200>2200</A> format(//' Column permutation  iq' / (1x, 10i7))

      end subroutine <a href="lusol_f_c.html#R_lu6prt">lu6prt</a> <COMMENT> subroutine lu6prt

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu6set><A Name='R_lu6set'><a target="index" href="lusol_f_i.html#R_lu6set">lu6set</a></A><ARGLIST>( mode, m, n, w,
     $                   lena, luparm, parmlu,
     $                   a, indc, indr, ip, iq,
     $                   lenc, lenr, locc, locr,
     $                   inform )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena), w(n)</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;5496</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>lenc(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

<COMMENT><HR></HR>
     lu6set  initializes various quantities for the LU routines.

     If mode = 1,
     lu6set  gives default values to relevant elements of the
     arrays  luparm(*)  and  parmlu(*).  This mode is appropriate
     if a factorization routine (e.g. lu1fac) is called later.

     If mode = 2,
     lu6set  also sets the arrays a(*), indc(*), indr(*), etc.
     to correspond to an LU factorization of the diagonal matrix

                      A = Diag( w(i) )

     for the given n-vector w(*).  The matrix A will have
     m rows and n columns, where m and n must be at least 1.

     w(*) may be completely zero, or contain some zero elements.
     Any zero elements will be excluded from the data structure.
     If m is less than n, only the first m entries of w(*)
     will be used.

     The LU factorization returned will be L = I, U = Diag(w),
     with identities for the row and column permutations ip, iq.

     On exit, inform = 0 unless there is some blatant error in
     the input parameters.

     09 May 1988: First F77 version.
     03 Mar 2004: Current version.
<HR></HR>
</COMMENT>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )

      luparm( 1) = 6
      luparm( 2) = 0<DIV ALIGN=right><INFO>lusol.f-&gt;5536</INFO></DIV>
      luparm( 3) = 10

      parmlu( 1) = 10.0d+0
      parmlu( 2) = 10.0d+0
      parmlu( 3) = 1.0d-12
      parmlu( 4) = 1.0d-10
      parmlu( 5) = parmlu(4)
      parmlu( 6) = 3.0d+0
      inform     = 0
      nrank      = 0<DIV ALIGN=right><INFO>lusol.f-&gt;5546</INFO></DIV>

<COMMENT>     Check for obvious errors.
</COMMENT>
      <TEST>if</TEST> (m    .le. 0    ) go to 910
      <TEST>if</TEST> (n    .le. 0    ) go to 910
      <TEST>if</TEST> (lena .le. m + n) go to 910
      <TEST>if</TEST> (mode .le. 1    ) go to 990

<COMMENT><HR></HR>
     mode = 2.      Set  U = Diag( w(i) ) using nonzero elements w(i).
<HR></HR></COMMENT>
      nsing  = 0
      jsing  = 0
      dumax  = zero
      dumin  = abs( w(1) )
      l      = 0
      minmn  = min( m, n )

      <LOOP><A Name=C_5564>do</A></LOOP> <A Href=#lu6set_L_100>100</A> i = 1, minmn
         <TEST>if</TEST> (w(i) .eq. zero) go to 100<DIV ALIGN=right><INFO>lusol.f-&gt;5566</INFO></DIV>
         l       = l + 1
         ip(l)   = i
         iq(l)   = i
         lenr(i) = 1
         locr(i) = l
         a(l)    = w(i)
         indr(l) = i
         dumax   = max( dumax, abs( w(i) ) )
         dumin   = min( dumin, abs( w(i) ) )
  <A Name=lu6set_L_100>100</A>[<A Href=#C_5564>1</A>] continue<DIV ALIGN=right><INFO>lusol.f-&gt;5576</INFO></DIV>

      nrank  = l

<COMMENT> The permutations ip and iq point to the nonsingular part of w.
 Fix up the remaining parts of ip.
</COMMENT>
      <LOOP><A Name=C_5582>do</A></LOOP> <A Href=#lu6set_L_200>200</A> i = 1, m
         <TEST>if</TEST> (  i  .gt.  n  ) go to 150
         <TEST>if</TEST> (w(i) .ne. zero) go to 200
  <A Name=lu6set_L_150>150</A>    l       = l + 1<DIV ALIGN=right><INFO>lusol.f-&gt;5586</INFO></DIV>
         ip(l)   = i
         lenr(i) = 0
         nsing   = nsing + 1
         jsing   = i
  <A Name=lu6set_L_200>200</A>[<A Href=#C_5582>1</A>] continue

<COMMENT> Fix up the remaining parts of iq.
</COMMENT>
      l      = nrank
      <LOOP><A Name=C_5595>do</A></LOOP> <A Href=#lu6set_L_300>300</A> j = 1, n<DIV ALIGN=right><INFO>lusol.f-&gt;5596</INFO></DIV>
         locc(j) = 0
         <TEST>if</TEST> (w(j) .ne. zero) go to 300
         l       = l + 1
         iq(l)   = j
  <A Name=lu6set_L_300>300</A>[<A Href=#C_5595>1</A>] continue

<COMMENT><HR></HR>
 Set output parameters for  mode 2.
<HR></HR></COMMENT>
      nupdat = 0<DIV ALIGN=right><INFO>lusol.f-&gt;5606</INFO></DIV>
      numl0  = 0
      lenl   = 0
      lenu   = nrank
      lrow   = nrank
      ncp    = 0
      amax   = dumax
      elmax  = zero
      umax   = dumax

      luparm(11) = nsing<DIV ALIGN=right><INFO>lusol.f-&gt;5616</INFO></DIV>
      luparm(12) = jsing
      luparm(15) = nupdat
      luparm(16) = nrank

      luparm(20) = numl0
      luparm(21) = lenl
      luparm(22) = lenu
      luparm(23) = lenl
      luparm(24) = lenu
      luparm(25) = lrow<DIV ALIGN=right><INFO>lusol.f-&gt;5626</INFO></DIV>
      luparm(26) = ncp

      parmlu(10) = amax
      parmlu(11) = elmax
      parmlu(12) = umax
      parmlu(13) = dumax
      parmlu(14) = dumin
      go to <A Href=#lu6set_L_990>990</A>

<COMMENT> Error exit.
</COMMENT>
  <A Name=lu6set_L_910>910</A> inform = 1

<COMMENT> Exit.
</COMMENT>
  <A Name=lu6set_L_990>990</A> luparm(10) = inform

      end subroutine <a href="lusol_f_c.html#R_lu6set">lu6set</a> <COMMENT> subroutine lu6set</COMMENT>
************************************************************************
*<DIV ALIGN=right><INFO>lusol.f-&gt;5646</INFO></DIV>
*     File  lusol7a.f
*
*     lu7add   lu7cyc   lu7elm   lu7for   lu7rnk   lu7zap
*
*     Utilities for LUSOL's update routines.
*     lu7for is the most important -- the forward sweep.
*
* 01 May 2002: Derived from LUSOL's original lu7a.f file.
* 01 May 2002: Current version of lusol7a.f.
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<DIV ALIGN=right><INFO>lusol.f-&gt;5656</INFO></DIV>

      subroutine <!new fthrout lu7add><A Name='R_lu7add'><a target="index" href="lusol_f_i.html#R_lu7add">lu7add</a></A><ARGLIST>( m, n, jadd, v,
     $                   lena, luparm, parmlu,
     $                   lenL, lenU, lrow, nrank,
     $                   a, indr, ip, lenr, locr,
     $                   inform, klast, vnorm )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena), v(m)</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;5666</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>indr(lena), ip(m), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locr(m)</VARIABLE>

*     ------------------------------------------------------------------
*     lu7add  inserts the first nrank elements of the vector v(*)
*     as column  jadd  of  U.  We assume that  U  does not yet have any
*     entries in this column.
*     Elements no larger than  parmlu(3)  are treated as zero.
*     klast  will be set so that the last row to be affected
*     (in pivotal order) is row  ip(klast).<DIV ALIGN=right><INFO>lusol.f-&gt;5676</INFO></DIV>
*
*     09 May 1988: First f77 version.
*     ------------------------------------------------------------------

<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )

      small  = parmlu(3)
      vnorm  = zero
      klast  = 0

      <LOOP><A Name=C_5686>do</A></LOOP> <A Href=#lu7add_L_200>200</A> k  = 1, nrank<DIV ALIGN=right><INFO>lusol.f-&gt;5687</INFO></DIV>
         i      = ip(k)
         <TEST>if</TEST> (abs( v(i) ) .le. small) go to 200
         klast  = k
         vnorm  = vnorm  +  abs( v(i) )
         leni   = lenr(i)

*        Compress row file if necessary.

         minfre = leni + 1
         nfree  = lena - lenL - lrow<DIV ALIGN=right><INFO>lusol.f-&gt;5697</INFO></DIV>
         <TEST>if</TEST> (nfree .lt. minfre) then
            call <!new fthcall lu1rec><A Name='C_5698'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( m, .true., luparm, lrow, lena,
     $                   a, indr, lenr, locr )</BRANCHEMENT>
            nfree  = lena - lenL - lrow
            <TEST>if</TEST> (nfree .lt. minfre) go to 970
         end if

*        Move row  i  to the end of the row file,
*        unless it is already there.
*        No need to move if there is a gap already.<DIV ALIGN=right><INFO>lusol.f-&gt;5707</INFO></DIV>

         <TEST>if</TEST> (leni .eq. 0) locr(i) = lrow + 1
         lr1    = locr(i)
         lr2    = lr1 + leni - 1
         <TEST>if</TEST> (lr2    .eq.   lrow) go to 150
         <TEST>if</TEST> (indr(lr2+1) .eq. 0) go to 180
         locr(i) = lrow + 1

         <LOOP><A Name=C_5715>do</A></LOOP> <A Href=#lu7add_L_140>140</A> l = lr1, lr2
            lrow       = lrow + 1<DIV ALIGN=right><INFO>lusol.f-&gt;5717</INFO></DIV>
            a(lrow)    = a(l)
            j          = indr(l)
            indr(l)    = 0
            indr(lrow) = j
  <A Name=lu7add_L_140>140</A>[<A Href=#C_5715>1</A>]    continue

  <A Name=lu7add_L_150>150</A>    lr2     = lrow
         lrow    = lrow + 1

*        Add the element of  v.<DIV ALIGN=right><INFO>lusol.f-&gt;5727</INFO></DIV>

  <A Name=lu7add_L_180>180</A>    lr2       = lr2 + 1
         a(lr2)    = v(i)
         indr(lr2) = jadd
         lenr(i)   = leni + 1
         lenU      = lenU + 1
  <A Name=lu7add_L_200>200</A>[<A Href=#C_5686>1</A>] continue

*     Normal exit.

      inform = 0<DIV ALIGN=right><INFO>lusol.f-&gt;5738</INFO></DIV>
      go to <A Href=#lu7add_L_990>990</A>

*     Not enough storage.

  <A Name=lu7add_L_970>970</A> inform = 7

  <A Name=lu7add_L_990>990</A> return

      end subroutine <a href="lusol_f_c.html#R_lu7add">lu7add</a> <COMMENT> subroutine lu7add
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;5748</INFO></DIV>
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine <!new fthrout lu7cyc><A Name='R_lu7cyc'><a target="index" href="lusol_f_i.html#R_lu7cyc">lu7cyc</a></A><ARGLIST>( kfirst, klast, ip )</ARGLIST>

      <DECLARE>integer</DECLARE> <VARIABLE>ip(klast)</VARIABLE>

*     ------------------------------------------------------------------
*     lu7cyc performs a cyclic permutation on the row or column ordering
*     stored in ip, moving entry kfirst down to klast.
*     If kfirst .ge. klast, lu7cyc should not be called.<DIV ALIGN=right><INFO>lusol.f-&gt;5758</INFO></DIV>
*     Sometimes klast = 0 and nothing should happen.
*
*     09 May 1988: First f77 version.
*     ------------------------------------------------------------------

      <TEST>if</TEST> (kfirst .lt. klast) then
         ifirst = ip(kfirst)

         <LOOP><A Name=C_5766>do</A></LOOP> <A Href=#lu7cyc_L_100>100</A> k = kfirst, klast - 1
            ip(k) = ip(k + 1)<DIV ALIGN=right><INFO>lusol.f-&gt;5768</INFO></DIV>
  <A Name=lu7cyc_L_100>100</A>[<A Href=#C_5766>1</A>]    continue

         ip(klast) = ifirst
      end if

      end subroutine <a href="lusol_f_c.html#R_lu7cyc">lu7cyc</a> <COMMENT> subroutine lu7cyc
</COMMENT>
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine <!new fthrout lu7elm><A Name='R_lu7elm'><a target="index" href="lusol_f_i.html#R_lu7elm">lu7elm</a></A><ARGLIST>( m, n, jelm, v,
     $                   lena, luparm, parmlu,
     $                   lenL, lenU, lrow, nrank,
     $                   a, indc, indr, ip, iq, lenr, locc, locr,
     $                   inform, diag )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena), v(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;5788</INFO></DIV>

*     ------------------------------------------------------------------
*     lu7elm  eliminates the subdiagonal elements of a vector  v(*),
*     where  L*v = y  for some vector y.
*     If  jelm &gt; 0,  y  has just become column  jelm  of the matrix  A.
*     lu7elm  should not be called unless  m  is greater than  nrank.
*
*     inform = 0 if y contained no subdiagonal nonzeros to eliminate.
*     inform = 1 if y contained at least one nontrivial subdiagonal.
*     inform = 7 if there is insufficient storage.<DIV ALIGN=right><INFO>lusol.f-&gt;5798</INFO></DIV>
*
*     09 May 1988: First f77 version.
*                  No longer calls lu7for at end.  lu8rpc, lu8mod do so.
*     ------------------------------------------------------------------

<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )

      small  = parmlu(3)
      nrank1 = nrank + 1
      diag   = zero<DIV ALIGN=right><INFO>lusol.f-&gt;5808</INFO></DIV>

*     Compress row file if necessary.

      minfre = m - nrank
      nfree  = lena - lenL - lrow
      <TEST>if</TEST> (nfree .ge. minfre) go to 100
      call <!new fthcall lu1rec><A Name='C_5814'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( m, .true., luparm, lrow, lena, a, indr, lenr, locr )</BRANCHEMENT>
      nfree  = lena - lenL - lrow
      <TEST>if</TEST> (nfree .lt. minfre) go to 970

*     Pack the subdiagonals of  v  into  L,  and find the largest.<DIV ALIGN=right><INFO>lusol.f-&gt;5819</INFO></DIV>

  <A Name=lu7elm_L_100>100</A> vmax   = zero
      kmax   = 0
      l      = lena - lenL + 1

      <LOOP><A Name=C_5824>do</A></LOOP> <A Href=#lu7elm_L_200>200</A> k = nrank1, m
         i       = ip(k)
         vi      = abs( v(i) )
         <TEST>if</TEST> (vi .le. small) go to 200
         l       = l - 1<DIV ALIGN=right><INFO>lusol.f-&gt;5829</INFO></DIV>
         a(l)    = v(i)
         indc(l) = i
         <TEST>if</TEST> (vmax .ge. vi ) go to 200
         vmax    = vi
         kmax    = k
         lmax    = l
  <A Name=lu7elm_L_200>200</A>[<A Href=#C_5824>1</A>] continue

      <TEST>if</TEST> (kmax .eq. 0) go to 900

*     ------------------------------------------------------------------<DIV ALIGN=right><INFO>lusol.f-&gt;5840</INFO></DIV>
*     Remove  vmax  by overwriting it with the last packed  v(i).
*     Then set the multipliers in  L  for the other elements.
*     ------------------------------------------------------------------

      imax       = ip(kmax)
      vmax       = a(lmax)
      a(lmax)    = a(l)
      indc(lmax) = indc(l)
      l1         = l + 1
      l2         = lena - lenL<DIV ALIGN=right><INFO>lusol.f-&gt;5850</INFO></DIV>
      lenL       = lenL + (l2 - l)

      <LOOP><A Name=C_5852>do</A></LOOP> <A Href=#lu7elm_L_300>300</A> l = l1, l2
         a(l)    = - a(l) / vmax
         indr(l) =   imax
  <A Name=lu7elm_L_300>300</A>[<A Href=#C_5852>1</A>] continue

*     Move the row containing vmax to pivotal position nrank + 1.

      ip(kmax  ) = ip(nrank1)<DIV ALIGN=right><INFO>lusol.f-&gt;5860</INFO></DIV>
      ip(nrank1) = imax
      diag       = vmax

*     ------------------------------------------------------------------
*     If jelm is positive, insert  vmax  into a new row of  U.
*     This is now the only subdiagonal element.
*     ------------------------------------------------------------------

      <TEST>if</TEST> (jelm .gt. 0) then
         lrow       = lrow + 1<DIV ALIGN=right><INFO>lusol.f-&gt;5870</INFO></DIV>
         locr(imax) = lrow
         lenr(imax) = 1
         a(lrow)    = vmax
         indr(lrow) = jelm
      end if

      inform = 1
      go to <A Href=#lu7elm_L_990>990</A>

*     No elements to eliminate.<DIV ALIGN=right><INFO>lusol.f-&gt;5880</INFO></DIV>

  <A Name=lu7elm_L_900>900</A> inform = 0
      go to <A Href=#lu7elm_L_990>990</A>

*     Not enough storage.

  <A Name=lu7elm_L_970>970</A> inform = 7

  <A Name=lu7elm_L_990>990</A> return

      end subroutine <a href="lusol_f_c.html#R_lu7elm">lu7elm</a> <COMMENT> subroutine lu7elm
</COMMENT>
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine <!new fthrout lu7for><A Name='R_lu7for'><a target="index" href="lusol_f_i.html#R_lu7for">lu7for</a></A><ARGLIST>( m, n, kfirst, klast,
     $                   lena, luparm, parmlu,
     $                   lenL, lenU, lrow,
     $                   a, indc, indr, ip, iq, lenr, locc, locr,
     $                   inform, diag )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE><DIV ALIGN=right><INFO>lusol.f-&gt;5901</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

*     ------------------------------------------------------------------
*     lu7for  (forward sweep) updates the LU factorization  A = L*U
*     when row  iw = ip(klast)  of  U  is eliminated by a forward
*     sweep of stabilized row operations, leaving  ip * U * iq  upper
*     triangular.<DIV ALIGN=right><INFO>lusol.f-&gt;5911</INFO></DIV>
*
*     The row permutation  ip  is updated to preserve stability and/or
*     sparsity.  The column permutation  iq  is not altered.
*
*     kfirst  is such that row  ip(kfirst)  is the first row involved
*     in eliminating row  iw.  (Hence,  kfirst  marks the first nonzero
*     in row  iw  in pivotal order.)  If  kfirst  is unknown it may be
*     input as  1.
*
*     klast   is such that row  ip(klast)  is the row being eliminated.<DIV ALIGN=right><INFO>lusol.f-&gt;5921</INFO></DIV>
*     klast   is not altered.
*
*     lu7for  should be called only if  kfirst .le. klast.
*     If  kfirst = klast,  there are no nonzeros to eliminate, but the
*     diagonal element of row  ip(klast)  may need to be moved to the
*     front of the row.
*
*     On entry,  locc(*)  must be zero.
*
*     On exit:<DIV ALIGN=right><INFO>lusol.f-&gt;5931</INFO></DIV>
*     inform = 0  if row iw has a nonzero diagonal (could be small).
*     inform = 1  if row iw has no diagonal.
*     inform = 7  if there is not enough storage to finish the update.
*
*     On a successful exit (inform le 1),  locc(*)  will again be zero.
*
*        Jan 1985: Final f66 version.
*     09 May 1988: First f77 version.
*     ------------------------------------------------------------------

<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )<DIV ALIGN=right><INFO>lusol.f-&gt;5942</INFO></DIV>

      <DECLARE>double precision</DECLARE> <VARIABLE>Ltol</VARIABLE>
      <DECLARE>logical</DECLARE> <VARIABLE>swappd</VARIABLE>

      Ltol   = parmlu(2)
      small  = parmlu(3)
      uspace = parmlu(6)
      kbegin = kfirst
      swappd = .false.

*     We come back here from below if a row interchange is performed.<DIV ALIGN=right><INFO>lusol.f-&gt;5953</INFO></DIV>

  <A Name=lu7for_L_100>100</A> iw     = ip(klast)
      lenw   = lenr(iw)
      <TEST>if</TEST> (lenw   .eq.   0  ) go to 910
      lw1    = locr(iw)
      lw2    = lw1 + lenw - 1
      jfirst = iq(kbegin)
      <TEST>if</TEST> (kbegin .ge. klast) go to 700

*     Make sure there is room at the end of the row file<DIV ALIGN=right><INFO>lusol.f-&gt;5963</INFO></DIV>
*     in case row  iw  is moved there and fills in completely.

      minfre = n + 1
      nfree  = lena - lenL - lrow
      <TEST>if</TEST> (nfree .lt. minfre) then
         call <!new fthcall lu1rec><A Name='C_5968'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( m, .true., luparm, lrow, lena,
     $                a, indr, lenr, locr )</BRANCHEMENT>
         lw1    = locr(iw)
         lw2    = lw1 + lenw - 1
         nfree  = lena - lenL - lrow<DIV ALIGN=right><INFO>lusol.f-&gt;5973</INFO></DIV>
         <TEST>if</TEST> (nfree .lt. minfre) go to 970
      end if

*     Set markers on row  iw.

      <LOOP><A Name=C_5978>do</A></LOOP> <A Href=#lu7for_L_120>120</A> l = lw1, lw2
         j       = indr(l)
         locc(j) = l
  <A Name=lu7for_L_120>120</A>[<A Href=#C_5978>1</A>] continue


*     ==================================================================<DIV ALIGN=right><INFO>lusol.f-&gt;5985</INFO></DIV>
*     Main elimination loop.
*     ==================================================================
      kstart = kbegin
      kstop  = min( klast, n )

      <LOOP><A Name=C_5990>do</A></LOOP> <A Href=#lu7for_L_500>500</A> k  = kstart, kstop
         jfirst = iq(k)
         lfirst = locc(jfirst)
         <TEST>if</TEST> (lfirst .eq. 0) go to 490

*        Row  iw  has its first element in column  jfirst.<DIV ALIGN=right><INFO>lusol.f-&gt;5996</INFO></DIV>

         wj     = a(lfirst)
         <TEST>if</TEST> (k .eq. klast) go to 490

*        ---------------------------------------------------------------
*        We are about to use the first element of row  iv
*               to eliminate the first element of row  iw.
*        However, we may wish to interchange the rows instead,
*        to preserve stability and/or sparsity.
*        ---------------------------------------------------------------<DIV ALIGN=right><INFO>lusol.f-&gt;6006</INFO></DIV>
         iv     = ip(k)
         lenv   = lenr(iv)
         lv1    = locr(iv)
         vj     = zero
         <TEST>if</TEST> (lenv      .eq.   0   ) go to 150
         <TEST>if</TEST> (indr(lv1) .ne. jfirst) go to 150
         vj     = a(lv1)
         <TEST>if</TEST> (            swappd               ) go to 200
         <TEST>if</TEST> (Ltol * abs( wj )  .lt.  abs( vj )) go to 200
         <TEST>if</TEST> (Ltol * abs( vj )  .lt.  abs( wj )) go to 150<DIV ALIGN=right><INFO>lusol.f-&gt;6016</INFO></DIV>
         <TEST>if</TEST> (            lenv  .le.  lenw     ) go to 200

*        ---------------------------------------------------------------
*        Interchange rows  iv  and  iw.
*        ---------------------------------------------------------------
  <A Name=lu7for_L_150>150</A>    ip(klast) = iv
         ip(k)     = iw
         kbegin    = k
         swappd    = .true.
         go to <A Href=#lu7for_L_600>600</A><DIV ALIGN=right><INFO>lusol.f-&gt;6026</INFO></DIV>

*        ---------------------------------------------------------------
*        Delete the eliminated element from row  iw
*        by overwriting it with the last element.
*        ---------------------------------------------------------------
  <A Name=lu7for_L_200>200</A>    a(lfirst)    = a(lw2)
         jlast        = indr(lw2)
         indr(lfirst) = jlast
         indr(lw2)    = 0
         locc(jlast)  = lfirst<DIV ALIGN=right><INFO>lusol.f-&gt;6036</INFO></DIV>
         locc(jfirst) = 0
         lenw         = lenw - 1
         lenU         = lenU - 1
         <TEST>if</TEST> (lrow .eq. lw2) lrow = lrow - 1
         lw2          = lw2  - 1

*        ---------------------------------------------------------------
*        Form the multiplier and store it in the  L  file.
*        ---------------------------------------------------------------
         <TEST>if</TEST> (abs( wj ) .le. small) go to 490<DIV ALIGN=right><INFO>lusol.f-&gt;6046</INFO></DIV>
         amult   = - wj / vj
         l       = lena - lenL
         a(l)    = amult
         indr(l) = iv
         indc(l) = iw
         lenL    = lenL + 1

*        ---------------------------------------------------------------
*        Add the appropriate multiple of row  iv  to row  iw.
*        We use two different inner loops.  The first one is for the<DIV ALIGN=right><INFO>lusol.f-&gt;6056</INFO></DIV>
*        case where row  iw  is not at the end of storage.
*        ---------------------------------------------------------------
         <TEST>if</TEST> (lenv .eq. 1) go to 490
         lv2    = lv1 + 1
         lv3    = lv1 + lenv - 1
         <TEST>if</TEST> (lw2 .eq. lrow) go to 400

*        ...............................................................
*        This inner loop will be interrupted only if
*        fill-in occurs enough to bump into the next row.<DIV ALIGN=right><INFO>lusol.f-&gt;6066</INFO></DIV>
*        ...............................................................
         <LOOP><A Name=C_6067>do</A></LOOP> <A Href=#lu7for_L_350>350</A> lv = lv2, lv3
            jv     = indr(lv)
            lw     = locc(jv)
            <TEST>if</TEST> (lw .gt. 0) then

*              No fill-in.

               a(lw)  = a(lw)  +  amult * a(lv)
               <TEST>if</TEST> (abs( a(lw) ) .le. small) then<DIV ALIGN=right><INFO>lusol.f-&gt;6076</INFO></DIV>

*                 Delete small computed element.

                  a(lw)     = a(lw2)
                  j         = indr(lw2)
                  indr(lw)  = j
                  indr(lw2) = 0
                  locc(j)   = lw
                  locc(jv)  = 0
                  lenU      = lenU - 1<DIV ALIGN=right><INFO>lusol.f-&gt;6086</INFO></DIV>
                  lenw      = lenw - 1
                  lw2       = lw2  - 1
               end if
            else

*              Row  iw  doesn't have an element in column  jv  yet
*              so there is a fill-in.

               <TEST>if</TEST> (indr(lw2+1) .ne. 0) go to 360
               lenU      = lenU + 1<DIV ALIGN=right><INFO>lusol.f-&gt;6096</INFO></DIV>
               lenw      = lenw + 1
               lw2       = lw2  + 1
               a(lw2)    = amult * a(lv)
               indr(lw2) = jv
               locc(jv)  = lw2
            end if
  <A Name=lu7for_L_350>350</A>[<A Href=#C_6067>1</A>]    continue

         go to <A Href=#lu7for_L_490>490</A>

*        Fill-in interrupted the previous loop.<DIV ALIGN=right><INFO>lusol.f-&gt;6107</INFO></DIV>
*        Move row  iw  to the end of the row file.

  <A Name=lu7for_L_360>360</A>    lv2      = lv
         locr(iw) = lrow + 1

         <LOOP><A Name=C_6112>do</A></LOOP> <A Href=#lu7for_L_370>370</A> l = lw1, lw2
            lrow       = lrow + 1
            a(lrow)    = a(l)
            j          = indr(l)
            indr(l)    = 0<DIV ALIGN=right><INFO>lusol.f-&gt;6117</INFO></DIV>
            indr(lrow) = j
            locc(j)    = lrow
  <A Name=lu7for_L_370>370</A>[<A Href=#C_6112>1</A>]    continue

         lw1    = locr(iw)
         lw2    = lrow

*        ...............................................................
*        Inner loop with row  iw  at the end of storage.
*        ...............................................................<DIV ALIGN=right><INFO>lusol.f-&gt;6127</INFO></DIV>
  <A Name=lu7for_L_400>400</A>    <LOOP><A Name=C_6127>do</A></LOOP> <A Href=#lu7for_L_450>450</A> lv = lv2, lv3
            jv     = indr(lv)
            lw     = locc(jv)
            <TEST>if</TEST> (lw .gt. 0) then

*              No fill-in.

               a(lw)  = a(lw)  +  amult * a(lv)
               <TEST>if</TEST> (abs( a(lw) ) .le. small) then

*                 Delete small computed element.<DIV ALIGN=right><INFO>lusol.f-&gt;6138</INFO></DIV>

                  a(lw)     = a(lw2)
                  j         = indr(lw2)
                  indr(lw)  = j
                  indr(lw2) = 0
                  locc(j)   = lw
                  locc(jv)  = 0
                  lenU      = lenU - 1
                  lenw      = lenw - 1
                  lw2       = lw2  - 1<DIV ALIGN=right><INFO>lusol.f-&gt;6148</INFO></DIV>
               end if
            else

*              Row  iw  doesn't have an element in column  jv  yet
*              so there is a fill-in.

               lenU      = lenU + 1
               lenw      = lenw + 1
               lw2       = lw2  + 1
               a(lw2)    = amult * a(lv)<DIV ALIGN=right><INFO>lusol.f-&gt;6158</INFO></DIV>
               indr(lw2) = jv
               locc(jv)  = lw2
            end if
  <A Name=lu7for_L_450>450</A>[<A Href=#C_6127>1</A>]    continue

         lrow   = lw2

*        The  k-th  element of row  iw  has been processed.
*        Reset  swappd  before looking at the next element.

  <A Name=lu7for_L_490>490</A>    swappd = .false.<DIV ALIGN=right><INFO>lusol.f-&gt;6169</INFO></DIV>
  <A Name=lu7for_L_500>500</A>[<A Href=#C_5990>1</A>] continue

*     ==================================================================
*     End of main elimination loop.
*     ==================================================================

*     Cancel markers on row  iw.

  <A Name=lu7for_L_600>600</A> lenr(iw) = lenw
      <TEST>if</TEST> (lenw .eq. 0) go to 910<DIV ALIGN=right><INFO>lusol.f-&gt;6179</INFO></DIV>
      <LOOP><A Name=C_6179>do</A></LOOP> <A Href=#lu7for_L_620>620</A> l = lw1, lw2
         j       = indr(l)
         locc(j) = 0
  <A Name=lu7for_L_620>620</A>[<A Href=#C_6179>1</A>] continue

*     Move the diagonal element to the front of row  iw.
*     At this stage,  lenw gt 0  and  klast le n.

  <A Name=lu7for_L_700>700</A> <LOOP><A Name=C_6187>do</A></LOOP> <A Href=#lu7for_L_720>720</A> l = lw1, lw2
         ldiag = l<DIV ALIGN=right><INFO>lusol.f-&gt;6189</INFO></DIV>
         <TEST>if</TEST> (indr(l) .eq. jfirst) go to 730
  <A Name=lu7for_L_720>720</A>[<A Href=#C_6187>1</A>] continue
      go to <A Href=#lu7for_L_910>910</A>

  <A Name=lu7for_L_730>730</A> diag        = a(ldiag)
      a(ldiag)    = a(lw1)
      a(lw1)      = diag
      indr(ldiag) = indr(lw1)
      indr(lw1)   = jfirst

*     If an interchange is needed, repeat from the beginning with the<DIV ALIGN=right><INFO>lusol.f-&gt;6200</INFO></DIV>
*     new row  iw,  knowing that the opposite interchange cannot occur.

      <TEST>if</TEST> (swappd) go to 100
      inform = 0
      go to <A Href=#lu7for_L_950>950</A>

*     Singular.

  <A Name=lu7for_L_910>910</A> diag   = zero
      inform = 1<DIV ALIGN=right><INFO>lusol.f-&gt;6210</INFO></DIV>

*     Force a compression if the file for  U  is much longer than the
*     no. of nonzeros in  U  (i.e. if  lrow  is much bigger than  lenU).
*     This should prevent memory fragmentation when there is far more
*     memory than necessary  (i.e. when  lena  is huge).

  <A Name=lu7for_L_950>950</A> limit  = uspace * lenU + m + n + 1000
      <TEST>if</TEST> (lrow .gt. limit) then
         call <!new fthcall lu1rec><A Name='C_6218'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( m, .true., luparm, lrow, lena,
     $                a, indr, lenr, locr )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;6220</INFO></DIV>
      end if
      go to <A Href=#lu7for_L_990>990</A>

*     Not enough storage.

  <A Name=lu7for_L_970>970</A> inform = 7

*     Exit.

  <A Name=lu7for_L_990>990</A> return<DIV ALIGN=right><INFO>lusol.f-&gt;6230</INFO></DIV>

      end subroutine <a href="lusol_f_c.html#R_lu7for">lu7for</a> <COMMENT> subroutine lu7for
</COMMENT>
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine <!new fthrout lu7rnk><A Name='R_lu7rnk'><a target="index" href="lusol_f_i.html#R_lu7rnk">lu7rnk</a></A><ARGLIST>( m, n, jsing,
     $                   lena, luparm, parmlu,
     $                   lenL, lenU, lrow, nrank,
     $                   a, indc, indr, ip, iq, lenr, locc, locr,
     $                   inform, diag )</ARGLIST><DIV ALIGN=right><INFO>lusol.f-&gt;6240</INFO></DIV>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

*     ------------------------------------------------------------------
*     lu7rnk (check rank) assumes U is currently nrank by n
*     and determines if row nrank contains an acceptable pivot.<DIV ALIGN=right><INFO>lusol.f-&gt;6250</INFO></DIV>
*     If not, the row is deleted and nrank is decreased by 1.
*
*     jsing is an input parameter (not altered).  If jsing is positive,
*     column jsing has already been judged dependent.  A substitute
*     (if any) must be some other column.
*
*     -- Jul 1987: First version.
*     09 May 1988: First f77 version.
*     ------------------------------------------------------------------

<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )<DIV ALIGN=right><INFO>lusol.f-&gt;6261</INFO></DIV>

      Utol1    = parmlu(4)
      diag     = zero

*     Find Umax, the largest element in row nrank.

      iw       = ip(nrank)
      lenw     = lenr(iw)
      <TEST>if</TEST> (lenw .eq. 0) go to 400
      l1       = locr(iw)<DIV ALIGN=right><INFO>lusol.f-&gt;6271</INFO></DIV>
      l2       = l1 + lenw - 1
      Umax     = zero
      lmax     = l1

      <LOOP><A Name=C_6275>do</A></LOOP> <A Href=#lu7rnk_L_100>100</A> l = l1, l2
         <TEST>if</TEST> (Umax .lt. abs( a(l) )) then
             Umax   =  abs( a(l) )
             lmax   =  l
         end if
  <A Name=lu7rnk_L_100>100</A>[<A Href=#C_6275>1</A>] continue<DIV ALIGN=right><INFO>lusol.f-&gt;6281</INFO></DIV>

*     Find which column that guy is in (in pivotal order).
*     Interchange him with column nrank, then move him to be
*     the new diagonal at the front of row nrank.

      diag   = a(lmax)
      jmax   = indr(lmax)

      <LOOP><A Name=C_6289>do</A></LOOP> <A Href=#lu7rnk_L_300>300</A> kmax = nrank, n
         <TEST>if</TEST> (iq(kmax) .eq. jmax) go to 320<DIV ALIGN=right><INFO>lusol.f-&gt;6291</INFO></DIV>
  <A Name=lu7rnk_L_300>300</A>[<A Href=#C_6289>1</A>] continue

  <A Name=lu7rnk_L_320>320</A> iq(kmax)  = iq(nrank)
      iq(nrank) = jmax
      a(lmax)   = a(l1)
      a(l1)     = diag
      indr(lmax)= indr(l1)
      indr(l1)  = jmax

*     See if the new diagonal is big enough.<DIV ALIGN=right><INFO>lusol.f-&gt;6301</INFO></DIV>

      <TEST>if</TEST> (Umax .le. Utol1) go to 400
      <TEST>if</TEST> (jmax .eq. jsing) go to 400

*     ------------------------------------------------------------------
*     The rank stays the same.
*     ------------------------------------------------------------------
      inform = 0
      return

*     ------------------------------------------------------------------<DIV ALIGN=right><INFO>lusol.f-&gt;6312</INFO></DIV>
*     The rank decreases by one.
*     ------------------------------------------------------------------
  <A Name=lu7rnk_L_400>400</A> inform = -1
      nrank  = nrank - 1
      <TEST>if</TEST> (lenw .gt. 0) then

*        Delete row nrank from U.

         lenU     = lenU - lenw
         lenr(iw) = 0<DIV ALIGN=right><INFO>lusol.f-&gt;6322</INFO></DIV>
         <LOOP><A Name=C_6322>do</A></LOOP> <A Href=#lu7rnk_L_420>420</A> l = l1, l2
            indr(l) = 0
  <A Name=lu7rnk_L_420>420</A>[<A Href=#C_6322>1</A>]    continue

         <TEST>if</TEST> (l2 .eq. lrow) then

*           This row was at the end of the data structure.
*           We have to reset lrow.
*           Preceding rows might already have been deleted, so we
*           have to be prepared to go all the way back to 1.<DIV ALIGN=right><INFO>lusol.f-&gt;6332</INFO></DIV>

            <LOOP><A Name=C_6333>do</A></LOOP> <A Href=#lu7rnk_L_450>450</A> l = 1, l2
               <TEST>if</TEST> (indr(lrow) .gt. 0) go to 900
               lrow  = lrow - 1
  <A Name=lu7rnk_L_450>450</A>[<A Href=#C_6333>1</A>]       continue
         end if
      end if

  <A Name=lu7rnk_L_900>900</A> return

      end subroutine <a href="lusol_f_c.html#R_lu7rnk">lu7rnk</a> <COMMENT> subroutine lu7rnk
</COMMENT>
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine <!new fthrout lu7zap><A Name='R_lu7zap'><a target="index" href="lusol_f_i.html#R_lu7zap">lu7zap</a></A><ARGLIST>( m, n, jzap, kzap,
     $                   lena, lenU, lrow, nrank,
     $                   a, indr, ip, iq, lenr, locr )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>double precision</DECLARE> <VARIABLE>a(lena)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indr(lena), ip(m), iq(n), lenr(m)</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;6353</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>locr(m)</VARIABLE>

*     ------------------------------------------------------------------
*     lu7zap  eliminates all nonzeros in column  jzap  of  U.
*     It also sets  kzap  to the position of  jzap  in pivotal order.
*     Thus, on exit we have  iq(kzap) = jzap.
*
*     -- Jul 1987: nrank added.
*     10 May 1988: First f77 version.
*     ------------------------------------------------------------------<DIV ALIGN=right><INFO>lusol.f-&gt;6363</INFO></DIV>

      <LOOP><A Name=C_6364>do</A></LOOP> <A Href=#lu7zap_L_100>100</A> k  = 1, nrank
         i      = ip(k)
         leni   = lenr(i)
         <TEST>if</TEST> (leni .eq. 0) go to 90
         lr1    = locr(i)
         lr2    = lr1 + leni - 1
         <LOOP><A Name=C_6370>do</A></LOOP> <A Href=#lu7zap_L_50>50</A> l = lr1, lr2
            <TEST>if</TEST> (indr(l) .eq. jzap) go to 60
   <A Name=lu7zap_L_50>50</A>[<A Href=#C_6370>1</A>]    continue<DIV ALIGN=right><INFO>lusol.f-&gt;6373</INFO></DIV>
         go to <A Href=#lu7zap_L_90>90</A>

*        Delete the old element.

   <A Name=lu7zap_L_60>60</A>    a(l)      = a(lr2)
         indr(l)   = indr(lr2)
         indr(lr2) = 0
         lenr(i)   = leni - 1
         lenU      = lenU - 1

*        Stop if we know there are no more rows containing  jzap.<DIV ALIGN=right><INFO>lusol.f-&gt;6384</INFO></DIV>

   <A Name=lu7zap_L_90>90</A>    kzap   = k
         <TEST>if</TEST> (iq(k) .eq. jzap) go to 800
  <A Name=lu7zap_L_100>100</A>[<A Href=#C_6364>1</A>] continue

*     nrank must be smaller than n because we haven't found kzap yet.

      <LOOP><A Name=C_6391>do</A></LOOP> <A Href=#lu7zap_L_200>200</A> k = nrank+1, n
         kzap  = k
         <TEST>if</TEST> (iq(k) .eq. jzap) go to 800<DIV ALIGN=right><INFO>lusol.f-&gt;6394</INFO></DIV>
  <A Name=lu7zap_L_200>200</A>[<A Href=#C_6391>1</A>] continue

*     See if we zapped the last element in the file.

  <A Name=lu7zap_L_800>800</A> <TEST>if</TEST> (lrow .gt. 0) then
         <TEST>if</TEST> (indr(lrow) .eq. 0) lrow = lrow - 1
      end if

      end subroutine <a href="lusol_f_c.html#R_lu7zap">lu7zap</a> <COMMENT> subroutine lu7zap</COMMENT>
*************************************************************************<DIV ALIGN=right><INFO>lusol.f-&gt;6404</INFO></DIV>

<COMMENT>     File  lusol7b.f

     lu7asv   lu7bak

     These routines are used by the update routines in lusol8b.f.

 08 Jun 2004: lusol7b.f is essentially lu7b.for from VMS days.
              integer*4 changed to integer  .
<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu7asv><A Name='R_lu7asv'><a target="index" href="lusol_f_i.html#R_lu7asv">lu7asv</a></A><ARGLIST>( m, n, iv, lenw, lw1, lw2, marker, wmult,
     $                   lena, luparm, parmlu,
     $                   lenu, lrow,
     $                   a, indc, indr, lenr, locc, locr )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), lenr(m)</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;6424</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

<COMMENT><HR></HR>
     lu7asv (Add Sparse Vectors) sets  v  =  v  +  wmult * w,
     where  v  and  w  are sparse vectors and  wmult  is a scalar.
     v  is row  iv  of an  m by n  matrix  U  stored in  a(*), indr(*).
     w  is stored in locations  lw1  thru  lw2  of  a(*), indr(*).

     Assumptions...

  1. There are at least  n  free locations of storage in  a(*), indr(*)
     beyond the current point  lrow.  This means that  v  can be moved
     to the end of storage if need be, and there is room for fill-in.

  2. The nonzeros of  w  are marked by  locc(*)  in the usual way.

  3. The array  indc(*)  is parallel to  indr(*),  and has been
     initialized in the locations corresponding to  w  to some value
     other than the input parameter  marker.

     -- Feb 1985: Last  F66 version.
     10 May 1988: First F77 version.
<HR></HR>
</COMMENT>
      <DECLARE>logical</DECLARE> <VARIABLE>atend</VARIABLE>

      <TEST>if</TEST> (lenw .eq. 0) return
      small  = parmlu(3)
      lenv   = lenr(iv)
      <TEST>if</TEST> (lenv .eq. 0) locr(iv) = lrow + 1
      lv1    = locr(iv)<DIV ALIGN=right><INFO>lusol.f-&gt;6455</INFO></DIV>
      lv2    = lv1 + lenv - 1
      last   = lv2
      lenu   = lenu - lenv
      atend  = last .eq. lrow

<COMMENT><HR></HR>
     First, modify existing elements  v(j)  if  w(j)  is nonzero,
     and flag those elements of  w  by setting  indc(*) = marker.
     To facilitate removal of computed zeros, we work backwards
     through the elements of  v  and replace negligible new elements
     by the current last element of  v  (which will always be in the
     spot pointed to by the integer  last).
<HR></HR></COMMENT>
      <TEST>if</TEST> (lenv .eq. 0) go to 420
      nw     = 0

      <LOOP><A Name=C_6471>do</A></LOOP> lv = lv2, lv1, -1
         jv     = indr(lv)
         lw     = locc(jv)
         <TEST>if</TEST> (lw .gt. 0) then<DIV ALIGN=right><INFO>lusol.f-&gt;6475</INFO></DIV>
            nw       = nw + 1
            indc(lw) = marker
            a(lv)    = a(lv)  +  wmult * a(lw)
            <TEST>if</TEST> (abs( a(lv) ) .le. small) then

<COMMENT> Delete small element by moving the last element of  v.
</COMMENT>
               a(lv)      = a(last)
               indr(lv)   = indr(last)
               indr(last) = 0<DIV ALIGN=right><INFO>lusol.f-&gt;6485</INFO></DIV>
               last       = last - 1
            end if
         end if
      <A Href=#C_6471>end do</A>

<COMMENT><HR></HR>
     If all elements of  w  have just been accessed, we are done.
     Otherwise, see if there is enough room at the end of  v
     to accommodate the fill-in.
<HR></HR></COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;6495</INFO></DIV>
      <TEST>if</TEST> (nw .eq. lenw) go to 500
      <TEST>if</TEST> (   atend    ) go to 420
      l1     = last + 1
      l2     = last + (lenw - nw)

      <LOOP><A Name=C_6500>do</A></LOOP> l = l1, l2
         <TEST>if</TEST> (indr(l) .gt. 0) go to 400
      <A Href=#C_6500>end do</A>
      go to <A Href=#lu7asv_L_420>420</A>

<COMMENT><HR></HR>
     We must move  v  to the end of storage.
<HR></HR></COMMENT>
  <A Name=lu7asv_L_400>400</A> atend    = .true.
      l1       = lv1
      l2       = last
      lenv     = last - lv1 + 1
      lv1      = lrow + 1
      last     = lrow + lenv
      locr(iv) = lv1

      <LOOP><A Name=C_6516>do</A></LOOP> l = l1, l2<DIV ALIGN=right><INFO>lusol.f-&gt;6517</INFO></DIV>
         lrow       = lrow + 1
         a(lrow)    = a(l)
         indr(lrow) = indr(l)
         indr(l)    = 0
      <A Href=#C_6516>end do</A>

<COMMENT><HR></HR>
     Now generate the fill-ins in  v
     using the elements of  w  that were previously skipped.
<HR></HR></COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;6527</INFO></DIV>
  <A Name=lu7asv_L_420>420</A> <LOOP><A Name=C_6527>do</A></LOOP> lw = lw1, lw2
         <TEST>if</TEST> (indc(lw) .ne. marker) then
            last       = last + 1
            a(last)    = wmult * a(lw)
            indr(last) = indr(lw)
         end if
      <A Href=#C_6527>end do</A>

<COMMENT><HR></HR>
     Reset the length of  v  and the total nonzeros in  U.
<HR></HR></COMMENT>
  <A Name=lu7asv_L_500>500</A> lenv       = last  - lv1 + 1
      lenr(iv)   = lenv
      lenu       = lenu + lenv
      <TEST>if</TEST> (atend) lrow = last

      end subroutine <a href="lusol_f_c.html#R_lu7asv">lu7asv</a> <COMMENT> subroutine lu7asv

<HR></HR>
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;6547</INFO></DIV>
      subroutine <!new fthrout lu7bak><A Name='R_lu7bak'><a target="index" href="lusol_f_i.html#R_lu7bak">lu7bak</a></A><ARGLIST>( m, n, kfirst, klast, c,
     $                   lena, luparm, parmlu,
     $                   lenl, lenu, lrow,
     $                   a, indc, indr, ip, iq, lenr, locc, locr,
     $                   inform )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena), c(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n), lenr(m)</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;6557</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

<COMMENT><HR></HR>
     lu7bak  (Backward Sweep) updates the LU factorization  A = L*U
     when part of the column vector  c  is reduced to a multiple of
     a unit vector by a backward sweep of stabilized row operations
     of the form

        LSWEEP * c  =  c(iw) * e(iw).

     Elements  ip(kfirst+1),  ip(kfirst+2),  ...,  ip(klast)  of  c
     are involved.  It is assumed that  (kfirst + 1) &lt; klast.
     The matrices  L  and  U  are updated to become

        L(new)  =  L * LSWEEP(inverse)    and    U(new)  =  LSWEEP * U

     where  ip * U(new) * iq  is upper triangular except for the
     row  iw = ip(klast).  The row permutation  ip  is updated
     accordingly.  The column permutation  iq  is not altered.

     Row  iw  is held in compact form like the other rows of  U.

     On entry, all elements of  locc  are assumed to be zero.
     On a successful exit (inform = 0) they will again be zero.

     -- Feb 1985: First version.
     10 May 1988: First F77 version.
<HR></HR>
</COMMENT>
      <DECLARE>double precision</DECLARE> <VARIABLE>lmax</VARIABLE>
      <DECLARE>logical</DECLARE> <VARIABLE>cmprss, first, swap</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;6588</INFO></DIV>

      lmax   = parmlu(2)
      small  = parmlu(3)
      lfree  = lena - lenl
      iw     = ip(klast)
      cw     = c(iw)
      lenw   = lenr(iw)

<COMMENT><HR></HR>
     Eliminate the nonzeros of  c  backwards.
<HR></HR></COMMENT>
      first  = .true.

      <LOOP><A Name=C_6601>do</A></LOOP> <A Href=#lu7bak_L_500>500</A> k  = klast-1, kfirst+1, -1
         iv     = ip(k)
         cv     = c(iv)
         <TEST>if</TEST> (abs( cv ) .le. small) go to 500

<COMMENT> cv  has to be eliminated.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;6608</INFO></DIV>
         cmprss = .false.
         swap   = .false.

<COMMENT><HR></HR>
        Compress storage if necessary, so there will be room if
        v  has to be moved to the end.  (If we waited until  v  is
        actually moved, the markers on  w  would have to be reset.)
<HR></HR></COMMENT>
         minfre = n + 1
         nfree  = lfree - lrow<DIV ALIGN=right><INFO>lusol.f-&gt;6618</INFO></DIV>
         <TEST>if</TEST> (nfree .ge. minfre) go to 200
         call <!new fthcall lu1rec><A Name='C_6619'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( m, .true., luparm, lrow, lena, a,indr,lenr,locr )</BRANCHEMENT>
         cmprss = .true.
         nfree  = lfree - lrow
         <TEST>if</TEST> (nfree .lt. minfre) go to 970

<COMMENT><HR></HR>
        We are about to set  v  =  v  +  ( - cv/cw ) * w.
        See if rows  v  and  w  should be interchanged first.
<HR></HR></COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;6628</INFO></DIV>
  <A Name=lu7bak_L_200>200</A>    <TEST>if</TEST> (lmax * abs( cv )  .lt.  abs( cw )) go to 210
         <TEST>if</TEST> (lmax * abs( cw )  .lt.  abs( cv )) go to 220
         <TEST>if</TEST> (lenr(iv)          .lt.  lenw     ) go to 220

  <A Name=lu7bak_L_210>210</A>    <TEST>if</TEST> (first             .or.  cmprss   ) go to 250
         go to <A Href=#lu7bak_L_300>300</A>

<COMMENT><HR></HR>
        Interchange rows  iv  and  iw.
<HR></HR></COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;6638</INFO></DIV>
  <A Name=lu7bak_L_220>220</A>    swap      = .true.
         i         = iv
         iv        = iw
         iw        = i
         w         = cv
         cv        = cw
         cw        = w
         ip(k)     = iv
         ip(klast) = iw
         <TEST>if</TEST> (first  .or.  lenw .eq. 0) go to 250<DIV ALIGN=right><INFO>lusol.f-&gt;6648</INFO></DIV>

<COMMENT> Cancel the markers on the old row  iw.
</COMMENT>
         <LOOP><A Name=C_6651>do</A></LOOP> <A Href=#lu7bak_L_230>230</A> l = lw1, lw2
            jw       = indr(l)
            locc(jw) = 0
  <A Name=lu7bak_L_230>230</A>[<A Href=#C_6651>1</A>]    continue

<COMMENT><HR></HR>
        Set markers on the new row  iw.
        This happens if  first,  cmprss,  or  swap.
<HR></HR></COMMENT>
  <A Name=lu7bak_L_250>250</A>    lenw   = lenr(iw)
         <TEST>if</TEST> (lenw .eq. 0) go to 300
         lw1    = locr(iw)
         lw2    = lw1 + lenw - 1

         <LOOP><A Name=C_6665>do</A></LOOP> <A Href=#lu7bak_L_260>260</A> lw = lw1, lw2
            jw       = indr(lw)
            locc(jw) = lw<DIV ALIGN=right><INFO>lusol.f-&gt;6668</INFO></DIV>
            indc(lw) = 0
  <A Name=lu7bak_L_260>260</A>[<A Href=#C_6665>1</A>]    continue

<COMMENT><HR></HR>
        Form the multiplier and store it in the L file.
<HR></HR></COMMENT>
  <A Name=lu7bak_L_300>300</A>    first       = .false.
         wmult       = - cv / cw
         a(lfree)    = wmult
         indr(lfree) = iw<DIV ALIGN=right><INFO>lusol.f-&gt;6678</INFO></DIV>
         indc(lfree) = iv
         lenl        = lenl  + 1
         lfree       = lfree - 1

<COMMENT><HR></HR>
        Set  v  =  v  +  wmult * w.
<HR></HR></COMMENT>
         <TEST>if</TEST> (lenw .gt. 0) then
            call <!new fthcall lu7asv><A Name='C_6686'><a href="lusol_f_c.html#R_lu7asv">lu7asv</a></A><BRANCHEMENT>( m, n, iv, lenw, lw1, lw2, k, wmult,
     $                   lena, luparm, parmlu,
     $                   lenu, lrow,
     $                   a, indc, indr, lenr, locc, locr )</BRANCHEMENT>
         end if

<COMMENT><HR></HR>
        If there was a swap, make sure the diagonal of  v  is first.
<HR></HR></COMMENT>
         <TEST>if</TEST> (.not. swap ) go to 500
         lenv   = lenr(iv)
         <TEST>if</TEST> (lenv .eq. 0) go to 500<DIV ALIGN=right><INFO>lusol.f-&gt;6698</INFO></DIV>
         <TEST>if</TEST> ( k   .gt. n) go to 500
         jdiag  = iq(k)
         lv1    = locr(iv)
         lv2    = lv1 + lenv - 1

         <LOOP><A Name=C_6703>do</A></LOOP> l = lv1, lv2
            <TEST>if</TEST> (indr(l) .eq. jdiag) go to 470
         <A Href=#C_6703>end do</A>
         go to <A Href=#lu7bak_L_500>500</A>

  <A Name=lu7bak_L_470>470</A>    indr(l)   = indr(lv1)<DIV ALIGN=right><INFO>lusol.f-&gt;6709</INFO></DIV>
         indr(lv1) = jdiag
         diag      = a(l)
         a(l)      = a(lv1)
         a(lv1)    = diag
  <A Name=lu7bak_L_500>500</A>[<A Href=#C_6601>1</A>] continue

<COMMENT><HR></HR>
     End of main elimination loop.
<HR></HR>

 Cancel the markers on  w,  unless they were never set.
</COMMENT>
      <TEST>if</TEST> (first  .or.  lenw .eq. 0) go to 900
      <LOOP><A Name=C_6722>do</A></LOOP> lw = lw1, lw2
         jw       = indr(lw)
         locc(jw) = 0
      <A Href=#C_6722>end do</A>

<COMMENT> Successful update.
</COMMENT>
  <A Name=lu7bak_L_900>900</A> inform = 0<DIV ALIGN=right><INFO>lusol.f-&gt;6730</INFO></DIV>
      go to <A Href=#lu7bak_L_990>990</A>

<COMMENT> Not enough storage.
</COMMENT>
  <A Name=lu7bak_L_970>970</A> inform = 7

<COMMENT> Exit.
</COMMENT>
  <A Name=lu7bak_L_990>990</A> return

      end subroutine <a href="lusol_f_c.html#R_lu7bak">lu7bak</a> <COMMENT> subroutine lu7bak</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;6741</INFO></DIV>
************************************************************************
*
*     File  lusol8a.f
*
*     lu8rpc
*
*     Sparse LU update: Replace Column
*     LUSOL's sparse implementation of the Bartels-Golub update.
*
* 01 May 2002: Derived from LUSOL's original lu8a.f file.<DIV ALIGN=right><INFO>lusol.f-&gt;6751</INFO></DIV>
* 01 May 2002: Current version of lusol8a.f.
* 15 Sep 2004: Test nout. gt. 0 to protect write statements.
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine <!new fthrout lu8rpc><A Name='R_lu8rpc'><a target="index" href="lusol_f_i.html#R_lu8rpc">lu8rpc</a></A><ARGLIST>( mode1, mode2, m, n, jrep, v, w,
     $                   lena, luparm, parmlu,
     $                   a, indc, indr, ip, iq,
     $                   lenc, lenr, locc, locr,
     $                   inform, diag, vnorm )</ARGLIST>

      implicit           double precision(a-h,o-z)<DIV ALIGN=right><INFO>lusol.f-&gt;6762</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena), v(m), w(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>lenc(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

*     ------------------------------------------------------------------
*     lu8rpc  updates the LU factorization  A = L*U  when column  jrep
*     is replaced by some vector  a(new).
*<DIV ALIGN=right><INFO>lusol.f-&gt;6772</INFO></DIV>
*     lu8rpc  is an implementation of the Bartels-Golub update,
*     designed for the case where A is rectangular and/or singular.
*     L is a product of stabilized eliminations (m x m, nonsingular).
*     P U Q is upper trapezoidal (m x n, rank nrank).
*
*     If  mode1 = 0,  the old column is taken to be zero
*                     (so it does not have to be removed from  U).
*
*     If  mode1 = 1,  the old column need not have been zero.
*<DIV ALIGN=right><INFO>lusol.f-&gt;6782</INFO></DIV>
*     If  mode2 = 0,  the new column is taken to be zero.
*                     v(*)  is not used or altered.
*
*     If  mode2 = 1,  v(*)  must contain the new column  a(new).
*                     On exit,  v(*)  will satisfy  L*v = a(new).
*
*     If  mode2 = 2,  v(*)  must satisfy  L*v = a(new).
*
*     The array  w(*)  is not used or altered.
*<DIV ALIGN=right><INFO>lusol.f-&gt;6792</INFO></DIV>
*     On entry, all elements of  locc  are assumed to be zero.
*     On a successful exit (inform ne 7), this will again be true.
*
*     On exit:
*     inform = -1  if the rank of U decreased by 1.
*     inform =  0  if the rank of U stayed the same.
*     inform =  1  if the rank of U increased by 1.
*     inform =  2  if the update seemed to be unstable
*                  (diag much bigger than vnorm).
*     inform =  7  if the update was not completed (lack of storage).<DIV ALIGN=right><INFO>lusol.f-&gt;6802</INFO></DIV>
*     inform =  8  if jrep is not between 1 and n.
*
*     -- Jan 1985: Original F66 version.
*     -- Jul 1987: Modified to maintain U in trapezoidal form.
*     10 May 1988: First f77 version.
*     16 Oct 2000: Added test for instability (inform = 2).
*     ------------------------------------------------------------------

      <DECLARE>logical</DECLARE> <VARIABLE>singlr</VARIABLE>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )<DIV ALIGN=right><INFO>lusol.f-&gt;6812</INFO></DIV>

      nout   = luparm(1)
      lprint = luparm(2)
      nrank  = luparm(16)
      lenL   = luparm(23)
      lenU   = luparm(24)
      lrow   = luparm(25)
      Utol1  = parmlu(4)
      Utol2  = parmlu(5)
      nrank0 = nrank<DIV ALIGN=right><INFO>lusol.f-&gt;6822</INFO></DIV>
      diag   = zero
      vnorm  = zero
      <TEST>if</TEST> (jrep .lt. 1) go to 980
      <TEST>if</TEST> (jrep .gt. n) go to 980

*     ------------------------------------------------------------------
*     If mode1 = 0, there are no elements to be removed from  U
*     but we still have to set  krep  (using a backward loop).
*     Otherwise, use lu7zap to remove column  jrep  from  U
*     and set  krep  at the same time.<DIV ALIGN=right><INFO>lusol.f-&gt;6832</INFO></DIV>
*     ------------------------------------------------------------------
      <TEST>if</TEST> (mode1 .eq. 0) then
         krep   = n + 1

   <A Name=lu8rpc_L_10>10</A>    krep   = krep - 1
         <TEST>if</TEST> (iq(krep) .ne. jrep) go to 10
      else
         call <!new fthcall lu7zap><A Name='C_6839'><a href="lusol_f_c.html#R_lu7zap">lu7zap</a></A><BRANCHEMENT>( m, n, jrep, krep,
     $                lena, lenU, lrow, nrank,
     $                a, indr, ip, iq, lenr, locr )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;6842</INFO></DIV>
      end if

*     ------------------------------------------------------------------
*     Insert a new column of u and find klast.
*     ------------------------------------------------------------------

      <TEST>if</TEST> (mode2 .eq. 0) then
         klast  = 0
      else
         <TEST>if</TEST> (mode2 .eq. 1) then<DIV ALIGN=right><INFO>lusol.f-&gt;6852</INFO></DIV>

*           Transform v = a(new) to satisfy  L*v = a(new).

            call <!new fthcall lu6sol><A Name='C_6855'><a href="lusol_f_c.html#R_lu6sol">lu6sol</a></A><BRANCHEMENT>( 1, m, n, v, w, lena, luparm, parmlu,
     $                   a, indc, indr, ip, iq,
     $                   lenc, lenr, locc, locr, inform )</BRANCHEMENT>
         end if

*        Insert into  U  any nonzeros in the top of  v.
*        row  ip(klast)  will contain the last nonzero in pivotal order.<DIV ALIGN=right><INFO>lusol.f-&gt;6862</INFO></DIV>
*        Note that  klast  will be in the range  ( 0, nrank ).

         call <!new fthcall lu7add><A Name='C_6864'><a href="lusol_f_c.html#R_lu7add">lu7add</a></A><BRANCHEMENT>( m, n, jrep, v,
     $                lena, luparm, parmlu,
     $                lenL, lenU, lrow, nrank,
     $                a, indr, ip, lenr, locr,
     $                inform, klast, vnorm )</BRANCHEMENT>
         <TEST>if</TEST> (inform .eq. 7) go to 970
      end if

*     ------------------------------------------------------------------<DIV ALIGN=right><INFO>lusol.f-&gt;6873</INFO></DIV>
*     In general, the new column causes U to look like this:
*
*                 krep        n                 krep  n
*
*                ....a.........          ..........a...
*                 .  a        .           .        a  .
*                  . a        .            .       a  .
*                   .a        .             .      a  .
*        P U Q =     a        .    or        .     a  .
*                    b.       .               .    a  .<DIV ALIGN=right><INFO>lusol.f-&gt;6883</INFO></DIV>
*                    b .      .                .   a  .
*                    b  .     .                 .  a  .
*                    b   ......                  ..a...  nrank
*                    c                             c
*                    c                             c
*                    c                             c     m
*
*     klast points to the last nonzero "a" or "b".
*     klast = 0 means all "a" and "b" entries are zero.
*     ------------------------------------------------------------------<DIV ALIGN=right><INFO>lusol.f-&gt;6893</INFO></DIV>

      <TEST>if</TEST> (mode2 .eq. 0) then
         <TEST>if</TEST> (krep .gt. nrank) go to 900
      else if (nrank .lt. m) then

*        Eliminate any "c"s (in either case).
*        Row nrank + 1 may end up containing one nonzero.

         call <!new fthcall lu7elm><A Name='C_6901'><a href="lusol_f_c.html#R_lu7elm">lu7elm</a></A><BRANCHEMENT>( m, n, jrep, v,
     $                lena, luparm, parmlu,
     $                lenL, lenU, lrow, nrank,
     $                a, indc, indr, ip, iq, lenr, locc, locr,
     $                inform, diag )</BRANCHEMENT>
         <TEST>if</TEST> (inform .eq. 7) go to 970

         <TEST>if</TEST> (inform .eq. 1) then

*           The nonzero is apparently significant.
*           Increase nrank by 1 and make klast point to the bottom.

            nrank = nrank + 1<DIV ALIGN=right><INFO>lusol.f-&gt;6914</INFO></DIV>
            klast = nrank
         end if
      end if

      <TEST>if</TEST> (nrank .lt. n) then

*        The column rank is low.
*
*        In the first case, we want the new column to end up in
*        position nrank, so the trapezoidal columns will have a chance<DIV ALIGN=right><INFO>lusol.f-&gt;6924</INFO></DIV>
*        later on (in lu7rnk) to pivot in that position.
*
*        Otherwise the new column is not part of the triangle.  We
*        swap it into position nrank so we can judge it for singularity.
*        lu7rnk might choose some other trapezoidal column later.

         <TEST>if</TEST> (krep .lt. nrank) then
            klast     = nrank
         else
            iq(krep ) = iq(nrank)<DIV ALIGN=right><INFO>lusol.f-&gt;6934</INFO></DIV>
            iq(nrank) = jrep
            krep      = nrank
         end if
      end if

*     ------------------------------------------------------------------
*     If krep .lt. klast, there are some "b"s to eliminate:
*
*                  krep
*<DIV ALIGN=right><INFO>lusol.f-&gt;6944</INFO></DIV>
*                ....a.........
*                 .  a        .
*                  . a        .
*                   .a        .
*        P U Q =     a        .  krep
*                    b.       .
*                    b .      .
*                    b  .     .
*                    b   ......  nrank
*<DIV ALIGN=right><INFO>lusol.f-&gt;6954</INFO></DIV>
*     If krep .eq. klast, there are no "b"s, but the last "a" still
*     has to be moved to the front of row krep (by lu7for).
*     ------------------------------------------------------------------

      <TEST>if</TEST> (krep .le. klast) then

*        Perform a cyclic permutation on the current pivotal order,
*        and eliminate the resulting row spike.  krep becomes klast.
*        The final diagonal (if any) will be correctly positioned at
*        the front of the new krep-th row.  nrank stays the same.<DIV ALIGN=right><INFO>lusol.f-&gt;6964</INFO></DIV>

         call <!new fthcall lu7cyc><A Name='C_6965'><a href="lusol_f_c.html#R_lu7cyc">lu7cyc</a></A><BRANCHEMENT>( krep, klast, ip )</BRANCHEMENT>
         call <!new fthcall lu7cyc><A Name='C_6966'><a href="lusol_f_c.html#R_lu7cyc">lu7cyc</a></A><BRANCHEMENT>( krep, klast, iq )</BRANCHEMENT>

         call <!new fthcall lu7for><A Name='C_6968'><a href="lusol_f_c.html#R_lu7for">lu7for</a></A><BRANCHEMENT>( m, n, krep, klast,
     $                lena, luparm, parmlu,
     $                lenL, lenU, lrow,
     $                a, indc, indr, ip, iq, lenr, locc, locr,
     $                inform, diag )</BRANCHEMENT>
         <TEST>if</TEST> (inform .eq. 7) go to 970<DIV ALIGN=right><INFO>lusol.f-&gt;6974</INFO></DIV>
         krep   = klast

*        Test for instability (diag much bigger than vnorm).

         singlr = vnorm .lt. Utol2 * abs( diag )
         <TEST>if</TEST> ( singlr ) go to 920
      end if

*     ------------------------------------------------------------------
*     Test for singularity in column krep (where krep .le. nrank).<DIV ALIGN=right><INFO>lusol.f-&gt;6984</INFO></DIV>
*     ------------------------------------------------------------------

      diag   = zero
      iw     = ip(krep)
      singlr = lenr(iw) .eq. 0

      <TEST>if</TEST> (.not. singlr) then
         l1     = locr(iw)
         j1     = indr(l1)
         singlr = j1 .ne. jrep<DIV ALIGN=right><INFO>lusol.f-&gt;6994</INFO></DIV>

         <TEST>if</TEST> (.not. singlr) then
            diag   = a(l1)
            singlr = abs( diag ) .le. Utol1          .or.
     $               abs( diag ) .le. Utol2 * vnorm
         end if
      end if

      <TEST>if</TEST> ( singlr  .and.  krep .lt. nrank ) then

*        Perform cyclic permutations to move column jrep to the end.<DIV ALIGN=right><INFO>lusol.f-&gt;7005</INFO></DIV>
*        Move the corresponding row to position nrank
*        then eliminate the resulting row spike.

         call <!new fthcall lu7cyc><A Name='C_7008'><a href="lusol_f_c.html#R_lu7cyc">lu7cyc</a></A><BRANCHEMENT>( krep, nrank, ip )</BRANCHEMENT>
         call <!new fthcall lu7cyc><A Name='C_7009'><a href="lusol_f_c.html#R_lu7cyc">lu7cyc</a></A><BRANCHEMENT>( krep, n    , iq )</BRANCHEMENT>

         call <!new fthcall lu7for><A Name='C_7011'><a href="lusol_f_c.html#R_lu7for">lu7for</a></A><BRANCHEMENT>( m, n, krep, nrank,
     $                lena, luparm, parmlu,
     $                lenL, lenU, lrow,
     $                a, indc, indr, ip, iq, lenr, locc, locr,
     $                inform, diag )</BRANCHEMENT>
         <TEST>if</TEST> (inform .eq. 7) go to 970
      end if

*     Find the best column to be in position nrank.
*     If singlr, it can't be the new column, jrep.
*     If nothing satisfactory exists, nrank will be decreased.

      <TEST>if</TEST> ( singlr  .or.  nrank .lt. n ) then
         jsing  = 0<DIV ALIGN=right><INFO>lusol.f-&gt;7025</INFO></DIV>
         <TEST>if</TEST> ( singlr ) jsing = jrep

         call <!new fthcall lu7rnk><A Name='C_7027'><a href="lusol_f_c.html#R_lu7rnk">lu7rnk</a></A><BRANCHEMENT>( m, n, jsing,
     $                lena, luparm, parmlu,
     $                lenL, lenU, lrow, nrank,
     $                a, indc, indr, ip, iq, lenr, locc, locr,
     $                inform, diag )</BRANCHEMENT>
      end if

*     ------------------------------------------------------------------<DIV ALIGN=right><INFO>lusol.f-&gt;7035</INFO></DIV>
*     Set inform for exit.
*     ------------------------------------------------------------------

  <A Name=lu8rpc_L_900>900</A> <TEST>if</TEST> (nrank .eq. nrank0) then
         inform =  0
      else if (nrank .lt. nrank0) then
         inform = -1
         <TEST>if</TEST> (nrank0 .eq. n) then
            <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &           write(nout, 1100) jrep, diag<DIV ALIGN=right><INFO>lusol.f-&gt;7045</INFO></DIV>
         end if
      else
         inform =  1
      end if
      go to <A Href=#lu8rpc_L_990>990</A>

*     Instability.

  <A Name=lu8rpc_L_920>920</A> inform = 2
      <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)<DIV ALIGN=right><INFO>lusol.f-&gt;7055</INFO></DIV>
     &     write(nout, 1200) jrep, diag
      go to <A Href=#lu8rpc_L_990>990</A>

*     Not enough storage.

  <A Name=lu8rpc_L_970>970</A> inform = 7
      <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &     write(nout, 1700) lena
      go to <A Href=#lu8rpc_L_990>990</A>

*     jrep  is out of range.<DIV ALIGN=right><INFO>lusol.f-&gt;7066</INFO></DIV>

  <A Name=lu8rpc_L_980>980</A> inform = 8
      <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &     write(nout, 1800) m, n, jrep

*     Exit.

  <A Name=lu8rpc_L_990>990</A> luparm(10) = inform
      luparm(15) = luparm(15) + 1
      luparm(16) = nrank<DIV ALIGN=right><INFO>lusol.f-&gt;7076</INFO></DIV>
      luparm(23) = lenL
      luparm(24) = lenU
      luparm(25) = lrow
      return

 <A Name=lu8rpc_L_1100>1100</A> format(/ ' lu8rpc  warning.  Singularity after replacing column.',
     $       '    jrep =', i8, '    diag =', 1p, e12.2 )
 <A Name=lu8rpc_L_1200>1200</A> format(/ ' lu8rpc  warning.  Instability after replacing column.',
     $       '    jrep =', i8, '    diag =', 1p, e12.2 )
 <A Name=lu8rpc_L_1700>1700</A> format(/ ' lu8rpc  error...  Insufficient storage.',<DIV ALIGN=right><INFO>lusol.f-&gt;7086</INFO></DIV>
     $         '    lena =', i8)
 <A Name=lu8rpc_L_1800>1800</A> format(/ ' lu8rpc  error...  jrep  is out of range.',
     $         '    m =', i8, '    n =', i8, '    jrep =', i8)

      end subroutine <a href="lusol_f_c.html#R_lu8rpc">lu8rpc</a> <COMMENT> subroutine lu8rpc
<HR></HR>

     file  lusol8b.f

     lu8adc   lu8adr   lu8dlc   lu8dlr   lu8mod   lu8rpr

     These routines call lu7asv and lu7bak in lusol7b.f.

 08 Jun 2004: lusol8b.f is essentially lu8b.for from VMS days.
              integer*4 changed to integer  .
 15 Sep 2004: Test nout. gt. 0 to protect write statements.</COMMENT>
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine <!new fthrout lu8adc><A Name='R_lu8adc'><a target="index" href="lusol_f_i.html#R_lu8adc">lu8adc</a></A><ARGLIST>( mode, m, n, v, w,
     $                   lena, luparm, parmlu,
     $                   a, indc, indr, ip, iq,
     $                   lenc, lenr, locc, locr,
     $                   inform, diag, vnorm )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena), v(m), w(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>lenc(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;7116</INFO></DIV>

<COMMENT><HR></HR>
     lu8adc  updates the LU factorization  A = L*U  when the vector
     a(new)  is added to become the  n-th  column of  A.
     The dimension of  A  is assumed to increase from  n-1  to  n
     (not from  n  to  n+1).

     If  mode = 1,  v(*)  must contain  a(new).
     If  mode = 2,  v(*)  must satisfy  L*v = a(new).
     On exit,  L*v = a(new)  in both cases.

     The array  w(*)  is not used or altered.

     On entry, all elements of  locc  are assumed to be zero.
     On a successful exit (inform ne 7), this will again be true.

     On exit:
     inform =  0  if the rank of U stayed the same.
     inform =  1  if the rank of U increased by 1.
     inform =  7  if the update was not completed (lack of storage).

     -- Feb 1985: Last  F66 version.
     12 May 1988: First F77 version.  Now uses lu8rpc.
<HR></HR>
</COMMENT>
      nout   = luparm(1)
      lprint = luparm(2)
      nrank  = luparm(16)

<COMMENT> Set  locc(n)  in case the user forgot.
 Then let lu8rpc do the job (but stop it from printing messages).
</COMMENT>
      locc(n)   =  0
      iq(n)     =  n
      luparm(2) = -1

      call <!new fthcall lu8rpc><A Name='C_7152'><a href="lusol_f_c.html#R_lu8rpc">lu8rpc</a></A><BRANCHEMENT>( 0, mode, m, n, n, v, w,
     $             lena, luparm, parmlu,
     $             a, indc, indr, ip, iq,
     $             lenc, lenr, locc, locr,
     $             inform, diag, vnorm )</BRANCHEMENT>

      <TEST>if</TEST> (inform .le. 0) then
         <TEST>if</TEST> (nrank .eq. n - 1) then
            <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &           write(nout, 1100) m, n, diag, vnorm
         end if
      else if (inform .eq. 7) then
         <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &        write(nout, 1700) lena<DIV ALIGN=right><INFO>lusol.f-&gt;7166</INFO></DIV>
      end if

      luparm(2) = lprint
      return

 <A Name=lu8adc_L_1100>1100</A> format(/ ' lu8adc  warning.  Rank did not increase',
     $         ' after adding a column.'
     $       / ' m =', I8, '    n =', i8,
     $         '    diag =', 1p, e12.2, '    vnorm =', e12.2)
 <A Name=lu8adc_L_1700>1700</A> format(/ ' lu8adc  error...  Insufficient storage.',<DIV ALIGN=right><INFO>lusol.f-&gt;7176</INFO></DIV>
     $         '    lena =', I8)

      end subroutine <a href="lusol_f_c.html#R_lu8adc">lu8adc</a> <COMMENT> subroutine lu8adc

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu8adr><A Name='R_lu8adr'><a target="index" href="lusol_f_i.html#R_lu8adr">lu8adr</a></A><ARGLIST>( m, n, w,
     $                   lena, luparm, parmlu,
     $                   a, indc, indr, ip, iq,
     $                   lenc, lenr, locc, locr,
     $                   inform, diag )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena), w(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>lenc(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

<COMMENT><HR></HR>
     lu8adr  updates the LU factorization  A = L*U  when the vector
     w(*)  is added to become the  m-th  row of  A.
     The dimension of  A  is assumed to increase from  m-1  to  m
     (not from  m  to  m+1).

     w(*)  is not altered.

     On entry, all elements of  locc  are assumed to be zero.
     On a successful exit (inform ne 7), this will again be true.

     On exit:
     inform =  0  if the rank of U stayed the same.
     inform =  1  if the rank of U increased by 1.
     inform =  7  if the update was not completed (lack of storage).

     -- Feb 1985: Last  F66 version.
     17 May 1988: First F77 version.
<HR></HR>
</COMMENT>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0 )

      nout   = luparm(1)<DIV ALIGN=right><INFO>lusol.f-&gt;7218</INFO></DIV>
      lprint = luparm(2)
      nrank  = luparm(16)
      lenl   = luparm(23)
      lenu   = luparm(24)
      lrow   = luparm(25)
      small  = parmlu(3)
      diag   = zero
      nrank1 = nrank + 1

<COMMENT> Compress row file if necessary.
</COMMENT>
      minfre = n
      nfree  = lena - lenl - lrow
      <TEST>if</TEST> (nfree .ge. minfre) go to 100
      call <!new fthcall lu1rec><A Name='C_7232'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( m, .true., luparm, lrow, lena, a, indr, lenr, locr )</BRANCHEMENT>
      nfree  = lena - lenl - lrow
      <TEST>if</TEST> (nfree .lt. minfre) go to 970

<COMMENT> Pack the nonzeros of  w  at the end of the row file.
 Go backwards in order to set  kfirst.
</COMMENT>
  <A Name=lu8adr_L_100>100</A> locr(m) = lrow + 1
      ip(m)   = m
      lenr(m) = 0

      <LOOP><A Name=C_7243>do</A></LOOP> <A Href=#lu8adr_L_120>120</A> k = n, 1, -1
         j          = iq(k)
         <TEST>if</TEST> (abs( w(j) ) .le. small) go to 120
         kfirst     = k
         lrow       = lrow + 1<DIV ALIGN=right><INFO>lusol.f-&gt;7248</INFO></DIV>
         a(lrow)    = w(j)
         indr(lrow) = j
  <A Name=lu8adr_L_120>120</A>[<A Href=#C_7243>1</A>] continue

      lenw    = lrow + 1 - locr(m)
      lenu    = lenu + lenw
      lenr(m) = lenw

<COMMENT><HR></HR>
     Triangularize the new row.
<HR></HR>
</COMMENT>
      <TEST>if</TEST> (lenw .gt. 0) then

<COMMENT> Swap the new row into position nrank1.
</COMMENT>
         ip(m)      = ip(nrank1)
         ip(nrank1) = m

<COMMENT> Perform a forward sweep to eliminate subdiagonal elements.
</COMMENT>
         <TEST>if</TEST> (kfirst .le. nrank1) then
            call <!new fthcall lu7for><A Name='C_7270'><a href="lusol_f_c.html#R_lu7for">lu7for</a></A><BRANCHEMENT>( m, n, kfirst, nrank1,
     $                   lena, luparm, parmlu,
     $                   lenl, lenu, lrow,
     $                   a, indc, indr, ip, iq, lenr, locc, locr,
     $                   inform, diag )</BRANCHEMENT>
            <TEST>if</TEST> (inform .eq. 7) go to 970
         end if

<COMMENT> See if the rank increases.
</COMMENT>
         <TEST>if</TEST> (nrank .lt. n) then
            nrank  = nrank1
            call <!new fthcall lu7rnk><A Name='C_7282'><a href="lusol_f_c.html#R_lu7rnk">lu7rnk</a></A><BRANCHEMENT>( m, n, 0,
     $                   lena, luparm, parmlu,
     $                   lenl, lenu, lrow, nrank,
     $                   a, indc, indr, ip, iq, lenr, locc, locr,
     $                   inform, diag )</BRANCHEMENT>
         end if
      end if<DIV ALIGN=right><INFO>lusol.f-&gt;7289</INFO></DIV>

<COMMENT><HR></HR>
     Set inform for normal exit.
<HR></HR></COMMENT>
      <TEST>if</TEST> (nrank .ne. nrank1) then
         inform = 0
         <TEST>if</TEST> (nrank .eq. m - 1) then
            <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &           write(nout, 1100) m, n, diag
         end if<DIV ALIGN=right><INFO>lusol.f-&gt;7299</INFO></DIV>
      else
         inform = 1
      end if
      go to <A Href=#lu8adr_L_990>990</A>

<COMMENT> Not enough storage.
</COMMENT>
  <A Name=lu8adr_L_970>970</A> inform = 7
      <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &     write(nout, 1700) lena<DIV ALIGN=right><INFO>lusol.f-&gt;7309</INFO></DIV>

<COMMENT> Exit.
</COMMENT>
  <A Name=lu8adr_L_990>990</A> luparm(10) = inform
      luparm(15) = luparm(15) + 1
      luparm(16) = nrank
      luparm(23) = lenl
      luparm(24) = lenu
      luparm(25) = lrow
      return<DIV ALIGN=right><INFO>lusol.f-&gt;7319</INFO></DIV>

 <A Name=lu8adr_L_1100>1100</A> format(/ ' lu8adr  warning.  Rank did not increase',
     $         ' after adding a row.'
     $       / ' m =', i8, '    n =', i8,
     $         '    diag =', 1p, e12.2)
 <A Name=lu8adr_L_1700>1700</A> format(/ ' lu8adr  error...  Insufficient storage.',
     $         '    lena =', i8)

      end subroutine <a href="lusol_f_c.html#R_lu8adr">lu8adr</a> <COMMENT> subroutine lu8adr

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu8dlc><A Name='R_lu8dlc'><a target="index" href="lusol_f_i.html#R_lu8dlc">lu8dlc</a></A><ARGLIST>( m, n, jdel,
     $                   lena, luparm, parmlu,
     $                   a, indc, indr, ip, iq,
     $                   lenc, lenr, locc, locr,
     $                   inform )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena)</VARIABLE><DIV ALIGN=right><INFO>lusol.f-&gt;7340</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>lenc(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

<COMMENT><HR></HR>
     lu8dlc  updates the LU factorization  A = L*U  when column  jdel
     is deleted.  The dimension of  A  decreases from  n  to  n-1.
     The column permutation  iq(*)  and the column indices in  U
     are altered accordingly.

     NOTE:  The calling program must change  n  to  n-1.

     In some cases it may be more efficient to use  lu8rpc  to
     replace column  jdel  by zero, leaving it in the current position.

     On entry, all elements of  locc  are assumed to be zero.
     On a successful exit (inform ne 7), this will again be true.

     On exit:
     inform = -1  if the rank of U decreased by 1.
     inform =  0  if the rank of U stayed the same.
     inform =  7  if the update was not completed (lack of storage).

     -- Feb 1985: Last  F66 version.
     17 May 1988: First F77 version.
<HR></HR>
</COMMENT>
      nout   = luparm(1)
      lprint = luparm(2)
      nrank  = luparm(16)
      lenl   = luparm(23)<DIV ALIGN=right><INFO>lusol.f-&gt;7371</INFO></DIV>
      lenu   = luparm(24)
      lrow   = luparm(25)
      n1     = n - 1
      <TEST>if</TEST> (jdel .lt. 1) go to 980
      <TEST>if</TEST> (jdel .gt. n) go to 980

<COMMENT> Remove column jdel from U, and set kdel so that iq(kdel) = jdel.
</COMMENT>
      call <!new fthcall lu7zap><A Name='C_7379'><a href="lusol_f_c.html#R_lu7zap">lu7zap</a></A><BRANCHEMENT>( m, n, jdel, kdel,
     $             lena, lenu, lrow, nrank,
     $             a, indr, ip, iq, lenr, locr )</BRANCHEMENT>

<COMMENT> Renumber columns of  U  that are to the right of column  jdel.
 In effect, those columns are shifted one place to the left.
</COMMENT>
      <TEST>if</TEST> (jdel .lt. n) then
         <LOOP><A Name=C_7387>do</A></LOOP> k = 1, nrank
            i      = ip(k)
            lr1    = locr(i)
            lr2    = lr1 + lenr(i) - 1<DIV ALIGN=right><INFO>lusol.f-&gt;7391</INFO></DIV>

            <LOOP><A Name=C_7392>do</A></LOOP> l = lr1, lr2
               j     = indr(l)
               <TEST>if</TEST> (j .gt. jdel) indr(l) = j - 1
            <A Href=#C_7392>end do</A>
         <A Href=#C_7387>end do</A>

         <LOOP><A Name=C_7398>do</A></LOOP> k = 1, n
            j     = iq(k)
            <TEST>if</TEST> (j .gt. jdel) iq(k) = j - 1<DIV ALIGN=right><INFO>lusol.f-&gt;7401</INFO></DIV>
         <A Href=#C_7398>end do</A>
      end if

<COMMENT> Perform cyclic permutations to move column kdel to the end
 and the corresponding row to position nrank.
 Then eliminate the resulting row spike.
</COMMENT>
      call <!new fthcall lu7cyc><A Name='C_7408'><a href="lusol_f_c.html#R_lu7cyc">lu7cyc</a></A><BRANCHEMENT>( kdel, nrank, ip )</BRANCHEMENT>
      call <!new fthcall lu7cyc><A Name='C_7409'><a href="lusol_f_c.html#R_lu7cyc">lu7cyc</a></A><BRANCHEMENT>( kdel, n    , iq )</BRANCHEMENT>

      call <!new fthcall lu7for><A Name='C_7411'><a href="lusol_f_c.html#R_lu7for">lu7for</a></A><BRANCHEMENT>( m, n1, kdel, nrank,
     $             lena, luparm, parmlu,
     $             lenl, lenu, lrow,
     $             a, indc, indr, ip, iq, lenr, locc, locr,
     $             inform, diag )</BRANCHEMENT>
      <TEST>if</TEST> (inform .eq. 7) go to 970

<COMMENT> See if the rank decreased.
</COMMENT>
      CALL <!new fthcall LU7RNK><A Name='C_7420'><a href="lusol_f_c.html#R_lu7rnk">LU7RNK</a></A><BRANCHEMENT>( M, N1, 0,
     $             LENA, LUPARM, PARMLU,
     $             LENL, LENU, LROW, NRANK,
     $             A, INDC, INDR, IP, IQ, LENR, LOCC, LOCR,
     $             INFORM, DIAG )</BRANCHEMENT>
      go to <A Href=#lu8dlc_L_990>990</A>

<COMMENT> Not enough storage.
</COMMENT>
  <A Name=lu8dlc_L_970>970</A> inform = 7
      <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &     write(nout, 1700) lena<DIV ALIGN=right><INFO>lusol.f-&gt;7432</INFO></DIV>
      go to <A Href=#lu8dlc_L_990>990</A>

<COMMENT> jdel  is out of range.
</COMMENT>
  <A Name=lu8dlc_L_980>980</A> inform = 8
      <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &     write(nout, 1800) m, n, jdel

<COMMENT> Exit.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;7442</INFO></DIV>
  <A Name=lu8dlc_L_990>990</A> luparm(10) = inform
      luparm(15) = luparm(15) + 1
      luparm(16) = nrank
      luparm(23) = lenl
      luparm(24) = lenu
      luparm(25) = lrow
      return

 <A Name=lu8dlc_L_1700>1700</A> format(/ ' lu8dlc  error...  Insufficient storage.',
     $         '    lena =', i8)<DIV ALIGN=right><INFO>lusol.f-&gt;7452</INFO></DIV>
 <A Name=lu8dlc_L_1800>1800</A> format(/ ' lu8dlc  error...  jdel  is out of range.',
     $         '    m =', i8, '    n =', i8, '    jdel =', i8)

      end subroutine <a href="lusol_f_c.html#R_lu8dlc">lu8dlc</a> <COMMENT> subroutine lu8dlc

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu8dlr><A Name='R_lu8dlr'><a target="index" href="lusol_f_i.html#R_lu8dlr">lu8dlr</a></A><ARGLIST>( mode, m, n, idel, v, w,
     $                   lena, luparm, parmlu,
     $                   a, indc, indr, ip, iq,
     $                   lenc, lenr, locc, locr,
     $                   inform )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena), v(m), w(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>lenc(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

<COMMENT><HR></HR>
     lu8dlr  updates the LU factorization  A = L*U  when row  idel
     (the vector  w) is deleted from  A. The update is implemented as
     the rank-one modification

           A(new)  =  A  -  e(idel) * w',

     followed by a renumbering that makes row  idel  the last row of  A
     and shifts rows  idel + 1,  idel + 2,  ...,  m  one place up.
     Thus, row  idel  is replaced by the zero vector (rather than being
     deleted), and is then cyclically permuted to the bottom of  A.
     The dimensions of  A  do not alter, but  A  and  U  may become
     singular.

     If  mode = 1,  the old row is assumed to be unknown.  It will be
                    computed from the LU factors of  A.
     If  mode = 2,  w(*)  must contain the old row.

     v(*)  is a work array of length  m.

     On entry, all elements of  locc  are assumed to be zero.
     On a successful exit (inform = 0), this will again be true.

     Note --- significant overhead is involved in permuting row  idel
     to the bottom.  In some cases it may be better to use  lu8rpr  to
     replace row  idel  by zero, leaving it in the current position.
     The growth of nonzeros in  L  and  U  is identical, but less
     housekeeping is required than with  lu8dlr.


     On exit:
     inform = -1  if the rank of U decreased by 1.
     inform =  0  if the rank of U stayed the same.
     inform =  1  if the rank of U increased by 1.
     inform =  7  if the update was not completed (lack of storage).

     -- Feb 1985: Last  F66 version.
     18 May 1988: First F77 version.
<HR></HR>
</COMMENT>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0,  one = 1.0d+0 )<DIV ALIGN=right><INFO>lusol.f-&gt;7513</INFO></DIV>

      nout   = luparm(1)
      lprint = luparm(2)
      <TEST>if</TEST> (idel .lt. 1) go to 980
      <TEST>if</TEST> (idel .gt. m) go to 980

      <TEST>if</TEST> (mode .eq. 1) then

<COMMENT> Compute row idel as the vector w = A(transpose) * e(idel).
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;7523</INFO></DIV>
         <LOOP><A Name=C_7523>do</A></LOOP> i = 1, m
            v(i)  = zero
         <A Href=#C_7523>end do</A>
         v(idel) = one
         call <!new fthcall lu6mul><A Name='C_7527'><a href="lusol_f_c.html#R_lu6mul">lu6mul</a></A><BRANCHEMENT>( 6, m, n, v, w, lena, luparm, parmlu,
     $                a, indc, indr, ip, iq, lenc, lenr, locc, locr )</BRANCHEMENT>
      end if

<COMMENT> Set up the required vectors and do the rank-one mod
 (but don't let lu8mod print anything).
</COMMENT>
      <LOOP><A Name=C_7534>do</A></LOOP> i = 1, m
         v(i)  = zero
      <A Href=#C_7534>end do</A>

      v(idel)   =   one
      beta      = - one
      luparm(2) = - 1

      call <!new fthcall lu8mod><A Name='C_7542'><a href="lusol_f_c.html#R_lu8mod">lu8mod</a></A><BRANCHEMENT>( 1, m, n, beta, v, w,
     $             lena, luparm, parmlu,
     $             a, indc, indr, ip, iq, lenc, lenr, locc, locr,
     $             inform )</BRANCHEMENT>
      <TEST>if</TEST> (inform .eq. 7) go to 970

<COMMENT><HR></HR>
     Permute the deleted row to the bottom.
<HR></HR></COMMENT>
      <TEST>if</TEST> (idel .lt. m) then
         call <!new fthcall lu7cyc><A Name='C_7552'><a href="lusol_f_c.html#R_lu7cyc">lu7cyc</a></A><BRANCHEMENT>( idel, m, lenr )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;7553</INFO></DIV>
         call <!new fthcall lu7cyc><A Name='C_7553'><a href="lusol_f_c.html#R_lu7cyc">lu7cyc</a></A><BRANCHEMENT>( idel, m, locr )</BRANCHEMENT>

         <LOOP><A Name=C_7555>do</A></LOOP> <A Href=#lu8dlr_L_320>320</A> k = 1, m
            i     = ip(k)
            <TEST>if</TEST> (i .lt. idel) go to 320
            ip(k) = i - 1
            <TEST>if</TEST> (i .eq. idel) ip(k) = m
  <A Name=lu8dlr_L_320>320</A>[<A Href=#C_7555>1</A>]    continue

         lenl   = luparm(23)<DIV ALIGN=right><INFO>lusol.f-&gt;7563</INFO></DIV>
         l1     = lena + 1 - lenl

         <LOOP><A Name=C_7565>do</A></LOOP> <A Href=#lu8dlr_L_400>400</A> l = l1, lena
            i       = indc(l)
            <TEST>if</TEST> (i .lt. idel) go to 350
            indc(l) = i - 1
            <TEST>if</TEST> (i .eq. idel) indc(l) = m

  <A Name=lu8dlr_L_350>350</A>       i       = indr(l)
            <TEST>if</TEST> (i .lt. idel) go to 400<DIV ALIGN=right><INFO>lusol.f-&gt;7573</INFO></DIV>
            indr(l) = i - 1
            <TEST>if</TEST> (i .eq. idel) indr(l) = m
  <A Name=lu8dlr_L_400>400</A>[<A Href=#C_7565>1</A>]    continue
      end if

      go to <A Href=#lu8dlr_L_990>990</A>

<COMMENT> Not enough storage.
</COMMENT>
  <A Name=lu8dlr_L_970>970</A> inform = 7<DIV ALIGN=right><INFO>lusol.f-&gt;7583</INFO></DIV>
      <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &     write(nout, 1700) lena
      go to <A Href=#lu8dlr_L_990>990</A>

<COMMENT> idel  is out of range.
</COMMENT>
  <A Name=lu8dlr_L_980>980</A> inform = 8
      <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &     write(nout, 1800) m, n, idel

<COMMENT> Exit.
</COMMENT>
  <A Name=lu8dlr_L_990>990</A> luparm(2)  = lprint
      luparm(10) = inform
      return

 <A Name=lu8dlr_L_1700>1700</A> format(/ ' lu8dlr  error...  Insufficient storage.',
     $         '    lena =', i8)
 <A Name=lu8dlr_L_1800>1800</A> format(/ ' lu8dlr  error...  idel  is out of range.',
     $         '    m =', i8, '    n =', i8, '    idel =', i8)

      end subroutine <a href="lusol_f_c.html#R_lu8dlr">lu8dlr</a> <COMMENT> subroutine lu8dlr

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu8mod><A Name='R_lu8mod'><a target="index" href="lusol_f_i.html#R_lu8mod">lu8mod</a></A><ARGLIST>( mode, m, n, beta, v, w,
     $                   lena, luparm, parmlu,
     $                   a, indc, indr, ip, iq,
     $                   lenc, lenr, locc, locr,
     $                   inform )</ARGLIST>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE><DIV ALIGN=right><INFO>lusol.f-&gt;7615</INFO></DIV>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena), v(m), w(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>lenc(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

<COMMENT><HR></HR>
     lu8mod  updates the LU factorization  A = L*U  when the
     m by n matrix  A  is subjected to a rank-one modification
     to become
                    A  +  beta * v * w(transpose)
     for the given scalar  beta  and vectors  v, w.

     If mode = 1, v(*) must contain the vector  v.
                  On exit, v(*) will contain  y  satisfying  L*y = v.

     If MODE = 2, v(*) must already contain   y  satisfying  L*y = v.

     In both cases, w(*) is unaltered.

     On entry, the elements of  locc  are assumed to be zero.
     On a successful exit (inform ne 7), this will again be true.

     On exit:
     inform = -1  if the rank of U decreased by 1.
     inform =  0  if the rank of U stayed the same.
     inform =  1  if the rank of U increased by 1.
     inform =  7  if the update was not completed (lack of storage).

     -- Mar 1985: Last  F66 version.
     18 May 1988: First F77 version.
<HR></HR>
</COMMENT>
      <DECLARE>logical</DECLARE> <VARIABLE>singlr</VARIABLE>

      nout   = luparm(1)
      lprint = luparm(2)
      nrank  = luparm(16)
      lenl   = luparm(23)
      lenu   = luparm(24)
      lrow   = luparm(25)<DIV ALIGN=right><INFO>lusol.f-&gt;7656</INFO></DIV>
      small  = parmlu(3)
      utol1  = parmlu(4)
      nrank0 = nrank

<COMMENT> If necessary, solve  L*v(new) = v.
</COMMENT>
      <TEST>if</TEST> (mode .eq. 1) then
         call <!new fthcall lu6sol><A Name='C_7663'><a href="lusol_f_c.html#R_lu6sol">lu6sol</a></A><BRANCHEMENT>( 1, m, n, v, w, lena, luparm, parmlu,
     $                a, indc, indr, ip, iq, lenc, lenr, locc, locr,
     $                inform )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;7666</INFO></DIV>
      end if

<COMMENT><HR></HR>
     Find the first nonzero in  w  (in pivotal column order).
<HR></HR></COMMENT>
      <LOOP><A Name=C_7671>do</A></LOOP> k = 1, n
         kfirst = k
         j      = iq(k)
         <TEST>if</TEST> (abs( w(j) ) .gt. small) go to 120
      <A Href=#C_7671>end do</A><DIV ALIGN=right><INFO>lusol.f-&gt;7676</INFO></DIV>
      go to <A Href=#lu8mod_L_900>900</A>

<COMMENT><HR></HR>
     Eliminate any nonzeros in  v  below the trapezoid.
<HR></HR></COMMENT>
  <A Name=lu8mod_L_120>120</A> <TEST>if</TEST> (nrank .lt. m) then
         nrank  = nrank + 1
         jelm   = 0

         call <!new fthcall lu7elm><A Name='C_7685'><a href="lusol_f_c.html#R_lu7elm">lu7elm</a></A><BRANCHEMENT>( m, n, jelm, v,
     $                lena, luparm, parmlu,
     $                lenl, lenu, lrow, nrank,
     $                a, indc, indr, ip, iq, lenr, locc, locr,
     $                inform, diag )</BRANCHEMENT>
         <TEST>if</TEST> (inform .eq. 7) go to 970

         <TEST>if</TEST> (inform .eq. 0) nrank = nrank - 1
      end if

<COMMENT><HR></HR>
     Find the last nonzero in  v  (in pivotal row order).
<HR></HR></COMMENT>
      <LOOP><A Name=C_7698>do</A></LOOP> k = nrank, 1, -1
         klast  = k
         i      = ip(k)
         <TEST>if</TEST> (abs( v(i) ) .gt. small) go to 220
      <A Href=#C_7698>end do</A>
      go to <A Href=#lu8mod_L_900>900</A>

<COMMENT><HR></HR>
     Perform a backward sweep of eliminations to reduce part of  v
     to a multiple of the unit vector  e(iw),  where  iw = ip(klast).
     Elements  ip(kfirst+1),  ip(kfirst+2),  ...,  ip(klast)  of  v
     are involved.
     L, U  and  ip  are updated accordingly.
     U  will then be trapezoidal except for row  iw = ip(klast).
<HR></HR></COMMENT>
  <A Name=lu8mod_L_220>220</A> <TEST>if</TEST> (kfirst + 1  .lt.  klast) then
         call <!new fthcall lu7bak><A Name='C_7714'><a href="lusol_f_c.html#R_lu7bak">lu7bak</a></A><BRANCHEMENT>( m, n, kfirst, klast, v,
     $                lena, luparm, parmlu,
     $                lenl, lenu, lrow,
     $                a, indc, indr, ip, iq, lenr, locc, locr,
     $                inform )</BRANCHEMENT>
         <TEST>if</TEST> (inform .ne. 0) go to 970
      end if

<COMMENT><HR></HR>
     Pack the nonzeros of  w  in pivotal order in front of  L.
     (We will treat the packed  w  much like a normal row of  U.)
     Set markers on  w  and initialize the corresponding
     elements of  indc(*),  which are later used by  lu7asv.
<HR></HR>
</COMMENT>
      lfree  = lena - lenl
      minfre = n + 1 - kfirst
      nfree  = lfree - lrow
      <TEST>if</TEST> (nfree .ge. minfre) go to 310
      call <!new fthcall lu1rec><A Name='C_7733'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( m, .true., luparm, lrow, lena, a, indr, lenr, locr )</BRANCHEMENT>
      nfree  = lfree - lrow
      <TEST>if</TEST> (nfree .lt. minfre) go to 970<DIV ALIGN=right><INFO>lusol.f-&gt;7736</INFO></DIV>

  <A Name=lu8mod_L_310>310</A> lw     = lfree + 1

      <LOOP><A Name=C_7739>do</A></LOOP> <A Href=#lu8mod_L_320>320</A>   k  = n, kfirst, -1
         j        = iq(k)
         <TEST>if</TEST> (abs( w(j) ) .le. small) go to 320
         lw       = lw - 1
         a(lw)    = w(j)
         indr(lw) = j
         indc(lw) = 0<DIV ALIGN=right><INFO>lusol.f-&gt;7746</INFO></DIV>
         locc(j)  = lw
  <A Name=lu8mod_L_320>320</A>[<A Href=#C_7739>1</A>] continue

      lw1    = lw
      lw2    = lfree
      lenw   = lw2 + 1 - lw1
      lfree  = lfree - lenw

<COMMENT><HR></HR>
     Add multiples of  w  to the first  kfirst  rows of  U.
     (This does not alter the trapezoidal form of  U.)
<HR></HR>
</COMMENT>
      <LOOP><A Name=C_7759>do</A></LOOP> <A Href=#lu8mod_L_450>450</A> k  = 1, kfirst
         iv     = ip(k)
         cv     = v(iv)
         <TEST>if</TEST> (abs( cv ) .le. small) go to 450

<COMMENT><HR></HR>
        Compress storage if necessary, so there will be room if
        row  iv  has to be moved to the end.
<HR></HR></COMMENT>
         minfre = n
         nfree  = lfree - lrow
         <TEST>if</TEST> (nfree .ge. minfre) go to 420
         call <!new fthcall lu1rec><A Name='C_7771'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( m, .true., luparm, lrow, lena, a,indr,lenr,locr )</BRANCHEMENT>
         nfree  = lfree - lrow
         <TEST>if</TEST> (nfree .lt. minfre) go to 970

<COMMENT><HR></HR>
        Set  v  =  v  +  wmult * w.
<HR></HR></COMMENT>
  <A Name=lu8mod_L_420>420</A>    wmult  = beta * cv
         call <!new fthcall lu7asv><A Name='C_7779'><a href="lusol_f_c.html#R_lu7asv">lu7asv</a></A><BRANCHEMENT>( m, n, iv, lenw, lw1, lw2, k, wmult,
     $                lena, luparm, parmlu,
     $                lenu, lrow,
     $                a, indc, indr, lenr, locc, locr )</BRANCHEMENT>
  <A Name=lu8mod_L_450>450</A>[<A Href=#C_7759>1</A>] continue

<COMMENT><HR></HR>
     Add a multiple of  w  to row  iw  of  U.
<HR></HR>
</COMMENT>
      <TEST>if</TEST> (kfirst .lt. klast) then
         minfre = n
         nfree  = lfree - lrow
         <TEST>if</TEST> (nfree .ge. minfre) go to 500
         call <!new fthcall lu1rec><A Name='C_7793'><a href="lusol_f_c.html#R_lu1rec">lu1rec</a></A><BRANCHEMENT>( m, .true., luparm, lrow, lena, a,indr,lenr,locr )</BRANCHEMENT>
         nfree  = lfree - lrow
         <TEST>if</TEST> (nfree .lt. minfre) go to 970<DIV ALIGN=right><INFO>lusol.f-&gt;7796</INFO></DIV>

  <A Name=lu8mod_L_500>500</A>    iw     = ip(klast)
         marker = m + 1
         wmult  = beta * v(iw)
         call <!new fthcall lu7asv><A Name='C_7800'><a href="lusol_f_c.html#R_lu7asv">lu7asv</a></A><BRANCHEMENT>( m, n, iw, lenw, lw1, lw2, marker, wmult,
     $                lena, luparm, parmlu,
     $                lenu, lrow,
     $                a, indc, indr, lenr, locc, locr )</BRANCHEMENT>
      end if

<COMMENT><HR></HR>
     Cancel the markers on  w.
<HR></HR></COMMENT>
      <LOOP><A Name=C_7809>do</A></LOOP> lw  = lw1, lw2
         jw       = indr(lw)
         locc(jw) = 0
      <A Href=#C_7809>end do</A>

<COMMENT><HR></HR>
     Apply a forward sweep to eliminate the nonzeros in row  iw.
<HR></HR>
</COMMENT>
      <TEST>if</TEST> (kfirst .gt. klast) then
         <TEST>if</TEST> (klast .lt. nrank) go to 900
      else
         call <!new fthcall lu7for><A Name='C_7821'><a href="lusol_f_c.html#R_lu7for">lu7for</a></A><BRANCHEMENT>( m, n, kfirst, klast,
     $                lena, luparm, parmlu,
     $                lenl, lenu, lrow,
     $                a, indc, indr, ip, iq, lenr, locc, locr,
     $                inform, diag )</BRANCHEMENT>
         <TEST>if</TEST> (inform .eq. 7) go to 970<DIV ALIGN=right><INFO>lusol.f-&gt;7827</INFO></DIV>
      end if

<COMMENT><HR></HR>
     Test for singularity in column klast (if klast .le. nrank).
     The code is similar to part of lu8rpc with klast in place of krep.
<HR></HR>
</COMMENT>
      <TEST>if</TEST> (klast .le. nrank) then
         diag   = zero
         iw     = ip(klast)<DIV ALIGN=right><INFO>lusol.f-&gt;7837</INFO></DIV>
         singlr = lenr(iw) .eq. 0

         <TEST>if</TEST> (.not. singlr) then
            l1     = locr(iw)
            j1     = indr(l1)
            singlr = j1 .ne. jrep

            <TEST>if</TEST> (.not. singlr) then
               diag   = a(l1)
               singlr = abs( diag ) .le. utol1<DIV ALIGN=right><INFO>lusol.f-&gt;7847</INFO></DIV>
            end if
         end if

         <TEST>if</TEST> ( singlr  .and.  klast .lt. nrank ) then

<COMMENT> Perform cyclic permutations to move column klast
 to the end and the corresponding row to position nrank.
 Then eliminate the resulting row spike.
</COMMENT>
            call <!new fthcall lu7cyc><A Name='C_7856'><a href="lusol_f_c.html#R_lu7cyc">lu7cyc</a></A><BRANCHEMENT>( klast, nrank, ip )</BRANCHEMENT><DIV ALIGN=right><INFO>lusol.f-&gt;7857</INFO></DIV>
            call <!new fthcall lu7cyc><A Name='C_7857'><a href="lusol_f_c.html#R_lu7cyc">lu7cyc</a></A><BRANCHEMENT>( klast, n    , iq )</BRANCHEMENT>

            call <!new fthcall lu7for><A Name='C_7859'><a href="lusol_f_c.html#R_lu7for">lu7for</a></A><BRANCHEMENT>( m, n, klast, nrank,
     $                   lena, luparm, parmlu,
     $                   lenl, lenu, lrow,
     $                   a, indc, indr, ip, iq, lenr, locc, locr,
     $                   inform, diag )</BRANCHEMENT>
            <TEST>if</TEST> (inform .eq. 7) go to 970
         end if

<COMMENT> Find the best column to be in position nrank.
 If nothing satisfactory exists, nrank will be decreased.
</COMMENT>
         jsing  = 0
         call <!new fthcall lu7rnk><A Name='C_7871'><a href="lusol_f_c.html#R_lu7rnk">lu7rnk</a></A><BRANCHEMENT>( m, n, jsing,
     $                lena, luparm, parmlu,
     $                lenl, lenu, lrow, nrank,
     $                a, indc, indr, ip, iq, lenr, locc, locr,
     $                inform, diag )</BRANCHEMENT>
      end if

<COMMENT><HR></HR>
     Set inform for exit.
<HR></HR>
</COMMENT>
  <A Name=lu8mod_L_900>900</A> <TEST>if</TEST> (nrank .eq. nrank0) then
         inform =  0
      else if (nrank .lt. nrank0) then
         inform = -1
      else
         inform =  1
      end if<DIV ALIGN=right><INFO>lusol.f-&gt;7889</INFO></DIV>
      go to <A Href=#lu8mod_L_990>990</A>

<COMMENT> Not enough storage.
</COMMENT>
  <A Name=lu8mod_L_970>970</A> inform = 7
      <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &     write(nout, 1700) lena

<COMMENT> Exit.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;7899</INFO></DIV>
  <A Name=lu8mod_L_990>990</A> luparm(10) = inform
      luparm(15) = luparm(15) + 1
      luparm(16) = nrank
      luparm(23) = lenl
      luparm(24) = lenu
      luparm(25) = lrow
      return

 <A Name=lu8mod_L_1700>1700</A> format(/ ' lu8mod  error...  Insufficient storage.',
     $         '    lena =', i8)<DIV ALIGN=right><INFO>lusol.f-&gt;7909</INFO></DIV>

      end subroutine <a href="lusol_f_c.html#R_lu8mod">lu8mod</a> <COMMENT> subroutine lu8mod

<HR></HR>
</COMMENT>
      subroutine <!new fthrout lu8rpr><A Name='R_lu8rpr'><a target="index" href="lusol_f_i.html#R_lu8rpr">lu8rpr</a></A><ARGLIST>( mode1, mode2, m, n, irep, v, w, wnew,
     $                   lena, luparm, parmlu,
     $                   a, indc, indr, ip, iq,
     $                   lenc, lenr, locc, locr,
     $                   inform )</ARGLIST><DIV ALIGN=right><INFO>lusol.f-&gt;7919</INFO></DIV>

<DECLARE>      implicit           double precision (a-h,o-z)</DECLARE>
      <DECLARE>integer</DECLARE> <VARIABLE>luparm(30)</VARIABLE>
      <DECLARE>double precision</DECLARE> <VARIABLE>parmlu(30), a(lena), v(m), w(n), wnew(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>indc(lena), indr(lena), ip(m), iq(n)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>lenc(n), lenr(m)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>locc(n), locr(m)</VARIABLE>

<COMMENT><HR></HR>
     lu8rpr  updates the LU factorization  A = L*U  when row  irep
     (a vector  w(old)) is replaced by some vector  w(new).
     The update is implemented as the rank-one modification

           A(new)  =  A  -  e(irep) * ( w(old) - w(new) )'

     with variations determined by  mode1  and  mode2  as follows.

     mode1
<HR></HR>
       0     w(old)  is assumed to be zero.
             w(*)    need not be set on entry, but will be altered.

       1     w(old)  is assumed to be unknown.  it will be computed
                     from the LU factors of  A.
             w(*)    need not be set on entry, but will be altered.

       2     w(*)    must contain  w(old).
                     On exit, it will contain  w(old) - w(new).

       3     w(*)    must contain  w(old) - w(new).  It is not altered.
                     wnew(*) is not used.

       4     w(*)    must contain  w(new) - w(old).  It is not altered.
                     wnew(*) is not used.

     If  mode1 = 3 or 4,  mode2  is not used.  It may be set to 0 or 1.
     Otherwise,  mode2  is used as follows.

     mode2
<HR></HR>
       0     w(new)  is assumed to be zero.   wnew(*)  is not used.

       1     wnew(*) must contain the new row.

     v(*)    is a work array of length  m.
     On entry, all elements of  locc  are assumed to be zero.
     On a successful exit (inform ne 7), this will again be true.


     On exit:
     inform = -1  if the rank of U decreased by 1.
     inform =  0  if the rank of U stayed the same.
     inform =  1  if the rank of U increased by 1.
     inform =  7  if the update was not completed (lack of storage).
     inform =  8  if jrep is not between 1 and n.

     -- Mar 1985: Last  F66 version.
     18 May 1988: First F77 version.
<HR></HR>
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;7979</INFO></DIV>
<DECLARE>      parameter        </DECLARE>(<VARIABLE> zero = 0</VARIABLE>.0d+0,  one = 1.0d+0 )

      nout   = luparm(1)
      lprint = luparm(2)
      <TEST>if</TEST> (irep .lt. 1) go to 980
      <TEST>if</TEST> (irep .gt. m) go to 980

      <TEST>if</TEST> (mode1 .eq. 0) then

<COMMENT> The old row  irep  is zero.
</COMMENT>
         <LOOP><A Name=C_7990>do</A></LOOP> j = 1, n
            w(j) = zero
         <A Href=#C_7990>end do</A>
      else if (mode1 .eq. 1) then

<COMMENT> Compute row irep as the vector  w  =  A(transpose) * e(irep).
</COMMENT>
         <LOOP><A Name=C_7997>do</A></LOOP> i = 1, m
            v(i)  = zero<DIV ALIGN=right><INFO>lusol.f-&gt;7999</INFO></DIV>
         <A Href=#C_7997>end do</A>
         v(irep) = one
         call <!new fthcall lu6mul><A Name='C_8001'><a href="lusol_f_c.html#R_lu6mul">lu6mul</a></A><BRANCHEMENT>( 6, m, n, v, w, lena, luparm, parmlu,
     $                a, indc, indr, ip, iq, lenc, lenr, locc, locr )</BRANCHEMENT>
      end if

      <TEST>if</TEST> (mode1 .le. 2) then

<COMMENT> Compute the difference except if  wnew = 0.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;8009</INFO></DIV>
         <TEST>if</TEST> (mode2 .gt. 0) then
            <LOOP><A Name=C_8010>do</A></LOOP> j = 1, n
               w(j)  = w(j) - wnew(j)
            <A Href=#C_8010>end do</A>
         end if
      end if

<COMMENT><HR></HR>
     Set  v = a unit vector  and do the rank-one modification
     (but don't let lu8mod print anything).
<HR></HR>
</COMMENT>
      <LOOP><A Name=C_8021>do</A></LOOP> i = 1, m
         v(i)  = zero
      <A Href=#C_8021>end do</A>

      v(irep)   =   one
      beta      = - one
      <TEST>if</TEST> (mode1 .eq. 4) beta = one
      luparm(2) = - 1<DIV ALIGN=right><INFO>lusol.f-&gt;8029</INFO></DIV>

      call <!new fthcall lu8mod><A Name='C_8030'><a href="lusol_f_c.html#R_lu8mod">lu8mod</a></A><BRANCHEMENT>( 1, m, n, beta, v, w,
     $             lena, luparm, parmlu,
     $             a, indc, indr, ip, iq, lenc, lenr, locc, locr,
     $             inform )</BRANCHEMENT>
      <TEST>if</TEST> (inform .eq. 7) go to 970
      go to <A Href=#lu8rpr_L_990>990</A>

<COMMENT> Not enough storage.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;8039</INFO></DIV>
  <A Name=lu8rpr_L_970>970</A> inform = 7
      <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &     write(nout, 1700) lena
      go to <A Href=#lu8rpr_L_990>990</A>

<COMMENT> irep  is out of range.
</COMMENT>
  <A Name=lu8rpr_L_980>980</A> inform = 8
      <TEST>if</TEST> (nout. gt. 0  .and.  lprint .ge. 0)
     &     write(nout, 1800) m, n, irep<DIV ALIGN=right><INFO>lusol.f-&gt;8049</INFO></DIV>

<COMMENT> Exit.
</COMMENT>
  <A Name=lu8rpr_L_990>990</A> luparm(2)  = lprint
      luparm(10) = inform
      return

 <A Name=lu8rpr_L_1700>1700</A> format(/ ' lu8rpr  error...  Insufficient storage.',
     $         '    lena =', i8)
 <A Name=lu8rpr_L_1800>1800</A> format(/ ' lu8rpr  error...  irep  is out of range.',<DIV ALIGN=right><INFO>lusol.f-&gt;8059</INFO></DIV>
     $         '    m =', i8, '    n =', i8, '    irep =', i8)

      end subroutine <a href="lusol_f_c.html#R_lu8rpr">lu8rpr</a> <COMMENT> subroutine lu8rpr</COMMENT>
*********************************************************************
*
*     File  mi15blas fortran.
*
*     dasum    daxpy    dcopy    ddot    dscal    idamax
*
*     These correspond to members of the BLAS package (Basic Linear<DIV ALIGN=right><INFO>lusol.f-&gt;8069</INFO></DIV>
*     Algebra Subprograms, Lawson et al. (1979), ACM TOMS 5, 3).
*     If possible, they should be replaced by authentic BLAS routines
*     tuned to the machine being used.
*
*     12 Jul 2000: mi15blas.f now contains BLAS1 routines only.
*                  Other utilities moved into mi17util.f.
*     27 Jun 2003: dnrm2   removed because of obsolete features.
*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

*** dasum thru idamax taken<DIV ALIGN=right><INFO>lusol.f-&gt;8079</INFO></DIV>
*** from netlib, Thu May 16 21:00:13 EDT 1991 ***
*** Declarations of the form dx(1) changed to dx(*).
*** dabs(*), dsqrt(*) changed to generic intrinsics abs(*), sqrt(*).
*** Constants 0.0d0, 1.0d0 changed to 0.0d+0, 1.0d+0.

      double precision function <!new fthrout dasum><A Name='R_dasum'><a target="index" href="lusol_f_i.html#R_dasum">dasum</a></A><ARGLIST>(n,dx,incx)</ARGLIST>

<COMMENT>     takes the sum of the absolute values.
     jack dongarra, linpack, 3/11/78.
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;8089</INFO></DIV>
      <DECLARE>double precision</DECLARE> <VARIABLE>dx(*),dtemp</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>i,incx,m,mp1,n,nincx</VARIABLE>

      dasum = 0.0d+0
      dtemp = 0.0d+0
      <TEST>if</TEST>(n.le.0)return
      <TEST>if</TEST>(incx.eq.1)go to 20

<COMMENT>        code for increment not equal to 1
</COMMENT><DIV ALIGN=right><INFO>lusol.f-&gt;8099</INFO></DIV>
      nincx = n*incx
      <LOOP><A Name=C_8100>do</A></LOOP> <A Href=#dasum_L_10>10</A> i = 1,nincx,incx
        dtemp = dtemp + abs(dx(i))
   <A Name=dasum_L_10>10</A>[<A Href=#C_8100>1</A>] continue
      dasum = dtemp
      return

<COMMENT>        code for increment equal to 1


        clean-up loop
</COMMENT>
   <A Name=dasum_L_20>20</A> m = mod(n,6)
      <TEST>if</TEST>( m .eq. 0 ) go to 40
      <LOOP><A Name=C_8113>do</A></LOOP> <A Href=#dasum_L_30>30</A> i = 1,m
        dtemp = dtemp + abs(dx(i))
   <A Name=dasum_L_30>30</A>[<A Href=#C_8113>1</A>] continue
      <TEST>if</TEST>( n .lt. 6 ) go to 60
   <A Name=dasum_L_40>40</A> mp1 = m + 1
      <LOOP><A Name=C_8118>do</A></LOOP> <A Href=#dasum_L_50>50</A> i = mp1,n,6
        dtemp = dtemp + abs(dx(i)) + abs(dx(i + 1)) + abs(dx(i + 2))<DIV ALIGN=right><INFO>lusol.f-&gt;8120</INFO></DIV>
     *  + abs(dx(i + 3)) + abs(dx(i + 4)) + abs(dx(i + 5))
   <A Name=dasum_L_50>50</A>[<A Href=#C_8118>1</A>] continue
   <A Name=dasum_L_60>60</A> dasum = dtemp
      return
      end function <a href="lusol_f_c.html#R_dasum">dasum</a>

*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine <!new fthrout daxpy><A Name='R_daxpy'><a target="index" href="lusol_f_i.html#R_daxpy">daxpy</a></A><ARGLIST>(n,da,dx,incx,dy,incy)</ARGLIST>

<COMMENT>     constant times a vector plus a vector.
     uses unrolled loops for increments equal to one.
     jack dongarra, linpack, 3/11/78.
</COMMENT>
      <DECLARE>double precision</DECLARE> <VARIABLE>dx(*),dy(*),da</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>i,incx,incy,ix,iy,m,mp1,n</VARIABLE>

      <TEST>if</TEST>(n.le.0)return
      <TEST>if</TEST> (da .eq. 0.0d+0) return
      <TEST>if</TEST>(incx.eq.1.and.incy.eq.1)go to 20

<COMMENT>        code for unequal increments or equal increments
          not equal to 1
</COMMENT>
      ix = 1
      iy = 1
      <TEST>if</TEST>(incx.lt.0)ix = (-n+1)*incx + 1
      <TEST>if</TEST>(incy.lt.0)iy = (-n+1)*incy + 1
      <LOOP><A Name=C_8148>do</A></LOOP> <A Href=#daxpy_L_10>10</A> i = 1,n
        dy(iy) = dy(iy) + da*dx(ix)
        ix = ix + incx
        iy = iy + incy<DIV ALIGN=right><INFO>lusol.f-&gt;8152</INFO></DIV>
   <A Name=daxpy_L_10>10</A>[<A Href=#C_8148>1</A>] continue
      return

<COMMENT>        code for both increments equal to 1


        clean-up loop
</COMMENT>
   <A Name=daxpy_L_20>20</A> m = mod(n,4)
      <TEST>if</TEST>( m .eq. 0 ) go to 40<DIV ALIGN=right><INFO>lusol.f-&gt;8162</INFO></DIV>
      <LOOP><A Name=C_8162>do</A></LOOP> <A Href=#daxpy_L_30>30</A> i = 1,m
        dy(i) = dy(i) + da*dx(i)
   <A Name=daxpy_L_30>30</A>[<A Href=#C_8162>1</A>] continue
      <TEST>if</TEST>( n .lt. 4 ) return
   <A Name=daxpy_L_40>40</A> mp1 = m + 1
      <LOOP><A Name=C_8167>do</A></LOOP> <A Href=#daxpy_L_50>50</A> i = mp1,n,4
        dy(i) = dy(i) + da*dx(i)
        dy(i + 1) = dy(i + 1) + da*dx(i + 1)
        dy(i + 2) = dy(i + 2) + da*dx(i + 2)
        dy(i + 3) = dy(i + 3) + da*dx(i + 3)<DIV ALIGN=right><INFO>lusol.f-&gt;8172</INFO></DIV>
   <A Name=daxpy_L_50>50</A>[<A Href=#C_8167>1</A>] continue
      return
      end subroutine <a href="lusol_f_c.html#R_daxpy">daxpy</a>

*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine  <!new fthrout dcopy><A Name='R_dcopy'><a target="index" href="lusol_f_i.html#R_dcopy">dcopy</a></A><ARGLIST>(n,dx,incx,dy,incy)</ARGLIST>

<COMMENT>     copies a vector, x, to a vector, y.
     uses unrolled loops for increments equal to one.
     jack dongarra, linpack, 3/11/78.
</COMMENT>
      <DECLARE>double precision</DECLARE> <VARIABLE>dx(*),dy(*)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>i,incx,incy,ix,iy,m,mp1,n</VARIABLE>

      <TEST>if</TEST>(n.le.0)return
      <TEST>if</TEST>(incx.eq.1.and.incy.eq.1)go to 20

<COMMENT>        code for unequal increments or equal increments
          not equal to 1
</COMMENT>
      ix = 1
      iy = 1
      <TEST>if</TEST>(incx.lt.0)ix = (-n+1)*incx + 1
      <TEST>if</TEST>(incy.lt.0)iy = (-n+1)*incy + 1
      <LOOP><A Name=C_8197>do</A></LOOP> <A Href=#dcopy_L_10>10</A> i = 1,n
        dy(iy) = dx(ix)
        ix = ix + incx
        iy = iy + incy
   <A Name=dcopy_L_10>10</A>[<A Href=#C_8197>1</A>] continue<DIV ALIGN=right><INFO>lusol.f-&gt;8202</INFO></DIV>
      return

<COMMENT>        code for both increments equal to 1


        clean-up loop
</COMMENT>
   <A Name=dcopy_L_20>20</A> m = mod(n,7)
      <TEST>if</TEST>( m .eq. 0 ) go to 40
      <LOOP><A Name=C_8211>do</A></LOOP> <A Href=#dcopy_L_30>30</A> i = 1,m<DIV ALIGN=right><INFO>lusol.f-&gt;8212</INFO></DIV>
        dy(i) = dx(i)
   <A Name=dcopy_L_30>30</A>[<A Href=#C_8211>1</A>] continue
      <TEST>if</TEST>( n .lt. 7 ) return
   <A Name=dcopy_L_40>40</A> mp1 = m + 1
      <LOOP><A Name=C_8216>do</A></LOOP> <A Href=#dcopy_L_50>50</A> i = mp1,n,7
        dy(i) = dx(i)
        dy(i + 1) = dx(i + 1)
        dy(i + 2) = dx(i + 2)
        dy(i + 3) = dx(i + 3)
        dy(i + 4) = dx(i + 4)<DIV ALIGN=right><INFO>lusol.f-&gt;8222</INFO></DIV>
        dy(i + 5) = dx(i + 5)
        dy(i + 6) = dx(i + 6)
   <A Name=dcopy_L_50>50</A>[<A Href=#C_8216>1</A>] continue
      return
      end subroutine <a href="lusol_f_c.html#R_dcopy">dcopy</a>

*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      double precision function <!new fthrout ddot><A Name='R_ddot'><a target="index" href="lusol_f_i.html#R_ddot">ddot</a></A><ARGLIST>(n,dx,incx,dy,incy)</ARGLIST>

<COMMENT>     forms the dot product of two vectors.
     uses unrolled loops for increments equal to one.
     jack dongarra, linpack, 3/11/78.
</COMMENT>
      <DECLARE>double precision</DECLARE> <VARIABLE>dx(*),dy(*),dtemp</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>i,incx,incy,ix,iy,m,mp1,n</VARIABLE>

      ddot = 0.0d+0
      dtemp = 0.0d+0
      <TEST>if</TEST>(n.le.0)return
      <TEST>if</TEST>(incx.eq.1.and.incy.eq.1)go to 20<DIV ALIGN=right><INFO>lusol.f-&gt;8243</INFO></DIV>

<COMMENT>        code for unequal increments or equal increments
          not equal to 1
</COMMENT>
      ix = 1
      iy = 1
      <TEST>if</TEST>(incx.lt.0)ix = (-n+1)*incx + 1
      <TEST>if</TEST>(incy.lt.0)iy = (-n+1)*incy + 1
      <LOOP><A Name=C_8251>do</A></LOOP> <A Href=#ddot_L_10>10</A> i = 1,n
        dtemp = dtemp + dx(ix)*dy(iy)<DIV ALIGN=right><INFO>lusol.f-&gt;8253</INFO></DIV>
        ix = ix + incx
        iy = iy + incy
   <A Name=ddot_L_10>10</A>[<A Href=#C_8251>1</A>] continue
      ddot = dtemp
      return

<COMMENT>        code for both increments equal to 1


        clean-up loop
</COMMENT>
   <A Name=ddot_L_20>20</A> m = mod(n,5)
      <TEST>if</TEST>( m .eq. 0 ) go to 40
      <LOOP><A Name=C_8266>do</A></LOOP> <A Href=#ddot_L_30>30</A> i = 1,m
        dtemp = dtemp + dx(i)*dy(i)
   <A Name=ddot_L_30>30</A>[<A Href=#C_8266>1</A>] continue
      <TEST>if</TEST>( n .lt. 5 ) go to 60
   <A Name=ddot_L_40>40</A> mp1 = m + 1
      <LOOP><A Name=C_8271>do</A></LOOP> <A Href=#ddot_L_50>50</A> i = mp1,n,5
        dtemp = dtemp + dx(i)*dy(i) + dx(i + 1)*dy(i + 1) +<DIV ALIGN=right><INFO>lusol.f-&gt;8273</INFO></DIV>
     *   dx(i + 2)*dy(i + 2) + dx(i + 3)*dy(i + 3) + dx(i + 4)*dy(i + 4)
   <A Name=ddot_L_50>50</A>[<A Href=#C_8271>1</A>] continue
   <A Name=ddot_L_60>60</A> ddot = dtemp
      return
      end function <a href="lusol_f_c.html#R_ddot">ddot</a>

*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      subroutine  <!new fthrout dscal><A Name='R_dscal'><a target="index" href="lusol_f_i.html#R_dscal">dscal</a></A><ARGLIST>(n,da,dx,incx)</ARGLIST>

<COMMENT>     scales a vector by a constant.
     uses unrolled loops for increment equal to one.
     jack dongarra, linpack, 3/11/78.
</COMMENT>
      <DECLARE>double precision</DECLARE> <VARIABLE>da,dx(*)</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>i,incx,m,mp1,n,nincx</VARIABLE>

      <TEST>if</TEST>(n.le.0)return
      <TEST>if</TEST>(incx.eq.1)go to 20

<COMMENT>        code for increment not equal to 1
</COMMENT>
      nincx = n*incx
      <LOOP><A Name=C_8296>do</A></LOOP> <A Href=#dscal_L_10>10</A> i = 1,nincx,incx
        dx(i) = da*dx(i)
   <A Name=dscal_L_10>10</A>[<A Href=#C_8296>1</A>] continue
      return

<COMMENT>        code for increment equal to 1


        clean-up loop
</COMMENT>
   <A Name=dscal_L_20>20</A> m = mod(n,5)
      <TEST>if</TEST>( m .eq. 0 ) go to 40
      <LOOP><A Name=C_8308>do</A></LOOP> <A Href=#dscal_L_30>30</A> i = 1,m
        dx(i) = da*dx(i)
   <A Name=dscal_L_30>30</A>[<A Href=#C_8308>1</A>] continue
      <TEST>if</TEST>( n .lt. 5 ) return
   <A Name=dscal_L_40>40</A> mp1 = m + 1
      <LOOP><A Name=C_8313>do</A></LOOP> <A Href=#dscal_L_50>50</A> i = mp1,n,5
        dx(i) = da*dx(i)<DIV ALIGN=right><INFO>lusol.f-&gt;8315</INFO></DIV>
        dx(i + 1) = da*dx(i + 1)
        dx(i + 2) = da*dx(i + 2)
        dx(i + 3) = da*dx(i + 3)
        dx(i + 4) = da*dx(i + 4)
   <A Name=dscal_L_50>50</A>[<A Href=#C_8313>1</A>] continue
      return
      end subroutine <a href="lusol_f_c.html#R_dscal">dscal</a>

*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      integer function <!new fthrout idamax><A Name='R_idamax'><a target="index" href="lusol_f_i.html#R_idamax">idamax</a></A><ARGLIST>(n,dx,incx)</ARGLIST><DIV ALIGN=right><INFO>lusol.f-&gt;8326</INFO></DIV>

<COMMENT>     finds the index of element having max. absolute value.
     jack dongarra, linpack, 3/11/78.
</COMMENT>
      <DECLARE>double precision</DECLARE> <VARIABLE>dx(*),dmax</VARIABLE>
      <DECLARE>integer</DECLARE> <VARIABLE>i,incx,ix,n</VARIABLE>

      idamax = 0
      <TEST>if</TEST>( n .lt. 1 ) return
      idamax = 1<DIV ALIGN=right><INFO>lusol.f-&gt;8336</INFO></DIV>
      <TEST>if</TEST>(n.eq.1)return
      <TEST>if</TEST>(incx.eq.1)go to 20

<COMMENT>        code for increment not equal to 1
</COMMENT>
      ix = 1
      dmax = abs(dx(1))
      ix = ix + incx
      <LOOP><A Name=C_8344>do</A></LOOP> <A Href=#idamax_L_10>10</A> i = 2,n
         <TEST>if</TEST>(abs(dx(ix)).le.dmax) go to 5<DIV ALIGN=right><INFO>lusol.f-&gt;8346</INFO></DIV>
         idamax = i
         dmax = abs(dx(ix))
    <A Name=idamax_L_5>5</A>    ix = ix + incx
   <A Name=idamax_L_10>10</A>[<A Href=#C_8344>1</A>] continue
      return

<COMMENT>        code for increment equal to 1
</COMMENT>
   <A Name=idamax_L_20>20</A> dmax = abs(dx(1))
      <LOOP><A Name=C_8355>do</A></LOOP> <A Href=#idamax_L_30>30</A> i = 2,n<DIV ALIGN=right><INFO>lusol.f-&gt;8356</INFO></DIV>
         <TEST>if</TEST>(abs(dx(i)).le.dmax) go to 30
         idamax = i
         dmax = abs(dx(i))
   <A Name=idamax_L_30>30</A>[<A Href=#C_8355>1</A>] continue
      return
      end function <a href="lusol_f_c.html#R_idamax">idamax</a>
</PRE>
<BR><P><BR><A Href="http://sourceforge.net/projects/ftagshtml/"><IMG SRC="ftagshtml.jpg" ALT="ftagshtml's logo"></A><BR>Code lusol_mex, using FtagsHTML-0.520 by nwh, file lusol.f of 10/11/2010@12h13m19s.

</body>
</html>